#!/usr/bin/perl

use lib "/usr/lib/YaST2/agents_non_y2";
use ycp;
use strict;
use Net::LDAP;
use Net::LDAP::Entry;
use Net::LDAP::Util qw( ldap_error_name ldap_error_text);# LDAP error messages
#use Net::LDAP::Schema;
use Net::LDAP::Filter;

#use open ':utf8'; # TODO not needed?

# --------------------------------------------------------------------
# --------- global values, initialized by calling Execute (.ldap.init)

my $ldap;			# ---- main object for LDAP database
my $user_base;			# ---- DN of base for adding/editing users
my $group_base;			# ---- DN of base for adding/editing groups
my @user_object_class;		# ---- classes which user object belongs to
my @group_object_class;		# ---- classes which group object belongs to
my $bind_dn;			# ---- DN for binding to server
my $hash = "CRYPT";		# ---- how to crypt user passwords

my %users = ();			# ---- hash (map) of users, see Users::users
my %users_by_name = ();		# ---- mapping username -> uid
my @uids = ();			# ---- list of all LDAP UID's
my @usernames = ();		# ---- list of all LDAP user names
my @homes = ();			# ---- list of all LDAP home directories
my %groups = ();		# ---- hash (map) of groups, see Users::groups
my %groups_by_name = ();	# ---- hash (map) of groups, keys are groupnames
my @gids = ();			# ---- list of all LDAP GID's
my @groupnames = ();		# ---- list of all LDAP group names

my $last_ldap_uid = 1;		# ---- UID last used
my $the_answer = 42;		# ---- Definitely: this is the answer. ;-)
my $max_length_id = 5;		# ---- length of highest UID (used in widgets)

my %shadow_map = (		# ---- mapping from yast to LDAP representation
    "last_change"	=> "shadowLastChange",
    "warn"       	=> "shadowWarning",
    "inact"		=> "shadowInactive",
    "expire"		=> "shadowExpire",
    "min"		=> "shadowMin",
    "max"		=> "shadowMax");

my %optional_map = (		# ---- mapping from yast to LDAP representation
    "givenName"		=> "givenName",
    "shell"		=> "loginShell",
    "mail"		=> "mail",
    "gecos"		=> "gecos",
    "homePhone"		=> "homePhone",
    "telephoneNumber"	=> "telephoneNumber",
    "roomNumber"	=> "roomNumber");

# --------------------------------------------------------------------
# ---------- retrieve the error type
sub LDAPerror {
    (my $code) = @_;
    if ($code == 0) {
	return "";
    }
    my $error = ldap_error_name ($code);
    y2error ("LDAP error: $error");
    return $error;
}

# ---------- addBlanks to uid entry in table
sub addBlanks {
    (my $id) = @_;
    my $missing = $max_length_id - length ($id);
    if ($missing > 0)
    {
        for (my $i = 0; $i < $missing; $i++)
        {
            $id = " ".$id;
        }
    }
    return $id;
}

# ---------- form DN from username/groupname
sub get_dn {
    (my $name, my $type) = @_;
    if ($type eq "group") {
	return "cn=$name,$group_base";
    }
    else {
	my $search = "uid";			# TODO: configurable!!
	return "$search=$name,$user_base";
    }
}

# ---------- form RDN from username/groupname
sub get_rdn {
    (my $name, my $type) = @_;
    if ($type eq "group") {
	return "cn=$name";
    }
    else {
	my $search = "uid";			# TODO: configurable!!
	return "$search=$name";
    }
}

# ---------- read optional settings of one user entry
sub read_optional {
    my ($entry, $uid, $users, %map) = @_;
    foreach my $key (keys %map) {
	if (defined $entry->get_value($key)) {
	    $users->{$uid}{$map{$key}} = $entry->get_value($key);
	}
	else {
	    $users->{$uid}{$map{$key}} = "";
	}
    }
    return %{$users};
}
		
# ---------- read shadow settings of one user entry
sub read_shadow {
    my %shadow = ();
    my ($entry, %map) = @_;
    foreach my $key (keys %map) {
	if (defined $entry->get_value($key)) {
	    $shadow{$map{$key}} = $entry->get_value($key);
	}
    }
    return %shadow;
}
	    
# ---------- write optional settings of one user entry 
sub write_optional {
    my ($entry, $data, %map) = @_;
    foreach my $key (keys %map) {
	if (defined $data->{$key} && $data->{$key} ne "") {
	    $entry->add ($map{$key} => $data->{$key})
	}
    }
    return $entry;
}


# ---------- write shadow settings of one user entry 
sub write_shadow {
    my ($entry, $user, %map) = @_;
    my %shadow = %{$user->{"shadow"}};
    if (! %shadow) {
	return $entry;
    }
    else {
	return write_optional ($entry, \%shadow, %map);
    }
}

# ---------- change values in LDAP user entry
sub change_values {
    my ($replace, $data, %map) = @_;

    foreach my $key (keys %map) {
	if (defined $data->{$key} && $data->{$key} ne "") {
	    $replace->{$map{$key}} = $data->{$key};
	}
	else {
	    $replace->{$map{$key}} = [];
	}
    }
    return %{$replace};
}

# --------------------------------------------------------------------

while ( <STDIN> )
{
    my ($command, $path, $argument) = ycp::ParseCommand ($_);

    y2debug ("path: $path");
    
    if ( $command eq "Execute" )
    {
	if ( $path eq '.init' && ref ($argument) eq "HASH" ) {
	    # ------------------------------
	    # ---------- initialization
	    
	    my %ldap_conf 	= %{$argument};
	    my $host 		= $ldap_conf{"host"};
	    
	    $ldap = Net::LDAP->new($host) or ycp::Return ("initialize");

	    ycp::Return("");
	    # ---------------------------------------
	}
	elsif ( $path eq '.users.init' && ref ($argument) eq "HASH" ) {
	    # ------------------------------
	    # ---------- users initialization
	    
	    my %ldap_conf 	= %{$argument};

#TODO bind_dn argument of .bind path?
	    $bind_dn 		= $ldap_conf{'bind_dn'};
	    $user_base 		= $ldap_conf{"user_base"};
	    $group_base 	= $ldap_conf{"group_base"};
	    @user_object_class 	= $ldap_conf{"user_class"};
	    @group_object_class = $ldap_conf{"group_class"};
	    $hash 		= $ldap_conf{"pw_hash"};
	    
	    ycp::Return("");
	    # ---------------------------------------
	}
	elsif ( $path eq '.bind' && ! ref ($argument) ) {
	    
	    # ------------------------------
	    # ---------- bind to LDAP server
	    
	    my $res;
	    my $pass = $argument;

	    if (!defined $pass) {	# ----- anonymous bind
		$res = $ldap->bind ();
	    }
	    else {
		$res = $ldap->bind ($bind_dn, password => $pass);
	    }
	    ycp::Return (LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.search' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- generic ldapsearch call
	    
	    # TODO check if arguments exist (give some default values)
	    my $base	= $argument->{"base"};
	    my $scope	= $argument->{"scope"};
	    my $filter	= $argument->{"filter"};
	    my $attrs	= $argument->{"attrs"};

	    # --- do the LDAP search
	    my $mesg = $ldap->search(
		base	=> $base,
		scope	=> $scope,
		filter	=> $filter,
		attrs	=> $attrs
	    );

	    # FIXME return value can be both map and string!
	    # -> differ search and read call?
	    if ($mesg->code) {
		ycp::Return (LDAPerror ($mesg->code));
	    }

	    my @ret = ();
		
	    # --- return a map of result
	    foreach my $entry ($mesg->all_entries)
	    { 
		my %item = ();
		foreach my $attr (@{$attrs}) {

		    # --- return a list if more values are available...
		    my @list_value = $entry->get_value($attr);
		    if (scalar @list_value > 1) {
			$item{$attr} = \@list_value;
		    }
		    elsif (@list_value) {
			$item{$attr} = $entry->get_value($attr);
		    }
		}
		push @ret, \%item;
	    }
	    ycp::Return (\@ret);
	    # ---------------------------------------
	}
	elsif ( $path eq '.users.search' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- read users and groups from server

	    %users = ();
	    %users_by_name = ();
	    %groups = ();
	    %groups_by_name = ();

	    my $user_filter = $argument->{"user_filter"};
	    my $group_filter = $argument->{"group_filter"};
	    my $output_dir = $argument->{"output_dir"};
	    my %more_usersmap = ();
	    # map of groups each user is member of; indexed by usernames
	    my %users_groups = ();

	    # --- get LDAP groups 
	    my $mesg = $ldap->search(
		base => $group_base,
		filter => $group_filter,
		attrs => [ "cn", "gidNumber", "memberUid" ] );

	    if ($mesg->code) {
		ycp::Return (LDAPerror ($mesg->code));
	    }
		
	    foreach my $entry ($mesg->all_entries)
	    { 
		my $gid = $entry->get_value("gidNumber");
		my $groupname = $entry->get_value("cn");
	        $groups{$gid} = {
		    "gid"	=> $gid,
		    "groupname"	=> $groupname,
		    "type"	=> "ldap"
		};
	        # create userlist and save it to users_groups hash
		if (defined $entry->get_value("memberUid"))
		{
		    my @members = $entry->get_value("memberUid");
		    $groups{$gid}{"userlist"} = join (',', @members);
		    foreach my $u (@members) {
			push @{ $users_groups{$u}}, $groupname;
		    }
		}
	    }

	    # --- get LDAP users
	    $mesg = $ldap->search(
		base => $user_base,
		filter => $user_filter,
		attrs => [
		    "uid", "uidNumber", "gidNumber", "homeDirectory",
		    "loginShell", "cn", "mail", "sn", "givenName",
		    "shadowLastChange", "shadowWarning", "shadowInactive",
		    "shadowExpire", "shadowMin", "shadowMax",
		    "gecos", "homePhone", "telephoneNumber", "roomNumber"
		    ]);
	    
	    if ($mesg->code) {
		ycp::Return (LDAPerror ($mesg->code));
	    }

	    open YCP_LDAP_ITEMLIST, "> $output_dir/itemlist_ldap.ycp";
	    print YCP_LDAP_ITEMLIST "[\n";

	    # --- build users structures
	    foreach my $entry ($mesg->all_entries) { 
   
		my $uid = $entry->get_value("uidNumber");
    
    		if (! defined ($uid)) { # for admin?? 
		    next;
		}
		
		my $username = $entry->get_value("uid");
		my $fullname = $entry->get_value("cn");
		my $gid = $entry->get_value("gidNumber");
		my $groupname = "";
		if(defined $groups{$gid} && defined $groups{$gid}{"groupname"}){
		    $groupname = $groups{$gid}{"groupname"};
		}

		my $grouplist = "";
		if (defined $users_groups{$username}) {
		    $grouplist = join (',', @{$users_groups{$username}});
		}

		$users{$uid} = {
		    "sn"	=> $entry->get_value("sn"),
		    "home"	=> $entry->get_value("homeDirectory"),
		    "username"	=> $username,
		    "uid"	=> $uid,
		    "gid"	=> $gid,
		    "fullname"	=> $fullname,
		    "groupname"	=> $groupname,
		    "grouplist"	=> $grouplist,
		    "password"	=> "x",
		    "type"	=> "ldap"
		};

		%users = read_optional ($entry, $uid, \%users, (
		    "givenName"		=> "givenName",
		    "mail"		=> "mail",
		    "loginShell"	=> "shell",
		    "gecos"		=> "gecos",
		    "homePhone"		=> "homePhone",
		    "telephoneNumber"	=> "telephoneNumber",
		    "roomNumber"	=> "roomNumber"
		));

		my %shadow = read_shadow ($entry, (
		    "shadowLastChange"	=> "last_change",
		    "shadowWarning"	=> "warn",
		    "shadowInactive"	=> "inact",
		    "shadowExpire"	=> "expire",
		    "shadowMin"		=> "min",
		    "shadowMax"		=> "max",
		    ));
		if (%shadow) {
		    $users{$uid}{"shadow"} = \%shadow;
		}

		$users_by_name{$username} = $uid;
		push @uids, $uid;
   		push @usernames, $username;
		push @homes, $entry->get_value("homeDirectory");

		my $all_groups = $grouplist;
		if ( $groupname ne "" ) {
		    if ($grouplist eq "") {
			$all_groups = $groupname;
		    }
		    else {
			$all_groups = "$groupname,$grouplist";
		    }
		}
		# these 3 dots are for local groups
		if ($all_groups ne "") {
		    $all_groups .= ",...";
		}
		else {
		    $all_groups = "...";
		}
	        my $uid_wide = addBlanks ($uid);

	        print YCP_LDAP_ITEMLIST "\t`item(`id($uid), \"$username\", \"$fullname\", \"$uid_wide\", \"$all_groups\"),\n";

		if ($last_ldap_uid < $uid) {
		    $last_ldap_uid = $uid;
		}

		# modify default group's more_users entry
		if (defined $more_usersmap{$gid}) {
		    $more_usersmap{$gid} .= ",$username";
		}
		else {
		    $more_usersmap{$gid} = $username;
		}
	    }

	    print YCP_LDAP_ITEMLIST "]\n";
	    close YCP_LDAP_ITEMLIST;
	    
	    open YCP_LDAPGROUP_ITEMLIST, ">$output_dir/group_ldap_itemlist.ycp";
	    print YCP_LDAPGROUP_ITEMLIST "[\n";
	    
	    foreach my $gid (keys %groups)
	    {
		my $groupname = $groups{$gid}{"groupname"};
		my $all_users = $groups{$gid}{"userlist"};
		my $more_users = "";
		if (defined $more_usersmap{$gid}) {
		    $more_users = $more_usersmap{$gid};
		    $groups{$gid}{"more_users"} = $more_users;
		}
		$groups_by_name{$groupname} = $groups{$gid};

		push @groupnames, $groupname;
		push @gids, $gid;
       
		if (! defined ($all_users)) {
		    $all_users = "";
		}
		if ($all_users ne "" && $more_users ne "") {
		    $all_users .= ",";
		}
		$all_users .= $more_users;

		# shorten the list, if it is too long
	        my @users_list = split (/,/,$all_users);
	        if (@users_list > $the_answer) {
	            $all_users = "";
	            for (my $i=0; $i < $the_answer; $i++) {
	                $all_users .= "$users_list[$i],";
	            }
	            $all_users .= "...";
	        }

		my $gid_wide = addBlanks ($gid);
	        print YCP_LDAPGROUP_ITEMLIST "\t`item(`id($gid), \"$groupname\", \"$gid_wide\", \"$all_users\"),\n";
	    }

	    print YCP_LDAPGROUP_ITEMLIST "]\n";
	    close YCP_LDAPGROUP_ITEMLIST;

	    ycp::Return("");
	    # ------------------------------
	}
	else {
	    y2error ("wrong path ($path) or argument: ", ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "Read")
    {
	if ( $path eq '.filter.check' )
	{
	    my $filter = $argument;
	    my $f = Net::LDAP::Filter->new($filter);

	    if (! defined $f) {
	        y2error ("Bad filter: $filter");
	        ycp::Return ("BAD_FILTER");
	    }
	    else {
		y2milestone ("search filter:", $f->as_string());
		ycp::Return ("");
	    }
	}
	elsif ( $path eq '.users' ) {

	    ycp::Return (\%users);
	}
	elsif ( $path eq '.users.by_name' ) {

	    ycp::Return (\%users_by_name);
	}
	elsif ( $path eq '.users.homes' ) {

	    ycp::Return (\@homes);
	}
	elsif ( $path eq '.users.uids' ) {

	    ycp::Return (\@uids);
	}
	elsif ( $path eq '.users.usernames' ) {

	    ycp::Return (\@usernames);
	}
	elsif ( $path eq '.users.last_uid' ) {

	    ycp::Return ($last_ldap_uid);
	}
	elsif ( $path eq '.groups' ) {

	    ycp::Return (\%groups);
	}
	elsif ( $path eq '.groups.by_name' ) {

	    ycp::Return (\%groups_by_name);
	}
	elsif ( $path eq '.groups.gids' ) {

	    ycp::Return (\@gids);
	}
	elsif ( $path eq '.groups.groupnames' ) {

	    ycp::Return (\@groupnames);
	}
	else {
	    y2error ("wrong path ($path) or argument: ", ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "Write" )
    {
	if ( $path eq '.add' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- generic ldapadd call

	    my %item = %{$argument};
	    my $dn = $item{"dn"};

	    # ---------- form an entry with mandatory parameters
	    my $entry = Net::LDAP::Entry->new;
	    $entry->dn ($dn);
		    
	    # ---------- add optional parameters:
	    foreach my $key (keys %item) {
		if ($key ne "dn") {
		    if (ref $item{$key}) {
			y2internal ("key: $key, value:", @{$item{$key}});
			$entry->add ($key => \@{$item{$key}});
		    }
		    else {
			y2internal ("key: $key, value:", $item{$key});
			$entry->add ($key => $item{$key});
		    }
		}
	    }
	   
	    my $res = $ldap->add ($entry);
 
	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.group.add' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- add a new LDAP group

	    my %group = %{$argument};
	    my $dn = get_dn($group{"groupname"}, "group");

	    # ---------- form an entry with mandatory parameters
	    my $entry = Net::LDAP::Entry->new;
	    $entry->dn ($dn);
	    $entry->add (
		    "gidNumber" => $group{"gid"},
		    "cn" => $group{"groupname"},
		    "objectClass" => @group_object_class
	    );
	    # ---------- add optional parameters:
	    if (defined $group{"userlist"}) {
		$entry->add ("memberUid" => split (/,/,$group{"userlist"}));
	    }
	    if (defined $group{"password"}) {
		$entry->add ("userPassword" => "{$hash}".$group{"password"});
	    }
	   
	    my $res = $ldap->add ($entry);
 
	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( ($path eq '.group.modify' || $path eq '.group.edit') &&
		 ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- modify an existing LDAP group

	    my %group = %{$argument};
	    my $groupname 	= $group{"groupname"};
	    my $org_groupname	= $groupname;
	    if (defined $group{"org_groupname"} &&
		$group{"org_groupname"} ne "")
	    {
		$org_groupname = $group{"org_groupname"};
	    }
	    my $dn		= get_dn($org_groupname, "group");
	    
	    # ---------- modify required parameters
	    my %replace = (
		    "gidNumber" => $group{"gid"},
		    "cn"	=> $groupname,
	    );

	    # ---------- modify optional parameters
	    if (defined $group{"userlist"}) {
		@{$replace{"memberUid"}} = split (/,/,$group{"userlist"});
	    }
	    if (defined $group{"password"}) {
		$replace{"userPassword"} = "{$hash}".$group{"password"};
	    }
	   
	    my $res = $ldap->modify ($dn, replace => \%replace);
	    my $ret = LDAPerror ($res->code);
	    
	    if ( $ret eq "" && $org_groupname ne $groupname ) {
		$res = $ldap->moddn($dn,newrdn => get_rdn($groupname, "group"));
		$ret = LDAPerror ($res->code);
	    }
	    ycp::Return($ret);
	    # ---------------------------------------
	}
	elsif ( $path eq '.group.delete' && ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- delete an existing LDAP group

	    my $groupname = $argument->{"groupname"};
	    my $res = $ldap->delete (get_dn($groupname, "group"));

	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.user.add' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- add a new LDAP user

	    my %user = %{$argument};
	    my $username = $user{"username"};
	    my $dn = get_dn($username, "user");

	    # ---------- form an entry with mandatory parameters
	    my $entry = Net::LDAP::Entry->new;
	    $entry->dn ($dn);
	    $entry->add (
		    "uid" => $username,
		    "uidNumber" => $user{"uid"},
		    "gidNumber" => $user{"gid"},
		    "homeDirectory" => $user{"home"},
		    "cn" => $user{"fullname"},
		    "sn" => $user{"sn"},
		    "objectClass" => @user_object_class
	    );
	    if (defined $user{"password"} && $user{"password"} ne "x") {
		$entry->add ("userPassword" => "{$hash}".$user{"password"});
	    }
	    # ---------- add optional and shadow parameters
	    
	    $entry = write_optional ($entry, \%user, %optional_map);
	    $entry = write_shadow ($entry, \%user, %shadow_map);
   
	    my $res = $ldap->add ($entry);
	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( ($path eq '.user.modify' || $path eq '.user.edit') &&
		 ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- modify an existing LDAP user

	    my %user = %{$argument};
	    my $username 	= $user{"username"};
	    my $org_username	= $username;
	    if (defined $user{"org_username"} && $user{"org_username"} ne "") {
		$org_username = $user{"org_username"};
	    }
	    my $dn		= get_dn($org_username, "user");
	    
	    # ---------- modify required parameters
	    my %replace = (
		"uid"		=> $username,
		"uidNumber"	=> $user{"uid"},
		"gidNumber"	=> $user{"gid"},
		"homeDirectory" => $user{"home"},
		"cn"		=> $user{"fullname"},
		"sn"		=> $user{"sn"},
	    );
	    if (defined $user{"password"} && $user{"password"} ne "x") {
		$replace{"userPassword"} = "{$hash}".$user{"password"};
	    }
	    # ---------- modify optional and shadow parameters

	    %replace = change_values (\%replace, \%user, %optional_map);
	    %replace = change_values
		(\%replace, \%{$user{"shadow"}}, %shadow_map);

	    my $res = $ldap->modify ($dn, replace => \%replace);
	    my $ret = LDAPerror ($res->code);
	    
	    if ( $ret eq "" && $org_username ne $username ) {
		$res = $ldap->moddn ($dn, newrdn => get_rdn($username, "user"));
		$ret = LDAPerror ($res->code);
	    }
	    ycp::Return($ret);
	    # ---------------------------------------
	}
	elsif ( $path eq '.user.delete' && ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- delete an existing LDAP user

	    my $username = $argument->{"username"};
	    my $res = $ldap->delete (get_dn($username, "user"));

	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	else {
	    y2error ("wrong path ($path) or argument:", ref ($argument));
	    ycp::Return("wrong path ($path) or argument");
	}
    }
    elsif ($command eq "result")
    {
	if (defined $ldap) {
	    $ldap->unbind;
	}
	exit;
    }
    else
    {
	y2error ("wrong command: ", $command);
	ycp::Return("wrong command ($command)");
    }
}

# end
