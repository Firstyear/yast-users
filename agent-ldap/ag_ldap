#!/usr/bin/perl

use lib "/usr/lib/YaST2/agents_non_y2";
use ycp;
use strict;
use Net::LDAP;
use Net::LDAP::Entry;
use Net::LDAP::Util qw( ldap_error_name ldap_error_text);# LDAP error messages
#use Net::LDAP::Schema;

#use open ':utf8'; # TODO not needed?

# --------------------------------------------------------------------
# --------- global values, initialized by calling Execute (.ldap.init)

my $ldap;			# ---- main object for LDAP database
my $user_base;			# ---- DN of base for adding/editing users
my $group_base;			# ---- DN of base for adding/editing groups
my @user_object_class;		# ---- classes which user object belongs to
my @group_object_class;		# ---- classes which group object belongs to
my $bind_dn;			# ---- DN for binding to server
my $hash = "CRYPT";		# ---- how to crypt user passwords

my %users = ();			# ---- hash (map) of users, see Users::users
my %users_by_name = ();		# ---- mapping username -> uid
my @uids = ();			# ---- list of all LDAP UID's
my @usernames = ();		# ---- list of all LDAP user names
my @homes = ();			# ---- list of all LDAP home directories
my %groups = ();		# ---- hash (map) of groups, see Users::groups
my %groups_by_name = ();	# ---- hash (map) of groups, keys are groupnames
my @gids = ();			# ---- list of all LDAP GID's
my @groupnames = ();		# ---- list of all LDAP group names

my $last_ldap_uid = 1;		# ---- UID last used
my $the_answer = 42;		# ---- Definitely: this is the answer. ;-)
my $max_length_id = 5;		# ---- length of highest UID (used in widgets)

# --------------------------------------------------------------------
# ---------- retrieve the error type
sub LDAPerror {
    (my $code) = @_;
    if ($code == 0) {
	return "";
    }
    my $error = ldap_error_name ($code);
    y2error ("LDAP error: $error");
    return $error;
}

# ---------- addBlanks to uid entry in table
sub addBlanks {
    (my $id) = @_;
    my $missing = $max_length_id - length ($id);
    if ($missing > 0)
    {
        for (my $i = 0; $i < $missing; $i++)
        {
            $id = " ".$id;
        }
    }
    return $id;
}

# ---------- form DN from username/groupname
sub get_dn {
    (my $name, my $type) = @_;
    my $search = "uid";			# TODO: configurable!!
    if ($type eq "group") {
	return "cn=$name,$group_base";
    }
    else {
	return "uid=$name,$user_base";
    }
}

# --------------------------------------------------------------------

while ( <STDIN> )
{
    my ($command, $path, $argument) = ycp::ParseCommand ($_);

    y2debug ("path: $path");
    
    if ( $command eq "Execute" )
    {
	if ( $path eq '.init' && ref ($argument) eq "HASH" ) {
	    
	    # ------------------------------
	    # ---------- initialization
	    
	    my %ldap_conf 	= %{$argument};

	    my $host 		= $ldap_conf{"host"};
	    $bind_dn 		= $ldap_conf{'bind_dn'};
	    $user_base 		= $ldap_conf{"user_base"};
	    $group_base 	= $ldap_conf{"group_base"};
	    @user_object_class 	= $ldap_conf{"user_class"};
	    @group_object_class = $ldap_conf{"group_class"};
	    $hash 		= $ldap_conf{"pw_hash"};
	    
	    $ldap = Net::LDAP->new($host) or ycp::Return ("initialize");

	    ycp::Return("");
	    # ---------------------------------------
	}
	elsif ( $path eq '.bind' && ! ref ($argument) ) {
	    
	    # ------------------------------
	    # ---------- bind to LDAP server
	    
	    my $res;
	    
	    my $pass = $argument;
	    if ($pass eq "") {
		$res = $ldap->bind ();
	    }
	    else {
		$res = $ldap->bind ($bind_dn, password => $pass);
	    }

	    ycp::Return (LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.search' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- read users and groups from server

	    my $user_filter = $argument->{"user_filter"};
	    my $group_filter = $argument->{"group_filter"};
	    my $output_dir = $argument->{"output_dir"};
	    my %more_usersmap = ();
	    # list of groups each user is member of; indexed by usernames
	    my %users_groups = ();

	    # --- get LDAP groups 
	    my $mesg = $ldap->search(
		base => $group_base,
		filter => $group_filter,
		attrs => [ "cn", "gidNumber", "memberUid" ] );

	    if ($mesg->code) {
		ycp::Return (LDAPerror ($mesg->code));
	    }
		
	    foreach my $entry ($mesg->all_entries)
	    { 
		my $gid = $entry->get_value("gidNumber");
		my $groupname = $entry->get_value("cn");
	        $groups{$gid} = {
		    "gid"	=> $gid,
		    "groupname"	=> $groupname,
		    "type"	=> "ldap"
		};
	        # create userlist and save it to users_groups hash
		if (defined $entry->get_value("memberUid"))
		{
		    my @members = $entry->get_value("memberUid");
		    $groups{$gid}{"userlist"} = join (',', @members);
		    foreach my $u (@members) {
			push @{ $users_groups{$u}}, $groupname;
		    }
		}
# userPasword is not searched for
#		if (defined $entry->get_value("userPassword")) {
#		    $groups{$gid}{"password"} = "x";
#		}
	    }

	    # --- get LDAP users

	    $mesg = $ldap->search(
		base => $user_base,
		filter => $user_filter,
		attrs => [
		    "uid", "uidNumber", "gidNumber", "homeDirectory",
		    "loginShell", "cn", "mail", "sn", "givenName"]);
	    
	    if ($mesg->code) {
		ycp::Return (LDAPerror ($mesg->code));
	    }

	    open YCP_LDAP_ITEMLIST, "> $output_dir/itemlist_ldap.ycp";
	    print YCP_LDAP_ITEMLIST "[\n";

	    # --- build users structures
	    foreach my $entry ($mesg->all_entries) { 
   
		my $uid = $entry->get_value("uidNumber");
    
    		if (! defined ($uid)) { # for admin?? 
		    next;
		}
		
		my $username = $entry->get_value("uid");
		my $fullname = $entry->get_value("cn");
		my $gid = $entry->get_value("gidNumber");
		my $groupname = $groups{$gid}{"groupname"};
		if (! defined ($groupname)) {
		    $groupname = "";
		}

		my $grouplist = "";
		if (defined $users_groups{$username}) {
		    $grouplist = join (',', @{$users_groups{$username}});
		}

		$users{$uid} = {
		    "sn"	=> $entry->get_value("sn"),
		    "home"	=> $entry->get_value("homeDirectory"),
		    "username"	=> $username,
		    "uid"	=> $uid,
		    "gid"	=> $gid,
		    "fullname"	=> $fullname,
		    "groupname"	=> $groupname,
		    "grouplist"	=> $grouplist,
		    "password"	=> "x",
		    "type"	=> "ldap"
		};

		if (defined $entry->get_value("givenName")) {
		    $users{$uid}{"givenName"} = $entry->get_value("givenName");
		}
		if (defined $entry->get_value("mail")) {
		    $users{$uid}{"mail"} = $entry->get_value("mail");
		}
		if (defined $entry->get_value("loginShell")) {
		    $users{$uid}{"shell"} = $entry->get_value("loginShell");
		}

		$users_by_name{$username} = $uid;
		push @uids, $uid;
   		push @usernames, $username;
		push @homes, $entry->get_value("homeDirectory");

		my $all_groups = $grouplist;
		if ( $groupname ne "" ) {
		    if ($grouplist eq "") {
			$all_groups = $groupname;
		    }
		    else {
			$all_groups = "$groupname,$grouplist";
		    }
		}
		# these 3 dots are for local groups
		if ($all_groups ne "") {
		    $all_groups .= ",...";
		}
		else {
		    $all_groups = "...";
		}
	        my $uid_wide = addBlanks ($uid);

	        print YCP_LDAP_ITEMLIST "\t`item(`id($uid), \"$username\", \"$fullname\", \"$uid_wide\", \"$all_groups\"),\n";

		if ($last_ldap_uid < $uid) {
		    $last_ldap_uid = $uid;
		}

		# modify default group's more_users entry
		if (defined $more_usersmap{$gid}) {
		    $more_usersmap{$gid} .= ",$username";
		}
		else {
		    $more_usersmap{$gid} = $username;
		}
	    }

	    print YCP_LDAP_ITEMLIST "]\n";
	    close YCP_LDAP_ITEMLIST;
	    
	    open YCP_LDAPGROUP_ITEMLIST, ">$output_dir/group_ldap_itemlist.ycp";
	    print YCP_LDAPGROUP_ITEMLIST "[\n";
	    
	    foreach my $gid (keys %groups)
	    {
		my $groupname = $groups{$gid}{"groupname"};
		my $all_users = $groups{$gid}{"userlist"};
		my $more_users = "";
		if (defined $more_usersmap{$gid}) {
		    $more_users = $more_usersmap{$gid};
		    $groups{$gid}{"more_users"} = $more_users;
		}
 
		$groups_by_name{$groupname} = $groups{$gid};

		push @groupnames, $groupname;
		push @gids, $gid;
       
		if (! defined ($all_users)) {
		    $all_users = "";
		}
		if ($all_users ne "" && $more_users ne "") {
		    $all_users .= ",";
		}
		$all_users .= $more_users;

		# shorten the list, if it is too long
	        my @users_list = split (/,/,$all_users);
	        if (@users_list > $the_answer) {
	            $all_users = "";
	            for (my $i=0; $i < $the_answer; $i++) {
	                $all_users .= "$users_list[$i],";
	            }
	            $all_users .= "...";
	        }

		my $gid_wide = addBlanks ($gid);
	        print YCP_LDAPGROUP_ITEMLIST "\t`item(`id($gid), \"$groupname\", \"$gid_wide\", \"$all_users\"),\n";
	    }

	    print YCP_LDAPGROUP_ITEMLIST "]\n";
	    close YCP_LDAPGROUP_ITEMLIST;

	    ycp::Return("");
	    # ------------------------------
	}
	else {
	    y2error ("wrong path ($path) or argument: ", ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "Read")
    {
	if ( $path eq '.users' ) {

	    ycp::Return (\%users);
	}
	elsif ( $path eq '.users.by_name' ) {

	    ycp::Return (\%users_by_name);
	}
	elsif ( $path eq '.users.homes' ) {

	    ycp::Return (\@homes);
	}
	elsif ( $path eq '.users.uids' ) {

	    ycp::Return (\@uids);
	}
	elsif ( $path eq '.users.usernames' ) {

	    ycp::Return (\@usernames);
	}
	elsif ( $path eq '.users.last_uid' ) {

	    ycp::Return ($last_ldap_uid);
	}
	elsif ( $path eq '.groups' ) {

	    ycp::Return (\%groups);
	}
	elsif ( $path eq '.groups.by_name' ) {

	    ycp::Return (\%groups_by_name);
	}
	elsif ( $path eq '.groups.gids' ) {

	    ycp::Return (\@gids);
	}
	elsif ( $path eq '.groups.groupnames' ) {

	    ycp::Return (\@groupnames);
	}
	else {
	    y2error ("wrong path ($path) or argument: ", ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "Write" )
    {
	if ( $path eq '.group.add' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- add a new LDAP group

	    my %group = %{$argument};
	    my $dn = get_dn($group{"groupname"}, "group");

	    # ---------- form an entry with mandatory parameters
	    my $entry = Net::LDAP::Entry->new;
	    $entry->dn ($dn);
	    $entry->add (
		    "gidNumber" => $group{"gid"},
		    "cn" => $group{"groupname"},
		    "objectClass" => @group_object_class
	    );
	    # ---------- add optional parameters:
	    if (defined $group{"userlist"}) {
		$entry->add ("memberUid" => split (/,/,$group{"userlist"}));
	    }
	    if (defined $group{"password"}) {
		$entry->add ("userPassword" => "{$hash}".$group{"password"});
	    }
	   
	    my $res = $ldap->add ($entry);
 
	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( ($path eq '.group.modify' || $path eq '.group.edit') &&
		 ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- modify an existing LDAP group

	    my %group = %{$argument};
	    my $dn = get_dn($group{"groupname"}, "group");
	    
	    # ---------- modify required parameters
	    my %replace = (
		    "gidNumber" => $group{"gid"},
		    "cn" => $group{"groupname"},
	    );

	    # ---------- modify optional parameters
	    if (defined $group{"userlist"}) {
		@{$replace{"memberUid"}} = split (/,/,$group{"userlist"});
	    }
	    if (defined $group{"password"}) {
		$replace{"userPassword"} = "{$hash}".$group{"password"};
	    }
	   
	    my $res = $ldap->modify ($dn, replace => \%replace);
	    
	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.group.delete' && ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- delete an existing LDAP group

	    my $groupname = $argument->{"groupname"};
	    my $res = $ldap->delete (get_dn($groupname, "group"));

	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.add' && ref ($argument) eq "HASH" ) {

	    # ------------------------------
	    # ---------- add a new LDAP user

	    my %user = %{$argument};
y2internal ("user: ", %user);
	    my $username = $user{"username"};
	    my $dn = get_dn($username, "user");

	    # ---------- form an entry with mandatory parameters
	    my $entry = Net::LDAP::Entry->new;
	    $entry->dn ($dn);
	    $entry->add (
		    "uid" => $username,
		    "uidNumber" => $user{"uid"},
		    "gidNumber" => $user{"gid"},
		    "homeDirectory" => $user{"home"},
		    "cn" => $user{"fullname"},
		    "sn" => $user{"sn"},
		    "objectClass" => @user_object_class
	    );
	    # ---------- add optional parameters
	    # TODO: new values
	    if (defined $user{"givenName"} && $user{"givenName"} ne "") {
		$entry->add ("givenName" => $user{"givenName"});
	    }
	    if (defined $user{"shell"} && $user{"shell"} ne "") {
		$entry->add ("loginShell" => $user{"shell"});
	    }
	    if (defined $user{"password"} && $user{"password"} ne "x") {
		$entry->add ("userPassword" => "{$hash}".$user{"password"});
	    }
	    if (defined $user{"mail"} && $user{"mail"} ne "") {
		$entry->add ("mail" => $user{"mail"});
	    }
	   
	    my $res = $ldap->add ($entry);

	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( ($path eq '.modify' || $path eq '.edit') &&
		 ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- modify an existing LDAP user

	    my %user = %{$argument};
	    my $dn = get_dn($user{"username"}, "user");
	    
	    # ---------- modify required parameters
	    my %replace = (
		    "uid" => $user{"username"},
		    "uidNumber" => $user{"uid"},
		    "gidNumber" => $user{"gid"},
		    "homeDirectory" => $user{"home"},
		    "cn" => $user{"fullname"},
		    "sn" => $user{"sn"},
	    );
	    # ---------- modify optional parameters
	    if (defined $user{"givenName"} && $user{"givenName"} ne "") {
		$replace{"givenName"} = $user{"givenName"};
	    }
	    else {
		$replace{"givenName"} = [];
	    }
	    if (defined $user{"shell"} && $user{"shell"} ne "") {
		$replace{"loginShell"} = $user{"shell"};
	    }
	    else {
		$replace{"loginShell"} = [];
	    }
	    if (defined $user{"mail"} && $user{"mail"} ne "") {
		$replace{"mail"} = $user{"mail"};
	    }
	    else {
		$replace{"mail"} = [];
	    }
	    if (defined $user{"password"} && $user{"password"} ne "x") {
		$replace{"userPassword"} = "{$hash}".$user{"password"};
	    }
	   
	    my $res = $ldap->modify ($dn, replace => \%replace);

	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	elsif ( $path eq '.delete' && ref ($argument) eq "HASH" ) {
	    
	    # ---------------------------------------
	    # ---------- delete an existing LDAP user

	    my $username = $argument->{"username"};
	    my $res = $ldap->delete (get_dn($username, "user"));

	    ycp::Return(LDAPerror ($res->code));
	    # ---------------------------------------
	}
	else {
	    y2error ("wrong path ($path) or argument:", ref ($argument));
	    ycp::Return("wrong path ($path) or argument");
	}
    }
    elsif ($command eq "result")
    {
	if (defined $ldap) {
	    $ldap->unbind;
	}
	exit;
    }
    else
    {
	y2error ("wrong command: ", $command);
	ycp::Return("wrong command ($command)");
    }
}

# end
