/**
 * File:	modules/UsersCache.ycp
 * Package:	Configuration of users and groups
 * Summary:	Helper functions and cache structures for use from Users module
 *
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *		Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{

module "UsersCache";
textdomain "users";

import "Mode";

include "users/passwd.ycp";

// map of list of home directories
global map homelists = $[];
// map of list of usernames
global map usernamelists = $[];

//list of all but system usernames
global list usernamelist = [];

// list of user DN's (LDAP only)
global list userdnlist	= [];
/**
 * map of lists of usernames removed so far
 */
global map removed_usernamelists = $[];
// map of list of groupnames
global map groupnamelists = $[];
// map of list of all items in user table
global map users_itemlists = $[];
// map of list of all items in group table
global map groups_itemlists = $[];
// map of list of current items in user table
global list user_itemlist = [];
// map of list of current items in group table
global list group_itemlist = [];
// item list of all users used in edit group dialog
global list additional_users = [];
// map of list of uid's
global map uidlists = $[];
/**
 * map of lists of usernames removed so far
 */
global map removed_uidlists = $[];
// map of list of gid's
global map gidlists = $[];
global list current_users = [];
global list current_groups = [];
global list user_custom_sets = [];
global list group_custom_sets = [];

// type of current user/group
global string user_type = "local";
global string group_type = "local";

global integer focusline_group = nil;
global integer focusline_user  = nil;

global map max_uid  = $[];
global map max_gid  = $[];
global map min_uid  = $[];
global map min_gid  = $[];
global integer max_length_uid = 5;
global integer max_length_gid = 5;
global integer max_length_login = 32; // see for example man utmp, UT_NAMESIZE
global integer min_length_login = 2;
global integer max_length_groupname = 8;
global integer min_length_groupname = 2;
global boolean ldap_file_server = false;

// if currrent view is "customized"
global boolean customized_usersview = true;
global boolean customized_groupsview = true;

global string encoding = "";

// usernames generated by "Propose" button
global list proposed_usernames = [];
// number of clicks of "Propose" (-1 means: generate new list)
global integer proposal_count = -1;


/**
 * map of last uid used for new user (to fasten searching of free uid)
 */
global map last_uid = $[
    "system": 100,
    "local": 500,
    "ldap": 500];

global map last_gid = $[
    "system": 100,
    "local": 1000,
    "ldap": 500];

/**
 * Builds the list of uid's
 * @param usersset map of users of one type
 * @return list of id's
 */
global define list BuildUIDList(map usersset) ``{

    list ret = [];
    foreach (integer uid, map usersmap, usersset, ``{
	ret = add (ret, uid);
    });
    return ret;
}

/**
 * Builds the list of home directories of given users
 * @param usersmap map of users of one type
 * @return list of homedirs
 */
global define list BuildHomeList(map usersmap) ``{

    list ret = [];
    foreach (integer k, map v, usersmap, ``{
        if (v["home"]:nil != nil)
            ret = add (ret, v["home"]:nil);
    });
    return ret;
}

/**
 * Builds the list of user names
 * @param usersmap map of users of one type
 * @return list of names
 */
global define list BuildUsernameList(map usersmap) ``{

    list ret = [];
    foreach (integer k, map v, usersmap, ``{
        if (v["username"]:nil != nil)
            ret = add (ret, v["username"]:nil);
    });
    return ret;
}

/**
 * Build a string with n blanks
 * @param count number of blanks
 * @return string of blanks
 */
define string addBlanks(integer count ) ``{
    string  blanks = "";
    integer blanks_counter = 0;

    while (  blanks_counter < count )
    {
        blanks_counter = blanks_counter + 1;
//        blanks         = blanks + "\302\240"; // why this ??
        blanks         = blanks + " ";
    }
    return blanks;
}


/**
 * Builds item list for the user table
 * @param map_of_users users of one type
 * @return list of items for table widget
 */
global define list BuildUserItemList(map map_of_users) ``{

    list items = [];
    foreach ( integer key, map user,  map_of_users, ``{
        string username = user["username"]:"";
        string full	= user["cn"]:"";
        string  s_uid = sformat("%1", key );
        term    a     = `item(`id(key));

        if( size(s_uid) !=  max_length_uid )
            s_uid = addBlanks(max_length_uid - size(s_uid)) + s_uid;

        a = add(a, username );

        if (user["type"]:"local" == "system")
            a = add(a, SystemUsers [full]:full );
        else
            a = add(a, full );

        a = add(a, s_uid );

        string own_group = user["groupname"]:"";
        string grouplist = user["grouplist"]:"";
        list l_grouplist = splitstring (grouplist, ",");

        if ( !contains (l_grouplist, own_group) && own_group != "")
        {
            if (grouplist != "")
                    grouplist = own_group + "," + grouplist;
            else
                grouplist = own_group;
        }

        a = add(a, grouplist );
        items = add( items, a );
    });

    return items;
}


/**
 * Build the cache structures for user set
 * @param usersmap map of users of one type
 * @param type the users type
 */
global define void BuildUsers (map usersmap, string type) ``{

    homelists = add (homelists, type, BuildHomeList (usersmap));
    usernamelists = add (usernamelists, type, BuildUsernameList (usersmap));
    users_itemlists = add (users_itemlists, type,
        BuildUserItemList(usersmap));
    uidlists [type] = BuildUIDList(usersmap);
    last_uid [type] = min_uid [type]:0;
}

/**
 * Merge the users's item lists of types included in "custom view" to one list
 * @return new table itemlist
 */
global define list MergeUserTableItems() ``{

    list items = [];
    foreach (string usersset, user_custom_sets, ``{
        items = merge(items, users_itemlists [ usersset ]:[]);
    });
    return items;
}

/**
 * Builds the list of group names
 * @param groupsmap map of groups of one type
 * @return list of names
 */
global define list BuildGroupnameList(map groupsmap) ``{

    list ret = [];
    foreach (integer k, map v, groupsmap, ``{
        if (v["groupname"]:nil != nil)
            ret = add (ret, v["groupname"]:nil);
    });
    return sort (ret); //-- is this needed??
}


/**
 * Builds the list of gid's
 * @param groupsset map of groups of one type
 * @return list of id's
 */
global define list BuildGIDList(map groupsset) ``{

    list ret = [];
    foreach (integer gid, map groupsmap, groupsset, ``{
            ret = add (ret, gid);
    });
    return ret;
}

/**
 * Builds item list for the group table
 * @param map_of_groups groups of one type
 * @return list of items for table widget
 */
global define list BuildGroupItemList(map map_of_groups) ``{

    integer the_answer = 42;
    list items = [];
    foreach ( integer key, map group, map_of_groups, ``{

        string  s_gid = sformat("%1", key   );
        term    a     = `item(`id(key));

        if( size( s_gid) != max_length_gid )
            s_gid = addBlanks( max_length_gid - size(s_gid)) + s_gid;

        a = add (a, group["groupname"]:"" );
        a = add (a, s_gid);

        string userlist = group["userlist"]:"";

        string more = group["more_users"]:"";
        if ((userlist != "") && (more != ""))
            userlist = userlist + ",";
        userlist = userlist + more;
        list all_users = splitstring (userlist, ",");
	// ldap groups have list of user dn's...
	if (group_type == "ldap")
	{
	    all_users = merge (all_users,
		maplist (string dn, group["uniqueMember"]:[], ``{
		    list dn_l = splitstring (dn, ",");
		    return substring (dn_l[0]:"", find (dn_l[0]:"", "=")+1);
		}));
	    if (size (all_users) <= the_answer)
		userlist = mergestring (all_users, ",");
	}
        // shorten the list, if it is too long:
        if (size (all_users) > the_answer)
        {
            userlist = "";
            integer i = 0;
            while (i < the_answer)
            {
                userlist = userlist + all_users[i]:"" + ",";
                i = i + 1;
            }
            userlist = userlist + "...";
        }
        a = add(a, userlist);

        items = add( items, a );
    });
    return items;
}


/**
 * Build the cache structures for group set
 * @param groupsmap map of groups of one type
 * @param type the groups type
 */
global define void BuildGroups (map groupsmap, string type) ``{

    if (groupnamelists [type]:nil == nil)
        groupnamelists [type] = BuildGroupnameList (groupsmap);
    groups_itemlists [type] = BuildGroupItemList(groupsmap);

    gidlists [type] = BuildGIDList(groupsmap);
}

/**
 * Merge the groups's item lists of types included in "custom view" to one list
 * @return new table itemlist
 */
global define list MergeGroupTableItems() ``{

    list items = [];
    foreach (string groupsset, group_custom_sets, ``{
        items = merge(items, groups_itemlists [ groupsset ]:[]);
    });
    return items;
}


/**
 * Build the cache structures, used for fasten operations
 * @param usermap the map of users
 * @param groupmap the map of groups
 * @param cust_u custom view of user sets
 * @param cust_g custom view of group sets
 * @return true
 */
global define boolean Read(map usermap, map groupmap, list cust_u, list cust_g) ``{

    current_users = user_custom_sets;

    foreach (string type, map usersmap, usermap, ``{
        BuildUsers (usersmap, type);
    });
    users_itemlists [ "custom" ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ "custom" ]:[];

    current_groups = group_custom_sets;

    foreach (string type, map groupsmap, groupmap, ``{
        BuildGroups (groupsmap, type);
    });
    groups_itemlists [ "custom" ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ "custom" ]:[];

    return true;
}

/**
 * Read the prepared user data from the files
 * @param type the type of users
 * @param dir the source directory
 * @return true
 */
global define boolean ReadUsers (string type, string dir) ``{

    if (type == "ldap")
    {
	homelists [type] = SCR::Read(.ldap.users.homes);
        usernamelists [type] = SCR::Read(.ldap.users.usernames);
        userdnlist = (list) SCR::Read(.ldap.users.userdns);

	users_itemlists [type] =
	    SCR::Read (.ldap.users.itemlist);

	uidlists [type] = SCR::Read (.ldap.users.uids);
	// last_uid is set in ReadLDAPSettings (ldap_routines.ycp)

	usernamelist = union (usernamelist, sort (usernamelists [type]:[]));
	return true;
    }
    homelists [type] = SCR::Read(.target.ycp, dir + "/homelist_" +type+ ".ycp");
    usernamelists [type] = SCR::Read(.target.ycp, dir + "/usernamelist_" +
        type + ".ycp");

    // eval due to translation of system user names
    users_itemlists [type] = eval (
        SCR::Read(.target.ycp, dir + "/itemlist_" + type + ".ycp"));

    uidlists [type] = SCR::Read(.target.ycp, dir + "/uidlist_" + type + ".ycp");
    if (type != "nis")
    {
        last_uid [type] = SCR::Read (.target.ycp, dir + "/last_" +
            type + "_uid.ycp");
	if (last_uid [type]:0 < min_uid [type]:0)
	    last_uid [type] = min_uid [type]:0;
    }
    if (type != "system")
	usernamelist = union (usernamelist, sort (usernamelists [type]:[]));

    return true; // TODO: test for errors while reading
}

/**
 * Read the prepared group data from the files
 * @param type the type of groups
 * @param dir the source directory
 * @return true
 */
global define boolean ReadGroups (string type, string dir) ``{

    if (type == "ldap")
    {
        gidlists [type] = SCR::Read (.ldap.groups.gids);
	groupnamelists [type] = SCR::Read (.ldap.groups.groupnames);
	groups_itemlists [type] = SCR::Read(.ldap.groups.itemlist);
    }
    else
    {
	gidlists [type] = SCR::Read (.target.ycp, dir + "/gidlist_" +
	    type + ".ycp");
	groupnamelists [type] = SCR::Read (.target.ycp, dir + "/groupnamelist_"
	    + type + ".ycp");
	groups_itemlists [type] = SCR::Read(.target.ycp, dir + "/group_"
	    + type + "_itemlist.ycp");
    }

    return true;
}

/**
 * Read the prebuilded cache structures from files
 * @param dir the location of input files
 * @return true
 */
global define void ReadFromFiles (string dir) ``{

    current_users = user_custom_sets;

    // could be the sets here explicitly?
    list start_sets = ["local", "system"];
    foreach (string type, start_sets , ``{
        ReadUsers (type, dir);
    });
    users_itemlists [ "custom" ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ "custom" ]:[];

    foreach (string type, start_sets , ``{
        ReadGroups (type, dir);
    });
    groups_itemlists [ "custom" ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ "custom" ]:[];

}


/**
 * Reset the structures, to use during autoinstallation
 */
global define void EmptyStructures () ``{

    homelists = $[];
    usernamelists = $[];
    uidlists = $[];
    groupnamelists = $[];
    gidlists = $[];
}

/**
 * Uncode the string.
 * @param from string
 * @return string string recoded to UTF
 */
global define string Uncoding( string from ) ``{

    if (from == "" || from == nil)
        return "";
    else
        return UI::Recode( encoding, "UTF-8",  from );

}

/**
 * Change the list defining user's "custom view"
 * @param new new customized list
 */
global define void ChangeUserCustoms (list new) ``{

    user_custom_sets = new;
    users_itemlists ["custom"] = MergeUserTableItems();
    customized_usersview = true;
    user_itemlist = users_itemlists ["custom"]:[];
}

/**
 * Change the list defining group's "custom view"
 * @param new new customized list
 */
global define void ChangeGroupCustoms (list new) ``{

    group_custom_sets = new;
    groups_itemlists ["custom"] = MergeGroupTableItems();
    customized_groupsview = true;
    group_itemlist = groups_itemlists ["custom"]:[];
}

/**
 * Check if homedir doesn't exist for another user
 * Doesn't check directory existence, only looks to set of used directories
 * @param home the name
 * @return true if directory is used as another user's home directory
 */
global define boolean HomeExists(string home) ``{

    boolean ret = false;

    list sets_to_check = ["local", "system"];
    if (ldap_file_server)
    {
	sets_to_check = add (sets_to_check, "ldap");
    }
    else if (user_type == "ldap") //ldap, client only
    {
	sets_to_check = ["ldap"];
    }

    foreach (string type, sets_to_check, ``{
        if ( contains (homelists[type]:[], home)) ret = true;
    });

    return ret;
}


/**
 * Asks agent if given ID is not UID of any user in system
 * @param uid ID to check
 * @return false when UID already exists
 */
global define boolean IsIDUnique (integer uid) ``{

    return (boolean) SCR::Read (.uid.uid, uid);
}

/**
 * Asks agent if given name is not username of any user in system
 * @param username name to check
 * @return false when username already exists
 */
global define boolean IsUsernameUnique (string username) ``{

    return (boolean) SCR::Read (.uid.username, username);
}


/**
 * Check if username already exists
 * @param username username
 * @return true if exists
 */
global define boolean UsernameExists(string username) ``{

    boolean ret = false;
    foreach (string type, list usernames, usernamelists, ``{
	if ( !ret && contains (usernames, username)) ret = true;
    });
    // for autoyast, check only loaded sets
    if (Mode::config || ret)
	return ret;
    // not found -> check all sets via agent...
    ret = !IsUsernameUnique (username);
    if (ret)
    {
	// check if username wasn't just deleted...
	list sets_to_check = ["local", "system"];
	if (user_type != "ldap")
	{
	    sets_to_check = add (sets_to_check, "ldap");
	}
	foreach (string type, sets_to_check, ``{
	    if (contains (removed_usernamelists[type]:[],username)) ret = false;
	});
    }
    return ret;
}

/**
 * Check if UID doesn't already exist
 * @param uid UID
 * @return true if exists
 */
global define boolean UIDExists(integer uid) ``{

    boolean ret = false;
    foreach (string type, list uids, uidlists, ``{
	if ( !ret && contains (uids, uid)) ret = true;
    });
    // for autoyast, check only loaded sets
    if (Mode::config || ret)
	return ret;
    // not found -> check all sets via agent...
    ret = !IsIDUnique (uid);
    if (ret)
    {
	// check if uid wasn't just deleted...
	list sets_to_check = ["local", "system"];
	// LDAP: do not allow change uid of one user and use old one by
	// another user - because users are saved by calling extern tool
	// and colisions can be hardly avoided
	if (user_type != "ldap")
	{
	    sets_to_check = add (sets_to_check, "ldap");
	}
	foreach (string type, sets_to_check, ``{
	    if (contains (removed_uidlists[type]:[], uid)) ret = false;
	});
    }
    return ret;
}

/**
 * Check if GID doesn't already exist
 * @param gid GID
 * @return true if exists
 */
global define boolean GIDExists(integer gid) ``{

    // TODO: display warning if GID exists in other set?
    if (group_type == "ldap")
    {
	return contains (gidlists [group_type]:[], gid);
    }
    return (contains (gidlists ["local"]:[], gid) ||
	contains (gidlists ["system"]:[], gid));
}

/**
 * Check if groupname already exists
 * @param groupname groupname
 * @return true if exists
 */
global define boolean GroupnameExists(string groupname) ``{

    // TODO: display warning if groupname exists in some other set?
    if (group_type == "ldap")
    {
	return contains (groupnamelists [group_type]:[], groupname);
    }
    return (contains (groupnamelists ["local"]:[], groupname) ||
	 contains (groupnamelists ["system"]:[], groupname));
}

/**
 * Scan uidlist for the next free uid.
 * @return integer free uid // TODO: user_type as parameter?
 */
global define integer NextFreeUid() ``{

    integer max = max_uid [user_type]:max_uid ["local"]:60000;
    integer uid = last_uid [user_type]:min_uid [user_type]:500;
    repeat
    {
        if (UIDExists (uid))
            uid = uid + 1;
        else
        {
            last_uid [user_type] = uid;
            return uid;
        }
    } until ( uid == max );
    return nil;
}

/**
 * Scan the groupsettings for the next free gid.
 * @return integer free gid
 */
global define integer NextFreeGid() ``{

    integer max = max_gid [group_type]:max_gid ["local"]:60000;
    integer gid = last_gid [group_type]:min_gid [group_type]:500;
    repeat
    {
        if (GIDExists (gid))
            gid = gid + 1;
        else return gid;
    } until ( gid == max );
    return nil;
}

/**
 * Update the proper itemlist shown in table
 * @param type user type (system/local/...)
 */
define void UpdateUserItemlist (string type) ``{

    if (contains (user_custom_sets, type))
        users_itemlists ["custom"] = MergeUserTableItems();
    if (! (customized_usersview))
    {
        type = current_users[0]:type;
        user_itemlist = users_itemlists [type]:[];
    }
    else
        user_itemlist = users_itemlists ["custom"]:[];

    user_itemlist = sort (user_itemlist);
}

/**
 * Update the proper itemlist shown in table
 * @param type group type (system/local/...)
 */
define void UpdateGroupItemlist (string type) ``{

    if (contains (group_custom_sets, type))
        groups_itemlists ["custom"] = MergeGroupTableItems();
    if (! (customized_groupsview))
    {
        type = current_groups[0]:type;
        group_itemlist = groups_itemlists [type]:[];
    }
    else
        group_itemlist = groups_itemlists ["custom"]:[];

    group_itemlist = sort (group_itemlist);
}

/**
 * Update the cache after changing user
 * @param what the action done with the user
 * @param user the user's map
 */
global define void ChangeUser(string what, map user) ``{

    integer uid = user["uid"]:nil;
    integer org_uid = user["org_uid"]:uid;
    string home = user["home"]:nil;
    string org_home = user["org_home"]:nil;
    string username = user["username"]:nil;
    string org_username = user["org_username"]:username;
    string type = user["type"]:"local";
    string org_type = user["org_type"]:type;
    string dn = user["dn"]:"";
    string org_dn = user["org_dn"]:nil;

    if (what == "add_user")
    {
	if (type == "ldap")
	    userdnlist = add (userdnlist, dn);
        uidlists [type] = prepend (uidlists [type]:[], uid);
	removed_uidlists = mapmap (string type, list uids, removed_uidlists, ``{
	    return $[ type : filter (integer u, uids, ``(u != uid))];
	});
        homelists [type] = add (homelists [type]:[], home);
        usernamelists [type] = add (usernamelists [type]:[], username);
	removed_usernamelists = mapmap(string type, list usernames,
	    removed_usernamelists, ``{
		return $[ type: filter (string u, usernames,``(u != username))];
	});
        users_itemlists [type] = merge (users_itemlists [type]:[],
            BuildUserItemList( $[ uid : user ] ));
        UpdateUserItemlist (type);
	// set table focus
	focusline_user = uid;
    }
    else if (what == "edit_user" || what == "group_change")
    {
        if (uid != org_uid)
        {
            uidlists [org_type] = filter (integer u, uidlists [org_type]:[],
		``(u != org_uid));
            uidlists [type] = prepend (uidlists [type]:[], uid);
	    removed_uidlists [type] = add (removed_uidlists [type]:[], org_uid);
	    removed_uidlists = mapmap (string t, list uids, removed_uidlists,
		``( $[ t : filter (integer u, uids, ``(u != uid))]));
	}
        if (home != org_home)
        {
            homelists [org_type] = filter (string h, homelists [org_type]:[],
		``(h != home));
            homelists [type] = prepend (homelists [type]:[], home);
        }
        if (username != org_username)
        {
            usernamelists [org_type] =
		filter (string u, usernamelists [org_type]:[],
                ``(u != org_username));
	    removed_usernamelists = mapmap
		(string typ, list usernames, removed_usernamelists, ``{
		return $[ typ: filter (string u, usernames, ``(u != username))];
	    });
	    removed_usernamelists [type] = add (removed_usernamelists [type]:[],
		org_username);
            usernamelists [type] = prepend (usernamelists [type]:[], username);
	    if (type == "ldap")
	    {
		userdnlist = filter (string u, userdnlist , ``(u != org_dn));
		userdnlist = add (userdnlist, dn);
	    }
        }
        users_itemlists [org_type] =
	    filter (term it, users_itemlists [org_type]:[],
            ``(select(it,1,"") != org_username));
        users_itemlists [type] = prepend (users_itemlists [type]:[],
            select (BuildUserItemList( $[ uid : user ] ), 0, []));

	if (what != "group_change")
	    focusline_user = uid;
	if (org_type != type)
	{
	    focusline_user = nil;
	    UpdateUserItemlist (org_type);
	}
        UpdateUserItemlist (type);
    }
    else if (what == "delete_user")
    {
	if (type == "ldap")
	    userdnlist = filter (string u, userdnlist , ``(u != org_dn));
        uidlists [type] = filter (integer u, uidlists [type]:[], ``(u != uid));
        homelists [type] = filter (string h, homelists [type]:[],``(h != home));
        usernamelists [type] = filter (string u, usernamelists [type]:[],
                ``(u != username));
	removed_uidlists [type] = add (removed_uidlists [type]:[], uid);
	removed_usernamelists [type] = add (removed_usernamelists [type]:[],
	    username);
        users_itemlists [type] = filter (term item, users_itemlists [type]:[],
            ``(select(item,1,"") != username));
        UpdateUserItemlist (type);
	focusline_user = nil;
    }

}

/**
 * Update the cache after changing group
 * @param what the action done with the group
 * @param group the group's map
 */
global define void ChangeGroup (string what, map group) ``{

    integer gid = group["gid"]:nil;
    integer org_gid = group["org_gid"]:gid;
    string groupname = group["groupname"]:nil;
    string org_groupname = group["org_groupname"]:groupname;
    string type = group["type"]:"local";
    string org_type = group["org_type"]:type;

    if (what == "add_group")
    {
        gidlists [type] = prepend (gidlists [type]:[], gid);
        groupnamelists [type] = add (groupnamelists [type]:[], groupname);
        groups_itemlists [type] = merge (groups_itemlists [type]:[],
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist (type);
	focusline_group = gid;
    }
    if (what == "edit_group")
    {
        if (gid != org_gid)
        {
            gidlists [org_type] = filter (integer g, gidlists [org_type]:[],
		``(g != org_gid));
            gidlists [type] = prepend (gidlists [type]:[], gid);
        }
        if (groupname != org_groupname)
        {
            groupnamelists [org_type] =
		filter (string u, groupnamelists[org_type]:[],
		    ``(u != org_groupname));
            groupnamelists [type] = prepend (groupnamelists[type]:[],groupname);
        }
	focusline_group = gid;
    }
    if (what == "edit_group" || what == "user_change" ||
             what == "user_change_default")
    {
	/*
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
	*/
        groups_itemlists [org_type] = filter (term i,
	    groups_itemlists [org_type]:[],``(select(i,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
	if (org_type != type)
	{
	    UpdateGroupItemlist (org_type);
	    focusline_group = nil;
	}
        UpdateGroupItemlist (type);
    }
    if (what == "delete_group")
    {
        gidlists [type] = filter (integer g, gidlists [type]:[], ``(g != gid));
        groupnamelists [type] = filter (string g, groupnamelists [type]:[],
                ``(g != groupname));
        groups_itemlists [type] = filter (term item, groups_itemlists [type]:[],
            ``(select(item,1,"") != groupname));
        UpdateGroupItemlist (type);
	focusline_group = nil;
    }
    if (what == "itemlist")
    {
        groups_itemlists [type] = filter (term item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist (type);
    }
}

/**
 * Propose a username.
 * @param cn fullname
 * @return string proposed login name
 */
global define string ProposeUsername( string cn ) ``{

    string default_login  = "lxuser";
    string login = "";

    if (proposal_count == -1)
    {
	// generate new list of possible usernames each time cn is changed

	proposed_usernames = [];
	// do not propose username with uppercase (problematic: #26409)
	list parts = splitstring (tolower(cn), " ");
	list tested_usernames = (list) eval (parts);

	// 1st: add some interesting modifications...
	integer i = 0;
	while (i < size (parts) - 1)
	{
	    integer j = i;
	    while (j < size (parts) - 1)
	    {
		tested_usernames = union ( [ parts[i]:"" + parts[j+1]:"" ],
		    tested_usernames);
		tested_usernames = union (
		    [ substring (parts[i]:"", 0, 1) + parts[j+1]:parts[0]:""],
		    tested_usernames);
		tested_usernames = union (
		    [ parts[j+1]:"" + substring (parts[i]:"", 0, 1)],
		    tested_usernames );
		tested_usernames = union ( [ parts[j+1]:"" + parts[i]:""],
		    tested_usernames );
		j = j + 1;
	    }
	    i = i + 1;
	}
	tested_usernames = add (tested_usernames, default_login);

	// 2nd: check existence
	foreach (string name, tested_usernames, ``{
	    integer name_count = 0;
	    while (UsernameExists (name))
	    {
		name = name + sformat ("%1", name_count);
		name_count = name_count + 1;
	    }
	    if (size (name)< min_length_login || size (name) > max_length_login)
		return;
	    proposed_usernames = add (proposed_usernames, name);
	});

	if (!UsernameExists ("42") && size (proposed_usernames)> 11)
	{
	    proposed_usernames = add (proposed_usernames, "42");
	}
	proposal_count = 0;
    }
    if (proposal_count >= size (proposed_usernames))
	proposal_count = 0;

    login = proposed_usernames [proposal_count]:default_login;

    proposal_count = proposal_count + 1;

    return login;
}

/**
 * Checks if given UID is in correct interval
 * @param uid uid
 * @param type user type (local/system/ldap)
 * @return true for correct interval
 */
global define boolean CheckUIDInterval (integer uid, string type) ``{

    integer minimum = min_uid [type]:0;
    if (type == "system")
	minimum = 0;
    return (uid >= minimum && uid <= max_uid [type]:60000);
}

/**
 * Checks if given GID is in correct interval
 * @param gid gid
 * @param type group type (local/system/ldap)
 * @return true for correct interval
 */
global define boolean CheckGIDInterval (integer gid, string type) ``{

    integer minimum = min_gid [type]:0;
    if (type == "system")
	minimum = 0;
    return (gid >= minimum && gid <= max_gid [type]:60000);
}

}
