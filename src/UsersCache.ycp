/**
 * File:	modules/UsersCache.ycp
 * Package: Configuration of users and groups
 * Summary:	Helper functions and cache structures for use from Users module
 *
 * Authors: Johannes Buchhold <jbuch@suse.de>,
 *          Jiri Suchomel <jsuchome@suse.cz>
 *
 */
{

module "UsersCache";
textdomain "users";

import "Mode";

include "users/passwd.ycp";

// list of home directories
global map homelists = $[];
global map usernamelists = $[];
global map groupnamelists = $[];
global map users_itemlists = $[];
global map groups_itemlists = $[]; // global ??
// item list of all users used in edit group dialog
global list additional_users = [];
global list user_itemlist = [];
global list group_itemlist = [];
map uidlists = $[];
global list gidlist = [];
global list current_users = []; // global ??
global list current_groups = []; // global ??
global list user_custom_sets = []; // global ??
global list group_custom_sets = []; // global ??

global symbol user_type = `local;
global symbol group_type = `local;

global integer focusline_group = nil;
global integer focusline_user  = nil;

global integer max_uid  = 0; // no !!!
global integer max_gid  = 0;
global integer max_system_uid = 0;
global integer max_system_gid = 0;
global integer max_length_uid = 0;
global integer max_length_gid = 0;

global boolean customized_usersview = true;
global boolean customized_groupsview = true;

global string encoding = "";

// map of last uid used for new user (to fasten searching of free uid)
map last_uid = $[];

    map symbol_to_string = $[
        `local: "local",
        `system:"system",
        `nis:   "nis",
        `ldap:  "ldap",
        `kerb:  "kerb",
        `smb:   "smb"
        ];

// build the cache structures, which should be changed only when necessary
global define boolean Read(map usermap, map groupmap, list cust_u, list cust_g,
string dir) ``{

    user_custom_sets = cust_u;
    current_users = cust_u;

    foreach (`type, `usersmap, usermap, ``{
        BuildUsers (usersmap, type, dir);
    });
    /*
    if (uidlist == [])
        uidlist = BuildUIDList(usermap);
    */
    users_itemlists [ `custom ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ `custom ]:[];


    // -- change groups building in a same way !!
    group_custom_sets = cust_g;
    current_groups = cust_g;
    foreach (`type, `groupsmap, groupmap, ``{
        if (groupnamelists [type]:nil == nil)
            groupnamelists [type] = BuildGroupnameList (groupsmap);
        groups_itemlists [type] = BuildGroupItemList(groupsmap);
    });

    if (gidlist == [])
        gidlist = BuildGIDList(groupmap); // this doesn't look very useful...
    groups_itemlists [ `custom ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ `custom ]:[];


    return true;
}

global define boolean BuildUsers (map usersmap, symbol type, string dir) ``{

    string stringtype = symbol_to_string[type]:"";

    if (! issubstring (dir, "/tmp/"))
    {
        homelists = add (homelists, type, BuildHomeList(usersmap));
        usernamelists = add(usernamelists,type,BuildUsernameList(usersmap));
        users_itemlists = add (users_itemlists, type,
            BuildUserItemList(usersmap));
        uidlists [type] = BuildUIDList(usersmap);
        if (type != `system)
            last_uid [type] = max_system_uid + 1;
        else
            last_uid [type] = 1;
    }
    else // load from the file
    {
        homelists [type] = SCR::Read(.target.ycp, dir + "/homelist_" +
            stringtype + ".ycp");
        usernamelists [type] = SCR::Read(.target.ycp, dir + "/usernamelist_" +
            stringtype + ".ycp");
        // eval due to translation of system use names
        users_itemlists [type] = eval (
            SCR::Read(.target.ycp, dir + "/itemlist_" + stringtype + ".ycp"));
        uidlists [type] = SCR::Read(.target.ycp, dir + "/uidlist_" +
            stringtype + ".ycp");
        if (type != `nis)
            last_uid [type] = SCR::Read (.target.ycp, dir + "/last_" +
                stringtype + "_uid.ycp");
    }
}

// to use for reseting settings during autoinstallation
global define void EmptyStructures () ``{

    homelists = $[];
    usernamelists = $[];
    uidlists = $[];
    groupnamelists = $[];
    gidlist = [];
}

/*
 */
global define list BuildHomeList(map usersmap) ``{

    list ret = [];
    foreach (`k, `v, usersmap, ``{
        if (v["home"]:nil != nil)
            ret = add (ret, v["home"]:nil);
    });
    return ret;
}

/*
 */
global define list BuildUsernameList(map usersmap) ``{

    list ret = [];
    foreach (`k, `v, usersmap, ``{
        if (v["username"]:nil != nil)
            ret = add (ret, v["username"]:nil);
    });
    return ret;
}

/*
 */
global define list BuildGroupnameList(map groupsmap) ``{

    list ret = [];
    foreach (`k, `v, groupsmap, ``{
        if (v["groupname"]:nil != nil)
            ret = add (ret, v["groupname"]:nil);
    });
    return sort (ret); //-- is this needed??
}


/*
*/
global define list BuildUIDList(map usersset) ``{

    list ret = [];
        foreach (`uid, `usersmap, usersset, ``{
            ret = add (ret, uid);
        });
    return ret;
}

/*
*/
global define list BuildGIDList(map allgroups) ``{

    list ret = [];
    foreach (`type, `groupsset, allgroups, ``{
        foreach (`gid, `groupsmap, groupsset, ``{
            ret = add (ret, gid);
        });
    });
    return ret;
}

/** -- check this !!
 * Build a string with n blanks
 * @param count number of blanks
 * @return string of blanks
 */
define string addBlanks(integer count ) ``{
    string  blanks = "";
    integer blanks_counter = 0;

    while (  blanks_counter < count )
    {
        blanks_counter = blanks_counter + 1;
        blanks         = blanks + "\302\240"; // why this ??
    }
    return blanks;
}

/*
 * Build item list for the user table
 */
global define list BuildUserItemList(map map_of_users) ``{

    list items = [];
    foreach ( `key, `user,  map_of_users, ``{
        string username = user["username"]:"";
        string  s_uid = sformat("%1", key );
        term    a     = `item(`id(key));

        if( size(s_uid) !=  max_length_uid )
            s_uid = addBlanks(max_length_uid - size(s_uid)) + s_uid;

        a = add(a, username );

        if(key > max_system_uid)
            a = add(a, Uncoding(user["fullname"]:"") );
        else
            a = add(a, SystemUsers[username]:user["fullname"]:"" );

        a = add(a, s_uid );

        string own_group = user["groupname"]:"";
        string grouplist = user["grouplist"]:"";
        list l_grouplist = splitstring (grouplist, ",");

        if ( !contains (l_grouplist, own_group) && own_group != "")
        {
            if (grouplist != "")
                    grouplist = own_group + "," + grouplist;
            else
                grouplist = own_group;
        }

        a = add(a, grouplist );
        items = add( items, a );
    });

    return items;
}

/**
 * Uncode the string.
 * @param fullname string
 * @return string string recoded to UTF
 */
global define string Uncoding( string fullname ) ``{

    if (fullname == "" || fullname == nil)
        return "";
    else
        return UI::Recode( encoding, "UTF-8",  fullname );

}

/*
 * Build item list for the group table
 */
global define list BuildGroupItemList(map map_of_groups) ``{

    integer the_answer = 42;
    list items = [];
    foreach ( `key, `group, map_of_groups, ``{

        string  s_gid = sformat("%1", key   );
        term    a     = `item(`id(key));

        if( size( s_gid) != Users::max_length_gid )
            s_gid = addBlanks( Users::max_length_gid - size(s_gid)) + s_gid;

        a = add(a, group["groupname"]:"" );
        a = add(a, s_gid);

        string userlist = group["userlist"]:"";
        string more = group["more_users"]:"";
        if ((userlist != "") && (more != ""))
            userlist = userlist + ",";
        userlist = userlist + more;
        // filter out the duplicates from more_groups??
        // shorten the list, if it is too long:
        list all_users = splitstring (userlist, ",");
        if (size (all_users) > the_answer)
        {
            userlist = "";
            integer i = 0;
            while (i < the_answer)
            {
                userlist = userlist + all_users[i]:"" + ",";
                i = i + 1;
            }
            userlist = userlist + "...";
        }
        a = add(a, userlist);

        items = add( items, a );
    });
    return items;
}

/*
 */
global define list MergeUserTableItems() ``{

    list items = [];
    foreach (`usersset, user_custom_sets, ``{
            items = merge(items, users_itemlists [ usersset ]:[]);
    });
    return items;
}

/*
 */
global define list MergeGroupTableItems() ``{

    list items = [];
    foreach (`groupsset, group_custom_sets, ``{
            items = merge(items, groups_itemlists [ groupsset ]:[]);
    });
    return items;
}

global define void ChangeUserCustoms (list new) ``{

    user_custom_sets = new;
    users_itemlists [`custom] = MergeUserTableItems();
    if (customized_usersview)
        user_itemlist = users_itemlists [`custom]:[];
}

global define void ChangeGroupCustoms (list new) ``{

    group_custom_sets = new;
    groups_itemlists [`custom] = MergeGroupTableItems();
    if (customized_groupsview)
        group_itemlist = groups_itemlists [`custom]:[];
}


/* -- check for nis names???
 */
global define boolean UsernameExists(string username) ``{

    boolean ret = false;
    foreach (`type, `usernames, usernamelists, ``{
        if ( contains (usernames, username)) ret = true;
    });
    return ret;
}

/* -- check for nis homes???
 */
global define boolean HomeExists(string home) ``{

    boolean ret = false;
    foreach (`type, `homes, homelists, ``{
        if ( contains (homes, home)) ret = true;
    });
    return ret;
}

/*
 */
global define boolean UIDExists(integer uid) ``{

    boolean ret = false;
    foreach (`type, `uids, uidlists, ``{
        if ( contains (uids, uid)) ret = true;
    });
    return ret;
}

/*
 */
global define boolean GIDExists(integer gid) ``{

    if ( contains (gidlist, gid)) return true;
    return false;
}

/* -- check for nis names???
 */
global define boolean GroupnameExists(string groupname) ``{

    boolean ret = false;
    foreach (`type, `groupnames, groupnamelists, ``{
        if ( contains (groupnames, groupname)) ret = true;
    });
    return ret;
}

/**
 * Scan uidlist for the next free uid.
 * @return integer free uid
 */
global define integer NextFreeUid() ``{

    integer uid = last_uid [user_type]:last_uid [`local]:1;
    integer max = max_uid;
    if (user_type == `system)
        max = max_system_uid;
    repeat
    {
        if (UIDExists (uid))
            uid = uid + 1;
        else
        {
            last_uid [user_type] = uid;
            return uid;
        }
    } until ( uid == max );
    return nil;
}

/**
 * Scan the groupsettings for the next free gid.
 * @return integer free gid
 */
global define integer NextFreeGid() ``{
    // can't delete gid 101 with groupdel ????
    // FIXME ERROR
    //if ( gid == 101 ) gid = 102;

    integer min = 1;
    integer max = max_gid;
    if (group_type == `system)
        max = max_system_gid;
    else // beware !! what about LDAP etc.??
        min = max_system_gid + 1;
    integer gid = min;
    repeat
    {
        if (contains (gidlist, gid))
            gid = gid + 1;
        else return gid;
    } until ( gid == max );
    return nil;
}

/* Update the proper itemlist showed in table */
define void UpdateUserItemlist () ``{

    if (contains (user_custom_sets, user_type))
        users_itemlists [`custom] = MergeUserTableItems();
    if (! (customized_usersview))
    {
        symbol type = current_users[0]:user_type;
        user_itemlist = users_itemlists [type]:[]; //pointer ??
    }
    else
        user_itemlist = users_itemlists [`custom]:[]; //pointer ??

    user_itemlist = sort (user_itemlist);
}

/* Update the proper itemlist showed in table */
define void UpdateGroupItemlist () ``{

    if (contains (group_custom_sets, group_type))
        groups_itemlists [`custom] = MergeGroupTableItems();
    if (! (customized_groupsview))
    {
        symbol type = current_groups[0]:group_type;
        group_itemlist = groups_itemlists [type]:[]; //pointer ??
    }
    else
        group_itemlist = groups_itemlists [`custom]:[]; //pointer ??

    group_itemlist = sort (group_itemlist);
}

/* Update the cache after changing user */
global define void ChangeUser(symbol what, map user) ``{

    integer uid = user["uid"]:nil;
    string home = user["home"]:nil;
    string org_home = user["org_home"]:nil;
    string username = user["username"]:nil;
    string org_username = user["org_username"]:username;
    symbol type = user["type"]:`local; // we have global user_type!

    if (what == `add_user)
    {
        uidlists [type] = prepend (uidlists [type]:[], uid);
        homelists [type] = add (homelists [type]:[], home);
        usernamelists [type] = add (usernamelists [type]:[], username);
        users_itemlists [type] = merge (users_itemlists [type]:[],
            BuildUserItemList( $[ uid : user ] ));
        UpdateUserItemlist ();
    }
    else if (what == `edit_user || what == `group_change)
    {
//        uidlist = prepend (uidlist, uid); was uid changed? -> org_uid
        if (home != org_home)
        {
            homelists [type] = filter (`h, homelists [type]:[], ``(h != home));
            homelists [type] = prepend (homelists [type]:[], home);
        }
        if (username != org_username) // was username changed?
        {
            usernamelists [type] = filter (`u, usernamelists [type]:[],
                ``(u != org_username));
            usernamelists [type] = prepend (usernamelists [type]:[], username);
        }
        // could be done faster?  use add/merge/prepend?
        users_itemlists [type] = filter (`item, users_itemlists [type]:[],
            ``(select(item,1,"") != org_username));
        users_itemlists [type] = prepend (users_itemlists [type]:[],
            select (BuildUserItemList( $[ uid : user ] ), 0, []));
/*        users_itemlists [type] = merge (users_itemlists [type]:[],
            BuildUserItemList( $[ uid : user ] ));*/
        UpdateUserItemlist ();
    }
    else if (what == `delete_user)
    {
        uidlists [type] = filter (`u, uidlists [type]:[], ``(u != uid));
        homelists [type] = filter (`h, homelists [type]:[], ``(h != home));
        usernamelists [type] = filter (`u, usernamelists [type]:[],
                ``(u != username));
        users_itemlists [type] = filter (`item, users_itemlists [type]:[],
            ``(select(item,1,"") != username));
        UpdateUserItemlist ();
    }

}

/* Update the cache after changing group */
global define void ChangeGroup (symbol what, map group) ``{

    integer gid = group["gid"]:nil;
    integer org_gid = group["gid"]:gid;
    string groupname = group["groupname"]:nil;
    string org_groupname = group["org_groupname"]:groupname;
    symbol type = group["type"]:`local; // we have global group_type!

    if (what == `add_group)
    {
        gidlist = prepend (gidlist, gid);
        groupnamelists [type] = add (groupnamelists [type]:[], groupname);
        groups_itemlists [type] = merge (groups_itemlists [type]:[],
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
    else if (what == `edit_group || what == `user_change)
    {
        if (gid != org_gid)
        {
            gidlist = filter (`g, gidlist, ``(g != org_gid));
            gidlist = prepend (gidlist, gid);
        }
        if (groupname != org_groupname) // was groupname changed?
        {
            groupnamelists [type] = filter (`u, groupnamelists [type]:[],
                ``(u != org_groupname));
            groupnamelists [type] = prepend (groupnamelists[type]:[],groupname);
        }
        // could be done faster?  use add/merge/prepend?
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
    else if (what == `delete_group)
    {
        gidlist = filter (`g, gidlist, ``(g != gid));
        groupnamelists [type] = filter (`g, groupnamelists [type]:[],
                ``(g != groupname));
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != groupname));
        UpdateGroupItemlist ();
    }
    else if (what == `itemlist)
    {
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }


}

/**
  * Get group id
  * @param groupname string group name
  * @return integer gid
  *
global define integer GetGid( string groupname )``{

    integer gid = Users::max_gid;
    ProgressInitGroups ("GetGid");
    foreach ( `key, `group,  current_groups, ``{
        if( lookup( group, "groupname", "") == groupname )
        {
        gid = lookup(group, "gid", Users::max_gid  );
        }
        ProgressNext ();
    });
    ProgressDone ();
    return gid;
}*/

/**
  * Get iser id
  * @param username string user name
  * @return integer uid
  *
global define integer GetUid( string username )``{

        integer uid = Users::max_uid;
    ProgressInitUsers ("GetUid");
        foreach ( `key, `user,  current_users, ``{
            if( lookup( user, "username", "") == username )
            {
                uid = lookup(user, "uid", Users::max_uid  );
            }
        ProgressNext ();
        });
    ProgressDone ();
        return uid;
}*/

}
