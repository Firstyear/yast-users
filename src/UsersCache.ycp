/**
 * File:	modules/UsersCache.ycp
 * Package:	Configuration of users and groups
 * Summary:	Helper functions and cache structures for use from Users module
 *
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *		Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{

module "UsersCache";
textdomain "users";

import "Mode";

include "users/passwd.ycp";

// map of list of home directories
global map homelists = $[];
// map of list of usernames
global map usernamelists = $[];
/**
 * map of lists of usernames removed so far
 */
global map removed_usernamelists = $[];
// map of list of groupnames
global map groupnamelists = $[];
// map of list of all items in user table
global map users_itemlists = $[];
// map of list of all items in group table
global map groups_itemlists = $[];
// map of list of current items in user table
global list user_itemlist = [];
// map of list of current items in group table
global list group_itemlist = [];
// item list of all users used in edit group dialog
global list additional_users = [];
// map of list of uid's
global map uidlists = $[];
/**
 * map of lists of usernames removed so far
 */
global map removed_uidlists = $[];
// map of list of gid's
global map gidlists = $[];
global list current_users = [];
global list current_groups = [];
global list user_custom_sets = [];
global list group_custom_sets = [];

// type of current user/group
global string user_type = "local";
global string group_type = "local";

global integer focusline_group = nil;
global integer focusline_user  = nil;

// TODO move elsewhere...
global integer max_uid  = 60000;
global integer max_gid  = 60000;
global integer max_system_uid = 500-1;
global integer max_system_gid = 100-1;//TODO will be changed to 500...
global integer max_length_uid = 5;
global integer max_length_gid = 5;
global boolean ldap_file_server = false;

// if currrent view is "customized"
global boolean customized_usersview = true;
global boolean customized_groupsview = true;

global string encoding = "";

// usernames generated by "Propose" button
global list proposed_usernames = [];
// number of clicks of "Propose" (-1 means: generate new list)
global integer proposal_count = -1;


// map of last uid used for new user (to fasten searching of free uid)
map last_uid = $[
    "system": 1,
    "local": 500];

/**
 * Build the cache structures, used for fasten operations
 * @param usermap the map of users
 * @param groupmap the map of groups
 * @param cust_u custom view of user sets
 * @param cust_g custom view of group sets
 * @return true
 */
global define boolean Read(map usermap, map groupmap, list cust_u, list cust_g) ``{

    current_users = user_custom_sets;
    PrintDate ("read cache start");

    foreach (`type, `usersmap, usermap, ``{
        BuildUsers (usersmap, type);
    });
    users_itemlists [ "custom" ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ "custom" ]:[];

    current_groups = group_custom_sets;

    foreach (`type, `groupsmap, groupmap, ``{
        BuildGroups (groupsmap, type);
    });
    groups_itemlists [ "custom" ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ "custom" ]:[];

    return true;
}

/**
 * Read the prebuilded cache structures from files
 * @param dir the location of input files
 * @return true
 */
global define void ReadFromFiles (string dir) ``{

    current_users = user_custom_sets;
    PrintDate ("read cache start");

    // could be the sets here explicitly?
    list start_sets = ["local", "system"];
    foreach (`type, start_sets , ``{
        ReadUsers (type, dir);
    });
    PrintDate ("before merge");
    users_itemlists [ "custom" ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ "custom" ]:[];
    PrintDate ("after merge");

    foreach (`type, start_sets , ``{
        ReadGroups (type, dir);
    });
    groups_itemlists [ "custom" ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ "custom" ]:[];

    PrintDate ("read cache end");
}

/**
 * Build the cache structures for user set
 * @param usersmap map of users of one type
 * @param type the users type
 */
global define void BuildUsers (map usersmap, string type) ``{

    PrintDate ("build users start");

    homelists = add (homelists, type, BuildHomeList (usersmap));
    usernamelists = add (usernamelists, type, BuildUsernameList (usersmap));
    users_itemlists = add (users_itemlists, type,
        BuildUserItemList(usersmap));
    uidlists [type] = BuildUIDList(usersmap);
    if (type != "system")
        last_uid [type] = max_system_uid + 1;
    else
        last_uid [type] = 1;
}

/**
 * Build the cache structures for group set
 * @param groupsmap map of groups of one type
 * @param type the groups type
 */
global define void BuildGroups (map groupsmap, string type) ``{

    if (groupnamelists [type]:nil == nil)
        groupnamelists [type] = BuildGroupnameList (groupsmap);
    groups_itemlists [type] = BuildGroupItemList(groupsmap);

    gidlists [type] = BuildGIDList(groupsmap);
}

/**
 * Read the prepared user data from the files
 * @param type the type of users
 * @param dir the source directory
 * @return true
 */
global define boolean ReadUsers (string type, string dir) ``{

    PrintDate ("build users start");

    if (type == "ldap")
    {
	homelists [type] = SCR::Read(.ldap.users.homes);
        usernamelists [type] = SCR::Read(.ldap.users.usernames);

	PrintDate ("homelist");

	users_itemlists [type] =
	    SCR::Read (.target.ycp, dir + "/itemlist_ldap.ycp");

        PrintDate ("itemlists");
	uidlists [type] = SCR::Read (.ldap.users.uids);
        last_uid [type] = SCR::Read (.ldap.users.last_uid);

	return true;
    }
    homelists [type] = SCR::Read(.target.ycp, dir + "/homelist_" +type+ ".ycp");
    usernamelists [type] = SCR::Read(.target.ycp, dir + "/usernamelist_" +
        type + ".ycp");

    PrintDate ("homelist");
    // eval due to translation of system user names
    users_itemlists [type] = eval (
        SCR::Read(.target.ycp, dir + "/itemlist_" + type + ".ycp"));

    PrintDate ("itemlists");
    uidlists [type] = SCR::Read(.target.ycp, dir + "/uidlist_" + type + ".ycp");
    if (type != "nis")
    {
        last_uid [type] = SCR::Read (.target.ycp, dir + "/last_" +
            type + "_uid.ycp");
    }

    return true; // TODO: test for errors while reading
}

/**
 * Read the prepared group data from the files
 * @param type the type of groups
 * @param dir the source directory
 * @return true
 */
global define boolean ReadGroups (string type, string dir) ``{

    if (type == "ldap")
    {
        gidlists [type] = SCR::Read (.ldap.groups.gids);
	groupnamelists [type] = SCR::Read (.ldap.groups.groupnames);
    }
    else
    {
	gidlists [type] = SCR::Read (.target.ycp, dir + "/gidlist_" +
	    type + ".ycp");
	groupnamelists [type] = SCR::Read (.target.ycp, dir + "/groupnamelist_"
	    + type + ".ycp");
    }
    groups_itemlists [type] = SCR::Read(.target.ycp, dir + "/group_"
        + type + "_itemlist.ycp");

    return true;
}


/**
 * Reset the structures, to use during autoinstallation
 */
global define void EmptyStructures () ``{

    homelists = $[];
    usernamelists = $[];
    uidlists = $[];
    groupnamelists = $[];
    gidlists = $[];
}

/**
 * Builds the list of home directories of given users
 * @param usersmap map of users of one type
 * @return list of homedirs
 */
global define list BuildHomeList(map usersmap) ``{

    list ret = [];
    foreach (`k, `v, usersmap, ``{
        if (v["home"]:nil != nil)
            ret = add (ret, v["home"]:nil);
    });
    return ret;
}

/**
 * Builds the list of user names
 * @param usersmap map of users of one type
 * @return list of names
 */
global define list BuildUsernameList(map usersmap) ``{

    list ret = [];
    foreach (`k, `v, usersmap, ``{
        if (v["username"]:nil != nil)
            ret = add (ret, v["username"]:nil);
    });
    return ret;
}

/**
 * Builds the list of group names
 * @param groupsmap map of groups of one type
 * @return list of names
 */
global define list BuildGroupnameList(map groupsmap) ``{

    list ret = [];
    foreach (`k, `v, groupsmap, ``{
        if (v["groupname"]:nil != nil)
            ret = add (ret, v["groupname"]:nil);
    });
    return sort (ret); //-- is this needed??
}


/**
 * Builds the list of uid's
 * @param usersset map of users of one type
 * @return list of id's
 */
global define list BuildUIDList(map usersset) ``{

    list ret = [];
        foreach (`uid, `usersmap, usersset, ``{
            ret = add (ret, uid);
        });
    return ret;
}

/**
 * Builds the list of gid's
 * @param groupsset map of groups of one type
 * @return list of id's
 */
global define list BuildGIDList(map groupsset) ``{

    list ret = [];
    foreach (`gid, `groupsmap, groupsset, ``{
            ret = add (ret, gid);
    });
    return ret;
}

/**
 * Build a string with n blanks
 * @param count number of blanks
 * @return string of blanks
 */
define string addBlanks(integer count ) ``{
    string  blanks = "";
    integer blanks_counter = 0;

    while (  blanks_counter < count )
    {
        blanks_counter = blanks_counter + 1;
//        blanks         = blanks + "\302\240"; // why this ??
        blanks         = blanks + " ";
    }
    return blanks;
}

/**
 * Builds item list for the user table
 * @param map_of_users users of one type
 * @return list of items for table widget
 */
global define list BuildUserItemList(map map_of_users) ``{

    list items = [];
    foreach ( `key, `user,  map_of_users, ``{
        string username = user["username"]:"";
        string full = user["fullname"]:"";
        string  s_uid = sformat("%1", key );
        term    a     = `item(`id(key));

        if( size(s_uid) !=  max_length_uid )
            s_uid = addBlanks(max_length_uid - size(s_uid)) + s_uid;

        a = add(a, username );

        if (user["type"]:"local" == "system")
            a = add(a, SystemUsers [full]:full );
        else
            a = add(a, full );

        a = add(a, s_uid );

        string own_group = user["groupname"]:"";
        string grouplist = user["grouplist"]:"";
        list l_grouplist = splitstring (grouplist, ",");

        if ( !contains (l_grouplist, own_group) && own_group != "")
        {
            if (grouplist != "")
                    grouplist = own_group + "," + grouplist;
            else
                grouplist = own_group;
        }

        a = add(a, grouplist );
        items = add( items, a );
    });

    return items;
}

/**
 * Uncode the string.
 * @param fullname string
 * @return string string recoded to UTF
 */
global define string Uncoding( string fullname ) ``{

    if (fullname == "" || fullname == nil)
        return "";
    else
        return UI::Recode( encoding, "UTF-8",  fullname );

}

/**
 * Builds item list for the group table
 * @param map_of_groups groups of one type
 * @return list of items for table widget
 */
global define list BuildGroupItemList(map map_of_groups) ``{

    integer the_answer = 42;
    list items = [];
    foreach ( `key, `group, map_of_groups, ``{

        string  s_gid = sformat("%1", key   );
        term    a     = `item(`id(key));

        if( size( s_gid) != max_length_gid )
            s_gid = addBlanks( max_length_gid - size(s_gid)) + s_gid;

        a = add(a, group["groupname"]:"" );
        a = add(a, s_gid);

        string userlist = group["userlist"]:"";
        string more = group["more_users"]:"";
        if ((userlist != "") && (more != ""))
            userlist = userlist + ",";
        userlist = userlist + more;
        // filter out the duplicates from more_groups??
        // shorten the list, if it is too long:
        list all_users = splitstring (userlist, ",");
        if (size (all_users) > the_answer)
        {
            userlist = "";
            integer i = 0;
            while (i < the_answer)
            {
                userlist = userlist + all_users[i]:"" + ",";
                i = i + 1;
            }
            userlist = userlist + "...";
        }
        a = add(a, userlist);

        items = add( items, a );
    });
    return items;
}

/**
 * Merge the users's item lists of types included in "custom view" to one list
 * @return new table itemlist
 */
global define list MergeUserTableItems() ``{

    list items = [];
    foreach (`usersset, user_custom_sets, ``{
            items = merge(items, users_itemlists [ usersset ]:[]);
    });
    return items;
}

/**
 * Merge the groups's item lists of types included in "custom view" to one list
 * @return new table itemlist
 */
global define list MergeGroupTableItems() ``{

    list items = [];
    foreach (`groupsset, group_custom_sets, ``{
            items = merge(items, groups_itemlists [ groupsset ]:[]);
    });
    return items;
}

/**
 * Change the list defining user's "custom view"
 * @param new new customized list
 */
global define void ChangeUserCustoms (list new) ``{

    user_custom_sets = new;
    users_itemlists ["custom"] = MergeUserTableItems();
    customized_usersview = true;
    user_itemlist = users_itemlists ["custom"]:[];
}

/**
 * Change the list defining group's "custom view"
 * @param new new customized list
 */
global define void ChangeGroupCustoms (list new) ``{

    group_custom_sets = new;
    groups_itemlists ["custom"] = MergeGroupTableItems();
    customized_groupsview = true;
    group_itemlist = groups_itemlists ["custom"]:[];
}

/**
 * Check if homedir doesn't exist for another user
 * Doesn't check directory existence, only looks to set of used directories
 * @param home the name
 * @return true if directory is used as another user's home directory
 */
global define boolean HomeExists(string home) ``{

    boolean ret = false;

    list sets_to_check = ["local", "system"];
    if (ldap_file_server)
    {
	sets_to_check = add (sets_to_check, "ldap");
    }
    else if (user_type == "ldap") //ldap, client only
    {
	sets_to_check = ["ldap"];
    }

    foreach (`type, sets_to_check, ``{
        if ( contains (homelists[type]:[], home)) ret = true;
    });

    return ret;
}

/**
 * Check if username already exists
 * @param username username
 * @return true if exists
 */
global define boolean UsernameExists(string username) ``{

    boolean ret = false;
    foreach (`type, `usernames, usernamelists, ``{
	if ( !ret && contains (usernames, username)) ret = true;
    });
    // for autoyast, check only loaded sets
    if (Mode::config || ret)
	return ret;
    // not found -> check all sets via agent...
    ret = !IsUsernameUnique (username);
    if (ret)
    {
	// check if username wasn't just deleted...
	list sets_to_check = ["local", "system"];
	if (user_type != "ldap")
	{
	    sets_to_check = add (sets_to_check, "ldap");
	}
	foreach (`type, sets_to_check, ``{
	    if (contains (removed_usernamelists[type]:[],username)) ret = false;
	});
    }
    return ret;
}

/**
 * Check if UID doesn't already exist
 * @param uid UID
 * @return true if exists
 */
global define boolean UIDExists(integer uid) ``{

    boolean ret = false;
    foreach (`type, `uids, uidlists, ``{
	if ( !ret && contains (uids, uid)) ret = true;
    });
    // for autoyast, check only loaded sets
    if (Mode::config || ret)
	return ret;
    // not found -> check all sets via agent...
    ret = !IsIDUnique (uid);
    if (ret)
    {
	// check if uid wasn't just deleted...
	list sets_to_check = ["local", "system"];
	// LDAP: do not allow change uid of one user and use old one by
	// another user - because users are saved by calling extern tool
	// and colisions can be hardly avoided
	if (user_type != "ldap")
	{
	    sets_to_check = add (sets_to_check, "ldap");
	}
	foreach (`type, sets_to_check, ``{
	    if (contains (removed_uidlists[type]:[], uid)) ret = false;
	});
    }
    return ret;
}

/**
 * Check if GID doesn't already exist
 * @param gid GID
 * @return true if exists
 */
global define boolean GIDExists(integer gid) ``{

    // TODO: display warning if GID exists in other set?
    if (group_type == "ldap")
    {
	return contains (gidlists [group_type]:[], gid);
    }
    return (contains (gidlists ["local"]:[], gid) ||
	contains (gidlists ["system"]:[], gid));
}

/**
 * Check if groupname already exists
 * @param groupname groupname
 * @return true if exists
 */
global define boolean GroupnameExists(string groupname) ``{

    // TODO: display warning if groupname exists in some other set?
    if (group_type == "ldap")
    {
	return contains (groupnamelists [group_type]:[], groupname);
    }
    return (contains (groupnamelists ["local"]:[], groupname) ||
	 contains (groupnamelists ["system"]:[], groupname));
}

/**
 * Scan uidlist for the next free uid.
 * @return integer free uid
 */
global define integer NextFreeUid() ``{

    integer uid = (last_uid [user_type]:last_uid ["local"]:0) + 1;
    integer max = max_uid;
    if (user_type == "system")
        max = max_system_uid;
    repeat
    {
        if (UIDExists (uid))
            uid = uid + 1;
        else
        {
            last_uid [user_type] = uid;
            return uid;
        }
    } until ( uid == max );
    return nil;
}

/**
 * Scan the groupsettings for the next free gid.
 * @return integer free gid
 */
global define integer NextFreeGid() ``{

    integer min = 1;
    integer max = max_gid;
    if (group_type == "system")
        max = max_system_gid;
    else
        min = max_system_gid + 1;
    integer gid = min;
    repeat
    {
        if (GIDExists (gid))
            gid = gid + 1;
        else return gid;
    } until ( gid == max );
    return nil;
}

/**
 * Update the proper itemlist shown in table
 */
define void UpdateUserItemlist () ``{

    if (contains (user_custom_sets, user_type))
        users_itemlists ["custom"] = MergeUserTableItems();
    if (! (customized_usersview))
    {
        string type = current_users[0]:user_type;
        user_itemlist = users_itemlists [type]:[];
    }
    else
        user_itemlist = users_itemlists ["custom"]:[];

    user_itemlist = sort (user_itemlist);
}

/**
 * Update the proper itemlist shown in table
 */
define void UpdateGroupItemlist () ``{

    if (contains (group_custom_sets, group_type))
        groups_itemlists ["custom"] = MergeGroupTableItems();
    if (! (customized_groupsview))
    {
        string type = current_groups[0]:group_type;
        group_itemlist = groups_itemlists [type]:[];
    }
    else
        group_itemlist = groups_itemlists ["custom"]:[];

    group_itemlist = sort (group_itemlist);
}

/**
 * Update the cache after changing user // TODO:change to Commit?
 * @param what the action done with the user
 * @param user the user's map
 */
global define void ChangeUser(string what, map user) ``{

    integer uid = user["uid"]:nil;
    integer org_uid = user["org_uid"]:uid;
    string home = user["home"]:nil;
    string org_home = user["org_home"]:nil;
    string username = user["username"]:nil;
    string org_username = user["org_username"]:username;
    string type = user["type"]:"local";

    if (what == "add_user")
    {
        uidlists [type] = prepend (uidlists [type]:[], uid);
	removed_uidlists = mapmap (`type, `uids, removed_uidlists, ``{
	    return [ type, filter (`u, uids, ``(u != uid))];
	});
        homelists [type] = add (homelists [type]:[], home);
        usernamelists [type] = add (usernamelists [type]:[], username);
	removed_usernamelists=mapmap(`type,`usernames,removed_usernamelists, ``{
	    return [ type, filter (`u, usernames, ``(u != username))];
	});
        users_itemlists [type] = merge (users_itemlists [type]:[],
            BuildUserItemList( $[ uid : user ] ));
        UpdateUserItemlist ();
    }
    else if (what == "edit_user" || what == "group_change")
    {
        if (uid != org_uid)
        {
            uidlists [type] = filter (`u, uidlists [type]:[], ``(u != org_uid));
            uidlists [type] = prepend (uidlists [type]:[], uid);
	    removed_uidlists [type] = add (removed_uidlists [type]:[], org_uid);
	    removed_uidlists = mapmap (`type, `uids, removed_uidlists, ``{
		return [ type, filter (`u, uids, ``(u != uid))];
	    });
	}
        if (home != org_home)
        {
            homelists [type] = filter (`h, homelists [type]:[], ``(h != home));
            homelists [type] = prepend (homelists [type]:[], home);
        }
        if (username != org_username)
        {
            usernamelists [type] = filter (`u, usernamelists [type]:[],
                ``(u != org_username));
	    removed_usernamelists = mapmap
		(`type, `usernames, removed_usernamelists, ``{
		return [ type, filter (`u, usernames, ``(u != username))];
	    });
	    removed_usernamelists [type] = add (removed_usernamelists [type]:[],
		org_username);
            usernamelists [type] = prepend (usernamelists [type]:[], username);
        }
        users_itemlists [type] = filter (`item, users_itemlists [type]:[],
            ``(select(item,1,"") != org_username));
        users_itemlists [type] = prepend (users_itemlists [type]:[],
            select (BuildUserItemList( $[ uid : user ] ), 0, []));
        UpdateUserItemlist ();
    }
    else if (what == "delete_user")
    {
        uidlists [type] = filter (`u, uidlists [type]:[], ``(u != uid));
        homelists [type] = filter (`h, homelists [type]:[], ``(h != home));
        usernamelists [type] = filter (`u, usernamelists [type]:[],
                ``(u != username));
	removed_uidlists [type] = add (removed_uidlists [type]:[], uid);
	removed_usernamelists [type] = add (removed_usernamelists [type]:[],
	    username);
        users_itemlists [type] = filter (`item, users_itemlists [type]:[],
            ``(select(item,1,"") != username));
        UpdateUserItemlist ();
    }

}

/**
 * Update the cache after changing group
 * @param what the action done with the group
 * @param group the group's map
 */
global define void ChangeGroup (string what, map group) ``{

    integer gid = group["gid"]:nil;
    integer org_gid = group["org_gid"]:gid;
    string groupname = group["groupname"]:nil;
    string org_groupname = group["org_groupname"]:groupname;
    string type = group["type"]:"local";

    if (what == "add_group")
    {
        gidlists [type] = prepend (gidlists [type]:[], gid);
        groupnamelists [type] = add (groupnamelists [type]:[], groupname);
        groups_itemlists [type] = merge (groups_itemlists [type]:[],
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
    if (what == "edit_group")
    {
        if (gid != org_gid)
        {
            gidlists [type] = filter (`g, gidlists [type]:[], ``(g != org_gid));
            gidlists [type] = prepend (gidlists [type]:[], gid);
        }
        if (groupname != org_groupname)
        {
            groupnamelists [type] = filter (`u, groupnamelists [type]:[],
                ``(u != org_groupname));
            groupnamelists [type] = prepend (groupnamelists[type]:[],groupname);
        }
    }
    if (what == "edit_group" || what == "user_change" ||
             what == "user_change_default")
    {
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
    if (what == "delete_group")
    {
        gidlists [type] = filter (`g, gidlists [type]:[], ``(g != gid));
        groupnamelists [type] = filter (`g, groupnamelists [type]:[],
                ``(g != groupname));
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != groupname));
        UpdateGroupItemlist ();
    }
    if (what == "itemlist")
    {
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
}

/**
 * Speed debug function - prints current time to log
 * @param message debug message
 */
global define void PrintDate(string message) ``{

//    y2warning ("%1: %2", message, lookup (SCR::Execute(.target.bash_output, "date +%X"), "stdout", ""));
}

/**
 * Asks agent if given ID is not UID of any user in system
 * @param uid ID to check
 * @return false when UID already exists
 */
global define boolean IsIDUnique (integer uid) ``{

    return SCR::Read (.uid.uid, uid);
}

/**
 * Asks agent if given name is not username of any user in system
 * @param username name to check
 * @return false when username already exists
 */
global define boolean IsUsernameUnique (string username) ``{

    return SCR::Read (.uid.username, username);
}

/**
 * Propose a username.
 * @param fullname fullname
 * @return string proposed login name
 */
global define string ProposeUsername( string fullname ) ``{

    string default_login  = "lxuser";
    string login = "";

    if (proposal_count == -1)
    {
	// generate new list of possible usernames each time fullname is changed

	proposed_usernames = [];
	fullname = filterchars (fullname, Users::valid_logname_chars + " ");
	list parts = splitstring (fullname, " ");
	list tested_usernames = eval (parts);

	// 1st: add some interesting modifications...
	integer i = 0;
	while (i < size (parts) - 1)
	{
	    integer j = i;
	    while (j < size (parts) - 1)
	    {
		tested_usernames = union ( [ parts[i]:"" + parts[j+1]:"" ],
		    tested_usernames);
		tested_usernames = union (
		    [ substring (parts[i]:"", 0, 1) + parts[j+1]:parts[0]:""],
		    tested_usernames);
		tested_usernames = union (
		    [ parts[j+1]:"" + substring (parts[i]:"", 0, 1)],
		    tested_usernames );
		tested_usernames = union ( [ parts[j+1]:"" + parts[i]:""],
		    tested_usernames );
		j = j + 1;
	    }
	    i = i + 1;
	}

	// lowercase proposals go first
	foreach (`name, tested_usernames, ``{
	    tested_usernames = union ([ tolower(name) ], tested_usernames );
//	    tested_usernames = union (tested_usernames, [ toupper(name) ]  );
	});
	tested_usernames = add (tested_usernames, default_login);

	// 2nd: check existence
	foreach (`name, tested_usernames, ``{
	    integer name_count = 0;
	    while (UsersCache::UsernameExists (name))
	    {
		name = name + sformat ("%1", name_count);
		name_count = name_count + 1;
	    }
	    if (size (name) < 2 || size (name) > 32)
		return;
	    proposed_usernames = add (proposed_usernames, name);
	});

	if (! UsersCache::UsernameExists ("42") && size (proposed_usernames)>40)
	{
	    proposed_usernames = add (proposed_usernames, "42");
	}
	proposal_count = 0;
    }
    if (proposal_count >= size (proposed_usernames))
	proposal_count = 0;

    login = proposed_usernames [proposal_count]:default_login;

    proposal_count = proposal_count + 1;

    return login;
}



}
