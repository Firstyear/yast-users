/**
 * File:	modules/UsersCache.ycp
 * Package: Configuration of users and groups
 * Summary:	Helper functions and cache structures for use from Users module
 *
 * Authors: Johannes Buchhold <jbuch@suse.de>,
 *          Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{

module "UsersCache";
textdomain "users";

import "Mode";

include "users/passwd.ycp";

// map of list of home directories
global map homelists = $[];
global map usernamelists = $[];
global map groupnamelists = $[];
global map users_itemlists = $[];
global map groups_itemlists = $[];
// item list of all users used in edit group dialog
global list additional_users = [];
global list user_itemlist = [];
global list group_itemlist = [];
map uidlists = $[];
global map gidlists = $[];
global list current_users = [];
global list current_groups = [];
global list user_custom_sets = [];
global list group_custom_sets = [];

global symbol user_type = `local;
global symbol group_type = `local;

global integer focusline_group = nil;
global integer focusline_user  = nil;

global integer max_uid  = 0; // no !!!
global integer max_gid  = 0;
global integer max_system_uid = 0;
global integer max_system_gid = 0;
global integer max_length_uid = 0;
global integer max_length_gid = 0;

global boolean customized_usersview = true;
global boolean customized_groupsview = true;

global string encoding = "";

// map of last uid used for new user (to fasten searching of free uid)
map last_uid = $[
    `system: 1,
    `local: 500];

map symbol_to_string = $[
    `local: "local",
    `system:"system",
    `nis:   "nis",
    `ldap:  "ldap",
    `kerb:  "kerb",
    `smb:   "smb"
];

/**
 * Build the cache structures, used for fasten operations
 * @param usermap the map of users
 * @param groupmap the map of groups
 * @param cust_u custom view of user sets
 * @param cust_g custom view of group sets
 * @return true
 */
global define boolean Read(map usermap, map groupmap, list cust_u, list cust_g) ``{

    current_users = user_custom_sets;
    PrintDate ("read cache start");

    foreach (`type, `usersmap, usermap, ``{
        BuildUsers (usersmap, type);
    });
    users_itemlists [ `custom ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ `custom ]:[];

    current_groups = group_custom_sets;

    foreach (`type, `groupsmap, groupmap, ``{
        BuildGroups (groupsmap, type);
    });
    groups_itemlists [ `custom ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ `custom ]:[];

    return true;
}

/**
 * Read the prebuilded cache structures from files
 * @param dir the location of input files
 * @return true
 */
global define void ReadFromFiles (string dir) ``{

    current_users = user_custom_sets;
    PrintDate ("read cache start");

    // could be the sets here explicitly?
    list start_sets = [`local, `system];
    foreach (`type, start_sets , ``{
        ReadUsers (type, dir);
    });
    PrintDate ("before merge");
    users_itemlists [ `custom ] = MergeUserTableItems();
    user_itemlist = users_itemlists [ `custom ]:[];
    PrintDate ("after merge");

//    ReadGroups ( start_sets, dir);
    foreach (`type, start_sets , ``{
        ReadGroups (type, dir);
    });
    groups_itemlists [ `custom ] = MergeGroupTableItems();
    group_itemlist = groups_itemlists [ `custom ]:[];

    PrintDate ("read cache end");
}

/**
 * Build the cache structures for user set
 * @param usersmap map of users of one type
 * @param type the users type
 */
global define void BuildUsers (map usersmap, symbol type) ``{

    PrintDate ("build users start");

    homelists = add (homelists, type, BuildHomeList (usersmap));
    usernamelists = add (usernamelists, type, BuildUsernameList (usersmap));
    users_itemlists = add (users_itemlists, type,
        BuildUserItemList(usersmap));
    uidlists [type] = BuildUIDList(usersmap);
    if (type != `system)
        last_uid [type] = max_system_uid + 1;
    else
        last_uid [type] = 1;
}

/**
 * Build the cache structures for group set
 * @param groupsmap map of groups of one type
 * @param type the groups type
 */
global define void BuildGroups (map groupsmap, symbol type) ``{

    if (groupnamelists [type]:nil == nil)
        groupnamelists [type] = BuildGroupnameList (groupsmap);
    groups_itemlists [type] = BuildGroupItemList(groupsmap);

    gidlists [type] = BuildGIDList(groupsmap);
}

/**
 * Read the prepared user data from the files
 * @param type the type of users
 * @param dir the source directory
 * @return true
 */
global define boolean ReadUsers (symbol type, string dir) ``{

    string stringtype = symbol_to_string[type]:"";

    PrintDate ("build users start");

    homelists [type] = SCR::Read(.target.ycp, dir + "/homelist_" +
        stringtype + ".ycp");
    usernamelists [type] = SCR::Read(.target.ycp, dir + "/usernamelist_" +
        stringtype + ".ycp");

    PrintDate ("homelist");
    // eval due to translation of system user names
    users_itemlists [type] = eval (
        SCR::Read(.target.ycp, dir + "/itemlist_" + stringtype + ".ycp"));

    PrintDate ("itemlists");
    uidlists [type] = SCR::Read(.target.ycp, dir + "/uidlist_" +
        stringtype + ".ycp");
    if (type != `nis)
        last_uid [type] = SCR::Read (.target.ycp, dir + "/last_" +
            stringtype + "_uid.ycp");

    return true; // TODO: test for errors while reading
}

/**
 * Read the prepared group data from the files
 * @param type the type of groups
 * @param dir the source directory
 * @return true
 */
global define boolean ReadGroups (symbol type, string dir) ``{

    string stringtype = symbol_to_string[type]:"";

    gidlists [type] = SCR::Read (.target.ycp, dir + "/gidlist_" +
        stringtype + ".ycp");
    groupnamelists [type] = SCR::Read (.target.ycp, dir + "/groupnamelist_" +
        stringtype + ".ycp");
    groups_itemlists [type] = SCR::Read(.target.ycp, dir + "/group_"
        + stringtype + "_itemlist.ycp");

    return true;
}


/**
 * Reset the structures, to use during autoinstallation
 */
global define void EmptyStructures () ``{

    homelists = $[];
    usernamelists = $[];
    uidlists = $[];
    groupnamelists = $[];
    gidlists = $[];
}

/**
 * Builds the list of home directories of given users
 * @param usersmap map of users of one type
 * @return list of homedirs
 */
global define list BuildHomeList(map usersmap) ``{

    list ret = [];
    foreach (`k, `v, usersmap, ``{
        if (v["home"]:nil != nil)
            ret = add (ret, v["home"]:nil);
    });
    return ret;
}

/**
 * Builds the list of user names
 * @param usersmap map of users of one type
 * @return list of names
 */
global define list BuildUsernameList(map usersmap) ``{

    list ret = [];
    foreach (`k, `v, usersmap, ``{
        if (v["username"]:nil != nil)
            ret = add (ret, v["username"]:nil);
    });
    return ret;
}

/**
 * Builds the list of group names
 * @param groupsmap map of groups of one type
 * @return list of names
 */
global define list BuildGroupnameList(map groupsmap) ``{

    list ret = [];
    foreach (`k, `v, groupsmap, ``{
        if (v["groupname"]:nil != nil)
            ret = add (ret, v["groupname"]:nil);
    });
    return sort (ret); //-- is this needed??
}


/**
 * Builds the list of uid's
 * @param usersset map of users of one type
 * @return list of id's
 */
global define list BuildUIDList(map usersset) ``{

    list ret = [];
        foreach (`uid, `usersmap, usersset, ``{
            ret = add (ret, uid);
        });
    return ret;
}

/**
 * Builds the list of gid's
 * @param groupsset map of groups of one type
 * @return list of id's
 */
global define list BuildGIDList(map groupsset) ``{

    list ret = [];
    foreach (`gid, `groupsmap, groupsset, ``{
            ret = add (ret, gid);
    });
    return ret;
}

/**
 * Build a string with n blanks
 * @param count number of blanks
 * @return string of blanks
 */
define string addBlanks(integer count ) ``{
    string  blanks = "";
    integer blanks_counter = 0;

    while (  blanks_counter < count )
    {
        blanks_counter = blanks_counter + 1;
//        blanks         = blanks + "\302\240"; // why this ??
        blanks         = blanks + " ";
    }
    return blanks;
}

/**
 * Builds item list for the user table
 * @param map_of_users users of one type
 * @return list of items for table widget
 */
global define list BuildUserItemList(map map_of_users) ``{

    list items = [];
    foreach ( `key, `user,  map_of_users, ``{
        string username = user["username"]:"";
        string  s_uid = sformat("%1", key );
        term    a     = `item(`id(key));

        if( size(s_uid) !=  max_length_uid )
            s_uid = addBlanks(max_length_uid - size(s_uid)) + s_uid;

        a = add(a, username );

        if (user["type"]:`local == `system)
            a = add(a, SystemUsers[username]:user["fullname"]:"" );
        else
            a = add(a, user["fullname"]:"" );

        a = add(a, s_uid );

        string own_group = user["groupname"]:"";
        string grouplist = user["grouplist"]:"";
        list l_grouplist = splitstring (grouplist, ",");

        if ( !contains (l_grouplist, own_group) && own_group != "")
        {
            if (grouplist != "")
                    grouplist = own_group + "," + grouplist;
            else
                grouplist = own_group;
        }

        a = add(a, grouplist );
        items = add( items, a );
    });

    return items;
}

/**
 * Uncode the string.
 * @param fullname string
 * @return string string recoded to UTF
 */
global define string Uncoding( string fullname ) ``{

    if (fullname == "" || fullname == nil)
        return "";
    else
        return UI::Recode( encoding, "UTF-8",  fullname );

}

/**
 * Builds item list for the group table
 * @param map_of_groups groups of one type
 * @return list of items for table widget
 */
global define list BuildGroupItemList(map map_of_groups) ``{

    integer the_answer = 42;
    list items = [];
    foreach ( `key, `group, map_of_groups, ``{

        string  s_gid = sformat("%1", key   );
        term    a     = `item(`id(key));

        if( size( s_gid) != Users::max_length_gid )
            s_gid = addBlanks( Users::max_length_gid - size(s_gid)) + s_gid;

        a = add(a, group["groupname"]:"" );
        a = add(a, s_gid);

        string userlist = group["userlist"]:"";
        string more = group["more_users"]:"";
        if ((userlist != "") && (more != ""))
            userlist = userlist + ",";
        userlist = userlist + more;
        // filter out the duplicates from more_groups??
        // shorten the list, if it is too long:
        list all_users = splitstring (userlist, ",");
        if (size (all_users) > the_answer)
        {
            userlist = "";
            integer i = 0;
            while (i < the_answer)
            {
                userlist = userlist + all_users[i]:"" + ",";
                i = i + 1;
            }
            userlist = userlist + "...";
        }
        a = add(a, userlist);

        items = add( items, a );
    });
    return items;
}

/**
 * Merge the users's item lists of types included in "custom view" to one list
 * @return new table itemlist
 */
global define list MergeUserTableItems() ``{

    list items = [];
    foreach (`usersset, user_custom_sets, ``{
            items = merge(items, users_itemlists [ usersset ]:[]);
    });
    return items;
}

/**
 * Merge the groups's item lists of types included in "custom view" to one list
 * @return new table itemlist
 */
global define list MergeGroupTableItems() ``{

    list items = [];
    foreach (`groupsset, group_custom_sets, ``{
            items = merge(items, groups_itemlists [ groupsset ]:[]);
    });
    return items;
}

/**
 * Change the list defining user's "custom view"
 * @param new new customized list
 */
global define void ChangeUserCustoms (list new) ``{

    user_custom_sets = new;
    users_itemlists [`custom] = MergeUserTableItems();
    if (customized_usersview)
        user_itemlist = users_itemlists [`custom]:[];
}

/**
 * Change the list defining group's "custom view"
 * @param new new customized list
 */
global define void ChangeGroupCustoms (list new) ``{

    group_custom_sets = new;
    groups_itemlists [`custom] = MergeGroupTableItems();
    if (customized_groupsview)
        group_itemlist = groups_itemlists [`custom]:[];
}


/**
 * Check if username already exists
 * @param username username
 * @return true if exists
 */
global define boolean UsernameExists(string username) ``{

    boolean ret = false;
    foreach (`type, `usernames, usernamelists, ``{
        if ( contains (usernames, username)) ret = true;
    });
    return ret;
}

/**
 * Check if homedir doesn't exist for another user
 * @param home the name
 * @return true if exists
 */
global define boolean HomeExists(string home) ``{

    boolean ret = false;
    foreach (`type, `homes, homelists, ``{
        if ( contains (homes, home)) ret = true;
    });
    return ret;
}

/**
 * Check if UID doesn't already exist
 * @param uid UID
 * @return true if exists
 */
global define boolean UIDExists(integer uid) ``{

    boolean ret = false;
    foreach (`type, `uids, uidlists, ``{
        if ( !ret && contains (uids, uid)) ret = true;
    });
    return ret;
}

/**
 * Check if GID doesn't already exist
 * @param gid GID
 * @return true if exists
 */
global define boolean GIDExists(integer gid) ``{

    boolean ret = false;
    foreach (`type, `gids, gidlists, ``{
        if ( !ret && contains (gids, gid)) ret = true;
    });
    return ret;
}

/**
 * Check if groupname already exists
 * @param groupname groupname
 * @return true if exists
 */
global define boolean GroupnameExists(string groupname) ``{

    boolean ret = false;
    foreach (`type, `groupnames, groupnamelists, ``{
        if ( contains (groupnames, groupname)) ret = true;
    });
    return ret;
}

/**
 * Scan uidlist for the next free uid.
 * @return integer free uid
 */
global define integer NextFreeUid() ``{

    integer uid = last_uid [user_type]:last_uid [`local]:1;
    integer max = max_uid;
    if (user_type == `system)
        max = max_system_uid;
    repeat
    {
        if (UIDExists (uid))
            uid = uid + 1;
        else
        {
            last_uid [user_type] = uid;
            return uid;
        }
    } until ( uid == max );
    return nil;
}

/**
 * Scan the groupsettings for the next free gid.
 * @return integer free gid
 */
global define integer NextFreeGid() ``{
    // can't delete gid 101 with groupdel ????
    // FIXME ERROR
    //if ( gid == 101 ) gid = 102;

    integer min = 1;
    integer max = max_gid;
    if (group_type == `system)
        max = max_system_gid;
    else // beware !! what about LDAP etc.??
        min = max_system_gid + 1;
    integer gid = min;
    repeat
    {
        if (GIDExists (gid))
            gid = gid + 1;
        else return gid;
    } until ( gid == max );
    return nil;
}

/**
 * Update the proper itemlist shown in table
 */
define void UpdateUserItemlist () ``{

    if (contains (user_custom_sets, user_type))
        users_itemlists [`custom] = MergeUserTableItems();
    if (! (customized_usersview))
    {
        symbol type = current_users[0]:user_type;
        user_itemlist = users_itemlists [type]:[];
    }
    else
        user_itemlist = users_itemlists [`custom]:[];

    user_itemlist = sort (user_itemlist);
}

/**
 * Update the proper itemlist shown in table
 */
define void UpdateGroupItemlist () ``{

    if (contains (group_custom_sets, group_type))
        groups_itemlists [`custom] = MergeGroupTableItems();
    if (! (customized_groupsview))
    {
        symbol type = current_groups[0]:group_type;
        group_itemlist = groups_itemlists [type]:[];
    }
    else
        group_itemlist = groups_itemlists [`custom]:[];

    group_itemlist = sort (group_itemlist);
}

/**
 * Update the cache after changing user
 * @param what the action done with the user
 * @param user the user's map
 */
global define void ChangeUser(symbol what, map user) ``{

    integer uid = user["uid"]:nil;
    integer org_uid = user["org_uid"]:uid;
    string home = user["home"]:nil;
    string org_home = user["org_home"]:nil;
    string username = user["username"]:nil;
    string org_username = user["org_username"]:username;
    symbol type = user["type"]:`local;

    if (what == `add_user)
    {
        uidlists [type] = prepend (uidlists [type]:[], uid);
        homelists [type] = add (homelists [type]:[], home);
        usernamelists [type] = add (usernamelists [type]:[], username);
        users_itemlists [type] = merge (users_itemlists [type]:[],
            BuildUserItemList( $[ uid : user ] ));
        UpdateUserItemlist ();
    }
    else if (what == `edit_user || what == `group_change)
    {
        if (uid != org_uid)
        {
            uidlists [type] = filter (`u, uidlists [type]:[], ``(u != org_uid));
            uidlists [type] = prepend (uidlists [type]:[], uid);
        }
        if (home != org_home)
        {
            homelists [type] = filter (`h, homelists [type]:[], ``(h != home));
            homelists [type] = prepend (homelists [type]:[], home);
        }
        if (username != org_username)
        {
            usernamelists [type] = filter (`u, usernamelists [type]:[],
                ``(u != org_username));
            usernamelists [type] = prepend (usernamelists [type]:[], username);
        }
        users_itemlists [type] = filter (`item, users_itemlists [type]:[],
            ``(select(item,1,"") != org_username));
        users_itemlists [type] = prepend (users_itemlists [type]:[],
            select (BuildUserItemList( $[ uid : user ] ), 0, []));
        UpdateUserItemlist ();
    }
    else if (what == `delete_user)
    {
        uidlists [type] = filter (`u, uidlists [type]:[], ``(u != uid));
        homelists [type] = filter (`h, homelists [type]:[], ``(h != home));
        usernamelists [type] = filter (`u, usernamelists [type]:[],
                ``(u != username));
        users_itemlists [type] = filter (`item, users_itemlists [type]:[],
            ``(select(item,1,"") != username));
        UpdateUserItemlist ();
    }

}

/**
 * Update the cache after changing group
 * @param what the action done with the group
 * @param group the group's map
 */
global define void ChangeGroup (symbol what, map group) ``{

    integer gid = group["gid"]:nil;
    integer org_gid = group["gid"]:gid;
    string groupname = group["groupname"]:nil;
    string org_groupname = group["org_groupname"]:groupname;
    symbol type = group["type"]:`local;

    if (what == `add_group)
    {
        gidlists [type] = prepend (gidlists [type]:[], gid);
        groupnamelists [type] = add (groupnamelists [type]:[], groupname);
        groups_itemlists [type] = merge (groups_itemlists [type]:[],
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
    else if (what == `edit_group || what == `user_change)
    {
        if (gid != org_gid)
        {
            gidlists [type] = filter (`g, gidlists [type]:[], ``(g != org_gid));
            gidlists [type] = prepend (gidlists [type]:[], gid);
        }
        if (groupname != org_groupname)
        {
            groupnamelists [type] = filter (`u, groupnamelists [type]:[],
                ``(u != org_groupname));
            groupnamelists [type] = prepend (groupnamelists[type]:[],groupname);
        }
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
    else if (what == `delete_group)
    {
        gidlists [type] = filter (`g, gidlists [type]:[], ``(g != gid));
        groupnamelists [type] = filter (`g, groupnamelists [type]:[],
                ``(g != groupname));
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != groupname));
        UpdateGroupItemlist ();
    }
    else if (what == `itemlist)
    {
        groups_itemlists [type] = filter (`item, groups_itemlists [type]:[],
            ``(select(item,1,"") != org_groupname));
        groups_itemlists [type] = merge (groups_itemlists [type]:[], //add?
            BuildGroupItemList( $[ gid : group ] ));
        UpdateGroupItemlist ();
    }
}

/**
 * Speed debug function - prints current time to log
 * @param message debug message
 */
global define void PrintDate(string message) ``{

//    y2warning ("%1: %2", message, lookup (SCR::Execute(.target.bash_output, "date +%X"), "stdout", ""));
}


}
