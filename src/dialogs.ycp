/**
 * File:	include/users/dialogs.ycp
 * Package:	Configuration of users and groups
 * Summary:	Dialogs definitions
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "users";

import "Wizard";
import "Mode";
import "Report";
import "Progress";
import "Summary";
import "Require";
import "Autologin";
import "Call";

import "Users";
import "UsersCache";

import "Label";
import "Popup";

include "users/helps.ycp";
include "users/routines.ycp";


/**
 * Function that adds or edits a user.
 * @param what "add_user" or "edit_user"
 * @return symbol for wizard sequencer
 */
global define symbol EditUserDialog(string what) ``{

//Users::start_dialog = "user_add";
//Mode::cont = true;
    // maybe we have returned to the first "add user dialog"
    // during installation workflow:
    if (Users::start_dialog == "user_add" && Mode::cont && Users::use_next_time)
    {
        Users::user_in_work = eval (Users::saved_user);
        Users::use_next_time = false;
    }

    if (what == "add_user")
    {
	if (!Users::Add("user", Users::user_in_work))
	    return `nosave;
    }
    else
    {
	if (!Users::Edit("user", Users::user_in_work))
	    return `nosave;
    }

    // use local map here...
    map user = eval (Users::user_in_work);

    string user_type	= user["type"]:"local";
    string username	= user["username"]:"";
    string cn		= "";
    // in LDAP, cn is list of strings...
    if (is (user["cn"]:"", list))
	cn	= user["cn",0]:"";
    else
	cn	= user["cn"]:"";
    string tmp_fullname	= cn; // for login proposing
    string default_home = Users::GetDefaultHome(true, user_type);
    string home		= user["home"]:default_home;
    string org_home	= user["org_home"]:home;
    string password	= user["password"]:"x";
    string org_username = user["org_username"]:username;
    boolean create_home	= user["create_home"]:true;
    map shadow		= user["shadow"]:$[];
    integer uid		= user["uid"]:nil;
    string dn		= user["dn"]:"";
    string new_dn	= dn;

    if ( uid ==  nil )
    {
        y2error ("user has no UID?");
        return `nosave;
    }

    // only for LDAP users:
    string sn = user["sn"]:SplitFullName(`sn, cn);
    string givenName = user["givenName"]:SplitFullName(`givenName, cn);

    boolean do_not_edit = (user_type == "nis");

    map dialog_labels = $[
        "add_user": $[
            // dialog caption:
            "local":    _("Add a New Local User"),
            // dialog caption:
            "system":	_("Add a New System User"),
            // dialog caption:
            "ldap":     _("Add a New LDAP User")
        ],
        "edit_user": $[
            // dialog caption:
            "local":    _("Edit an Existing Local User"),
            // dialog caption:
            "system":	_("Edit an Existing System User"),
            // dialog caption:
            "ldap":	_("Edit an Existing LDAP User"),
            // dialog caption:
            "nis":	_("Edit an Existing NIS User")
        ]
    ];

    term name_entries =
        // text entry
	`TextEntry (`id(`cn), _("&Full User Name"), cn);
    if (user_type == "ldap")
    {
	name_entries = `VBox(
            // text entry
            `TextEntry(`id(`givenName), _("F&irst Name"), givenName),
            // text entry
            `TextEntry(`id(`sn),  _("&Last Name"),  sn ));
    }


    term fields = `VBox(
	`VStretch(),
	`VBox(
	    // label text
	    do_not_edit ? `Label(_("Only additional group memberships
can be changed for non-local users.
")) : `VSpacing (0),
	    do_not_edit ? `VSpacing (1) : `VSpacing (0),
	    name_entries
	),
	`VSquash(
	    `HBox(
		// input field for login name
		`Bottom(`TextEntry(`id(`username), _("&User Login"), username)),
		(what != "add_user")
		    ? `HSpacing (0)
		    // push button to generate login from first and last name
		    : `Bottom(`PushButton(`id(`propose), _("&Suggestion"))))
	),
	// first version of user password
	`Password(`id(`pw1), _("P&assword"), ""),
	// second version of user password, retyped to avoid typos
	// please use newline if it is longer than 48 characters
	`Password(`id(`pw2), _("&Verify Password:"), "")
    );

    term optionbox = `Empty();
    term buttonbox = `VBox(
	`PushButton(`id(`passwordsettings),`opt(`key_F7, `hstretch),
	    // push button label
	    _("&Password Settings...")),
	// push button label
	`PushButton(`id(`details),`opt(`key_F2, `hstretch), _("&Details..."))
    );

    boolean complex_layout = Mode::cont && Users::start_dialog == "user_add";

    if ( complex_layout )
    {
	term checkboxes = `VBox(
	    // checkbox label
	    `Left( `CheckBox (`id (`root_mail),_("Receive S&ystem Mail"),
		Users::root_mail != "") ),
	    `VSpacing (0.5),
	    // checkbox label
	    `Left( `CheckBox (`id (`autologin),_("A&uto Login"),
		Autologin::used) )
	);
	optionbox = `HBox(
			  `HStretch(),
			  `HVCenter( `HVSquash( checkboxes ) ),
			  `HSpacing( 1 ),
			  `HVCenter( `HVSquash( buttonbox  ) ),
			  `HSpacing( 1 )
			  );
    }
    else
    {
	optionbox = `HVCenter( `HSquash( buttonbox  ) );
    }

    term contents = `VBox(
	`VSpacing(),
	// Frame title
	`Frame( _("User Data"), `HVSquash(
	    `VBox(
		`VSpacing( 0.5 ),
		`HBox( `HSpacing( 2 ),
		       `VBox(
			     `HSquash( fields ),
			     `VSpacing( 1 ),
			     `VSquash( `Top( optionbox ) )
			     ),
		       `HSpacing( 2 )),
		`VSpacing( 0.5 )
	    )
	))
    );


    if ( complex_layout )
    {
	contents = add ( contents, `VBox (
	    `VSpacing (0.5),
	    `HCenter(`PushButton(`id(`additional), `opt(`key_F3),
		// push button
		_("User &Management") ) ),
	    `VSpacing (0.5))
	);
    }
    contents = `VCenter (contents);

    Wizard::SetContentsButtons(
            dialog_labels [ what, user_type ]:"",
            contents,
            EditUserDialogHelp (Mode::cont && Users::start_dialog == "user_add",
		user_type, what),
            Label::BackButton(), Label::NextButton());

    // TODO edit values for NIS users
    if (do_not_edit)
    {
        UI::ChangeWidget (`id(`cn), `Enabled, false);
        UI::ChangeWidget (`id(`username), `Enabled, false);
        UI::ChangeWidget (`id(`pw1), `Enabled, false);
        UI::ChangeWidget (`id(`pw2), `Enabled, false);
        UI::ChangeWidget (`id(`passwordsettings), `Enabled, false);
    }

    UI::ChangeWidget (`id (`username), `ValidChars, Users::valid_logname_chars);

    if ( what == "add_user" )
    {
        if ( !Mode::cont )
            Wizard::ReplaceNextButton (`PushButton (`id (`next),
                // change of button label
                `opt(`key_F10, `default), _("&Create")));
        else
            Wizard::ReplaceNextButton (`PushButton (`id (`next), `opt(`default),
                Label::NextButton()));
    }

    if ( what == "add_user" )
    {
	if (user_type == "system")
	    UI::ChangeWidget(`id(`propose), `Enabled, false );
	if (user_type == "ldap")
	    UI::SetFocus(`id(`givenName));
	else
	    UI::SetFocus(`id(`cn));
    }

    if( password != "")
    {
        UI::ChangeWidget(`id(`pw1), `Value, Users::default_pw);
        UI::ChangeWidget(`id(`pw2), `Value, Users::default_pw);
    }

    if (complex_layout && !Autologin::available)
	UI::ChangeWidget(`id(`autologin), `Enabled, false );

    any ret = `next;
    repeat
    {
        ret = UI::UserInput();

        username	= UI::QueryWidget(`id(`username), `Value);

	if (! contains ([`back, `cancel, `abort], ret))
	{
	    if (user_type == "ldap")
	    {
		// Form the fullname for LDAP user
		// sn (surname) and cn (fullname) are required attributes,
		// they cannot be empty
		givenName	= UI::QueryWidget(`id(`givenName), `Value);
		sn		= UI::QueryWidget(`id(`sn ), `Value);

		// create default cn/sn if they are not marked for substitution
		if (!(haskey (Users::ldap_user_defaults, "sn") &&
		      what == "add_user") &&
		    sn == "")
		{
		    if (givenName == "")
		    {
			sn = username;
		    }
		    else
		    {
			sn = givenName;
			givenName = "";
		    }
		}
		if (!(haskey (Users::ldap_user_defaults, "cn") &&
		      what == "add_user")
		    && cn == "")
		    cn = givenName + ((givenName != "") ? " " : "") + sn;
		UI::ChangeWidget(`id(`givenName), `Value, givenName);
		UI::ChangeWidget(`id(`sn), `Value, sn);
	    }
	    else
	    {
		cn	= UI::QueryWidget(`id(`cn), `Value);
		if (findfirstof(cn, Users::invalid_gecos_chars) != nil)
		{
		    // error message
		    Report::Error(_("
The full user name cannot contain
: or , characters.
Try again.
"));
		    UI::SetFocus(`id(`cn));
		    continue;
		}
	    }
	    user ["cn"]	= cn;
	    user ["givenName"] = givenName;
	    user ["sn"] = sn;
	}

        // generate a login name from first and last name
        if (ret == `propose)
        {
	    string to_propose = issubstring (cn, "%") ?
		givenName + " " + sn : cn;
	    if (tmp_fullname != to_propose)
	    {
		UsersCache::proposal_count = -1;
		tmp_fullname = to_propose;
	    }
	    username = UsersCache::ProposeUsername(
		filterchars (to_propose, Users::valid_logname_chars + " "));
            UI::ChangeWidget(`id(`username), `Value, username);
        }

        // only in continue mode
        if( ret == `additional )
        {
            if (UI::QueryWidget(`id(`pw1), `Value) == "" &&
                UI::QueryWidget(`id(`pw2),`Value) == ""  &&
                UI::QueryWidget(`id(`username), `Value) == "" &&
                UI::QueryWidget(`id(`cn), `Value) == "")
            ret = `nosave;
        }

        boolean details = (contains ([`details,`passwordsettings,`ldap], ret));

	if (ret == `passwordsettings && user_type == "ldap" &&
	    !contains (user["objectClass"]:[], "shadowAccount"))
	{
		// error, do not translate 'shadowAccount' (LDAP user parameter)
		Popup::Error (_("User does not have 'shadowAccount' as the Object Class,
so the password settings cannot be edited.
"));
		continue;
	}

        if (( ret == `next || ret == `additional || details ) && !do_not_edit)
        {
	    // --------------------------------- username checks, part 1/2
            if ( username == "" && Mode::cont && ret == `next &&
		 Users::start_dialog == "user_add")
	    {
		// The user login field is empty, this is allowed if the
		// system is part of a network with (e.g.) NIS user management.
                // yes-no popup headline
                if (  Popup::YesNoHeadline(_("Empty user login"),
                // yes-no popup contents
                 _("Leaving the user name empty only makes sense
in a network environment with an authentication server.

Are you sure?
")))
                {
                    ret = `nextmodule;
                    break;
                }
                UI::SetFocus(`id(`username));
                continue;
            }
            else if ( username == "")
            {
                // The username is empty (no user input).
                // error popup
                Report::Error(_("You didn't enter a username.
Please try again.
"));
                UI::SetFocus(`id(`username));
                continue;
            }

            if ( size( username ) < UsersCache::min_length_login ||
		 size( username ) > UsersCache::max_length_login )
            {
                // The username don't have a correct length
                // error popup, %1 is minimum, %2 maximum
                Report::Error(sformat(_("The user name must be between %1 and %2 characters in length.
Try again.
"), UsersCache::min_length_login, UsersCache::max_length_login));
                UI::SetFocus(`id(`username));
                continue;
            }

            string firstchar = substring(username, 0, 1);
            if ((! ((firstchar >= "A" && firstchar <= "z" )
                    || firstchar == "_")
                || nil!=findfirstnotof(username, Users::valid_logname_chars)))
            {

                // The login name contains invalid characters
                // error popup
                Report::Error(_("The user login may contain only
letters, digits, \"-\", \".\", and \"_\"
and must begin with a letter or \"_\".
Try again.
"));
                UI::SetFocus(`id(`username));
                continue;
            }

            // check if login is unique
            if ( (username != lookup( user , "username",""))
                 && UsersCache::UsernameExists(username))
            {

                // Entered login name conflicts with some existing login
                // error popup
                Report::Error(_("There is a conflict between the entered
login name and an existing user name.

Try another one.
"));
                UI::SetFocus(`id(`username));
                continue;
            }
	    // now save username to map
	    user["username"]	= username;
	    // --------------------------------- password checks
            string pw1   = UI::QueryWidget(`id(`pw1), `Value);
            string pw2   = UI::QueryWidget(`id(`pw2), `Value);

            if ( pw1 != pw2 )
            {
                // The two user password information do not match
                // error popup
                Report::Error(_("The first and the second version
of the password are different.
Please try again."));
		clear_password_fields ();
                continue;
            }

            // Use the old password (if any) if no passwords were entered.
            // only check pw1 here, its identical with pw2 as checked before
            if ( pw1 != Users::default_pw )
            {
            if ( pw1 == "" && !details )
            {
		// No password was entered
                // error popup
                Report::Error(_("You didn't enter a password.\nPlease try again."));
		clear_password_fields ();
                continue;
            }
	    integer min_length_pas = Users::pass_length [user_type,"min"]:5;
            if (size (pw1) < min_length_pas && pw1 != "")
            {
                // Password is too short
                // error popup. %1 and %2 are numbers (typical 5 and 8)
                Report::Error(sformat(_("The password must have between %1 and %2 characters.\nPlease try again."),
                    Users::pass_length [user_type,"max"]:8, min_length_pas));
		clear_password_fields ();
                continue;
            }
            if ( size(pw1) >=  min_length_pas )
            {
                if ( nil != findfirstnotof( pw1, Users::valid_password_chars ))
                {

                // The user password contains restricted characters
                // error popup
                Report::Error(_("The password may only contain the following characters:
0..9, a..z, A..Z, and any of \"#* ,.;:._-+!$%^&/|\?{[()]}\".
Please try again."));
		clear_password_fields ();
                continue;
                }
            }
            /* password check against cracklib */
            if (Users::use_cracklib && pw1 != "")
            {
                string out = CrackPassword (username, pw1);
                // question; %1 is error message of cracklib
                if (out != "" && out != "OK" && !Popup::YesNo (sformat(_("Password is too simple:
%1
Really use it?
"), out)))
                {
		    clear_password_fields ();
                    continue;
                }
            }
            if (Users::obscure_checks && pw1 != "")
            {
                string obs = CheckObscurity (username, pw1);
                if (obs != "OK" && !Popup::YesNo (obs))
                {
		    clear_password_fields ();
                    continue;
                }
            }
	    if (!CheckPasswordMaxLength (pw1, user_type))
	    {
		clear_password_fields ();
		continue;
	    }
	    }

	    // -------------------------------------- directory checks
            // build default home dir
            if ( home == default_home || home == "")
            {
		// LDAP: maybe home should be substituted
		if ( user_type == "ldap" && issubstring (home, "%") )
		{
		    user = Users::SubstituteValues ("user", user);
		    home = user["home"]:default_home;
		}
		if ( home == default_home  || home == "")
                    home = home + username;
            }

            if ( !details && (what == "add_user" || home != org_home))
            {
                // new popup for existing dir
                if (UsersCache::HomeExists(home))
                {
                    // error popup
                    Report::Error(_("The default home directory is used from another user.
Please press button Details and edit home directory."));
                    home = defualt_home;
                    continue;
                }
                // do not check in autoinstal config and for ldap client
                if ((user_type != "ldap" || Users::ldap_file_server) &&
                    !Mode::config && create_home &&
                    SCR::Read(.target.size, home ) != -1)
                {
                    integer dir_uid = lookup (SCR::Read(.target.stat, home), "uid", -1);
                    string question = sformat(
// yes-no popup, %1 is home directory
_("The home directory selected (%1) already exists.
Use it and change its owner?"), home);
                    if (uid == dir_uid) // chown is not needed (#25200)
                        question = sformat(
// yes-no popup
_("The home directory selected (%1)
already exists and is owned by the currently edited user.
Use this directory?
"), home);

		    // maybe it is home of some user marked to delete...
		    else if (contains (Users::removed_homes, home))
			question = sformat(
// yes-no popup
_("The home directory selected (%1)
already exists as a former home directory of
a user currently marked for deletion.
Use this directory?
"), home);

                    if (! Popup::YesNo(question))
                    {
                        home = default_home;
                        continue;
                    }
                    create_home = false;
                }
		user["create_home"]	= create_home;
                // do not check in autoinstal config and for ldap client
                if ((user_type != "ldap" || Users::ldap_file_server) &&
                    !Mode::config && what == "add_user")
                {
                    string home_path =
                        substring (home,0, findlastof(home,"/"));
                    home_path = Users::IsDirWritable (home_path);
                    if (home_path != "")
                    {
                        // error popup (%1 is part of home path, e.g. "/home")
                        Report::Error(sformat (_("The directory %1 is not writable.
Press Details and edit the home directory."), home_path));
                        home = default_home;
                        continue;
                    }
                }
            }
	    // save home
	    user ["home"]	= home;
	    // --------------------------------- username checks, part 2/2
	    // (it is at the end because it is question)
	    // upperase letters were used in username! bug #26409
            if ( username != tolower (username) && !Users::not_ask_uppercase &&
		 (what == "add_user" || username != org_username) &&
		 Require::IsAnyPackageInstalled (["sendmail", "postfix"]))
            {
                // The login name contains uppercase 1/3
		string text = _("<p>
You have used uppercase letters in the user login entry.</p>") +

                // The login name contains uppercase 2/3
_("<p>This could cause problems with delivering the mail
to this user, because mail systems generally do not
support case-sensitive names.<br>
You could solve this problem by editing the alias table.</p>
") +

                // The login name contains uppercase 3/3
_("<p>Really use the entered value?</p>");

		UI::OpenDialog (`opt(`decorated), `HBox(`VSpacing (14),
		    `VBox(
		    `HSpacing(50),
		    `RichText (`id(`rt), text),
		    `CheckBox (`id(`ch), `opt(`notify),
		    // checkbox label
		    _("Do Not Show This Message &Again")),
		    `HBox(
		    `PushButton (`id(`ok),`opt(`key_F10), Label::YesButton()),
		    `PushButton (`id(`no),`opt(`key_F9), Label::NoButton())
		    )))
		);
		any r = nil;
		do {
		    r = UI::UserInput();
		}
		while (!contains ([`cancel, `ok, `no], r));

		if (r != `cancel)
		{
		    Users::not_ask_uppercase = UI::QueryWidget(`id(`ch),`Value);
		    if (Users::not_ask_uppercase)
			Users::customs_modified = true;
		}
		UI::CloseDialog();
		if (r != `ok)
		{
		    UI::SetFocus(`id(`username));
		    continue;
		}
            }

	    // --------------------------------- save the password
            if (pw1 != "x" && pw1 != "" && pw1 != Users::default_pw)
            {
                // to use with autoinst.
                if (user["encrypted"]:true)
		{
                    password = Users::CryptPassword (pw1, user_type);
                }
                else password = pw1;

		user ["password"]		= password;
                shadow ["password"]		= password;
                shadow ["last_change"]		= Users::LastChangeIsNow();
		if (user_type == "ldap")
		    user ["shadowLastChange"]	= shadow["last_change"]:"";
		else
		    user ["shadow"]		= shadow;
            }
	    // --------------------------------- now everything should be OK
            if ( what == "edit_user" )
            {
                if ( org_username != username && org_username !="")
		{
                    user ["org_username"] = org_username;
		    if (user_type == "ldap")
		    {
			if (!haskey (user, "org_dn"))
			    user ["org_dn"] = dn;
			user ["dn"]	= Users::CreateUserDN (user);
		    }
		}
            }
	    else // add_user
	    {
		if (user_type == "ldap")
		{
		    new_dn	= Users::CreateUserDN (user);
		    user ["dn"] = new_dn;
		    user ["org_dn"] = new_dn;
		    if (details)
			user = Users::SubstituteValues ("user", user);
		}
		user["org_home"] = user["home"]:"";
	    }
	    Users::user_in_work = eval (user);
	}
	// TODO check for `abort here (otherwise, new values are lost when abort
	// is not confirmed)
    }
    until ( contains ([`next,`abort,`back,`cancel,`additional,`nosave,`ldap],
	    ret) || details );

    if (Users::start_dialog == "user_add" && Mode::cont)
    {
        Users::root_mail = UI::QueryWidget (`id (`root_mail), `Value)
            ? username : "";
	if (Autologin::available)
	{
	    Autologin::user = UI::QueryWidget (`id (`autologin), `Value)
		? username : "";
	    Autologin::used = UI::QueryWidget (`id (`autologin), `Value);
	}
    }
    if( ret == `additional ||  ret == `nosave )
    {
        // suring installation the first user is stored
        // (to show it when clicking `back from Summary dialog)
        Users::saved_user = Users::user_in_work;
    }
    return ret;
}


/**
 * Details of adding/cloning/editing dialog
 * @return symbol for wizard sequencer
 */
global define symbol EditUserDetailsDialog( ) ``{

    // load the current usersettings from Users::user_in_work
    string user_type      = Users::user_in_work["type"]:"local";
    string what           = Users::user_in_work["what"]:"no";
    string username       = Users::user_in_work["username"]:"";
    string cn		  = Users::user_in_work["cn"]:"";
    string home           = Users::user_in_work["home"]:"";
    string org_home       = Users::user_in_work["org_home"]:"";
    boolean create_home   = Users::user_in_work["create_home"]:true;
    string shell          = Users::user_in_work["shell"]:"";
    string grouplist      = Users::user_in_work["grouplist"]:"";
    integer uid = Users::user_in_work["uid"]:Users::max_uid [user_type]:60000;
    integer gid = Users::user_in_work["gid"]:Users::max_gid [user_type]:60000;
    string defaultgroup   = Users::user_in_work["groupname"]:"";

    // additional parts of GECOS (shown by `finger <username>`) (passwd only)
    string addit_data	= Users::user_in_work["addit_data"]:"";

    list available_shells = Users::all_shells_items;
    list available_groups = [];
    list additional_groups = [];
    list additional_ldap_groups = [];
    list list_grouplist = splitstring (grouplist, ",");
    list removed = [];

    string new_type = user_type;

    /* fill the list available_groups and set the user default group true */
    foreach ( `grouptype, `groupset, UsersCache::groupnamelists, ``{
        if (grouptype == "local" || grouptype == "system" ||
            (grouptype == "ldap" && user_type == "ldap"))
	{
          foreach ( `group, groupset, ``{

            if (user_type == "ldap")
            {
                if (grouptype == "ldap")
                {
                    if ( group == defaultgroup )
                        available_groups = add (available_groups,
                            `item( `id(group), group, true));
                    else
                        available_groups = add (available_groups,
                            `item( `id(group), group));
                    if ( contains (list_grouplist, group))
                        additional_ldap_groups = add (additional_ldap_groups,
                            `item( `id(group), group, true ));
                    else
                        additional_ldap_groups = add (additional_ldap_groups,
                            `item( `id(group), group, false));
                }
                else
                {
		    // if there is a group with same name, use only that
		    // with type "ldap"
		    if ( contains (UsersCache::groupnamelists["ldap"]:[],group))
			return;
                    if ( contains (list_grouplist, group))
                        additional_groups = add (additional_groups,
                            `item( `id(group), group, true ));
                    else
                        additional_groups = add (additional_groups,
                            `item( `id(group), group, false));
                }
            }
            else
            {
                if ( group == defaultgroup )
                    available_groups = add (available_groups,
                        `item( `id(group), group, true));
                else
                    available_groups = add (available_groups,
                        `item( `id(group), group));
                if ( contains (list_grouplist, group))
                    additional_groups = add (additional_groups,
                        `item( `id(group), group, true ));
                else
                    additional_groups = add (additional_groups,
                        `item( `id(group), group, false));
            }
          });
	}
    });
    if (defaultgroup == "")
    {
        available_groups = add (available_groups,
	    // group name is not known:
	    `item( `id(""), _("(not known)"), true));
    }

    boolean do_not_edit = (user_type == "nis");
    term edit_defaultgroup = `ComboBox(`id(`defaultgroup), `opt(`hstretch),
        // combobox label
        _("Default &group"), available_groups );
    term edit_shell = `ComboBox(`id(`shell), `opt(`hstretch, `editable),
        // combobox label
        _("Login &shell"), available_shells );

    term additional_data = `Empty();
    if (user_type == "system" || user_type == "local")
        additional_data =
            // textentry label
            `Top(`TextEntry(`id(`addd), _("&Additional User Information:"),
                addit_data));

    boolean skel_check = (what == "add_user" &&
	(user_type != "ldap" || Users::ldap_file_server));

    term browse = `VBox(
//	skel_check ? `Empty() :
	`Label (""),
	// button label
        `PushButton( `id(`browse), `opt(`key_F6), _("Bro&wse...")));

    term home_w = `VBox(
	// textentry label
	`TextEntry( `id(`home), _("&Home Directory"), home )
	/*,
	(skel_check)
	    // checkbox label FIXME no checking
	    ? `Left (`CheckBox (_("&Copy Skeleton"), user_type != "system"))
	    : `Empty()
	*/
    );

    term contents =
        `HBox(
          `HSpacing(1),
          `VBox(
           `VSpacing(0.5),
           // label
           do_not_edit ? `Label(_("Only additional group memberships
can be changed for non-local users.")) : `VSpacing (0),
           do_not_edit ? `VSpacing (1) : `VSpacing (0),
           // frame label, user name follows
           `VSpacing(0.5),
           `Frame(sformat(_("Detailed Profile for User \"%1\""),
		username),
           `HBox(
		`HSpacing (1),
                `VBox(
		    `VSpacing (0.5),
                    // textentry label
                    `Top(`TextEntry( `id(`uid), _("User &ID (uid)"),
                        sformat("%1",uid ))),
                    `Top(`HBox ( home_w, browse)),
                    additional_data,
                    `Top(edit_shell),
                    `Top(edit_defaultgroup),
                    `VStretch()
                ),
                `HSpacing(2),
		`VBox(
		    `VSpacing (0.5),
		    `Top(`MultiSelectionBox( `id(`grouplist),
			// selection box label
			_("Additional Group &Membership"), additional_groups)),
		    (user_type == "ldap")
		    ? `MultiSelectionBox( `id(`ldapgrouplist),
			// selection box label
			_("Additional &LDAP Groups"), additional_ldap_groups)
		    : `Empty()
		    ),
		`HSpacing (1)
            )),
            `VSpacing(0.5)
           ),
           `HSpacing(1)
        );

    // dialog caption
    Wizard::SetContentsButtons(_("Add/Edit User Properties - Details"),
                    contents,
                    EditUserDetailsDialogHelp(user_type),
                    Label::BackButton(),
                    Label::NextButton());

    if (do_not_edit)
    {
        UI::ChangeWidget (`id (`uid), `Enabled, false);
        UI::ChangeWidget (`id (`home), `Enabled, false);
        UI::ChangeWidget (`id (`shell), `Enabled, false);
        UI::ChangeWidget (`id (`defaultgroup), `Enabled, false);
        UI::ChangeWidget (`id (`browse), `Enabled, false);
    }
    if (user_type == "ldap")
    {
        if (!Users::ldap_file_server)
	{
            UI::ChangeWidget (`id (`browse), `Enabled, false);
//	    if (what != "add_user")
//		UI::ChangeWidget (`id (`home), `Enabled, false);
	}
    }

    UI::ChangeWidget(`id(`shell),    `Value,   shell );

    // user input
    any ret = `next;
    repeat
    {
        ret = UI::UserInput();
	if ( ret == `browse)
	{
	    string dir = home;
	    if (SCR::Read(.target.size, home ) == -1)
		dir = Users::GetDefaultHome (true, user_type);
	    dir = UI::AskForExistingDirectory (dir, "");
	    if (dir != nil)
	    {
		if ( (findlastof( dir, "/") + 1) == size(dir) )
		    dir = substring (dir, 0, size(dir)-1);
		UI::ChangeWidget (`id(`home), `Value, dir);
	    }
	    // TODO: add directory checks here...
	}
        if ( ret == `next )
        {
            string  new_home  = UI::QueryWidget(`id(`home),  `Value);
	    if ( (findlastof( new_home, "/") + 1) == size(new_home) )
		new_home = substring (new_home, 0, size(new_home)-1);
            string  new_shell = UI::QueryWidget(`id(`shell), `Value);
            string  new_uid   = UI::QueryWidget(`id(`uid),   `Value);
            string  new_defaultgroup=UI::QueryWidget(`id(`defaultgroup),`Value);

            if (do_not_edit) // check for Ena/Dis
            {
                new_home = home;
                new_shell = shell;
                new_uid = sformat("%1", uid);
                new_defaultgroup = defaultgroup;
            }
	    // additional data in GECOS field (passwd only)
            if (user_type == "local" || user_type == "system")
            {
                addit_data  = UI::QueryWidget(`id(`addd),  `Value);
                if (findfirstof(addit_data, ":") != nil)
                {
                    // error message
                    Report::Error(_("The \"Additional User Information\" entry cannot
contain a colon (:).  Try again.
"));
                    UI::SetFocus(`id(`addd));
                    continue;
                }
                list add_l = splitstring (addit_data, ",");
                if (size (add_l) > 3 )
                {
                    // error message
                    Report::Error(_("The \"Additional User Information\" entry can consist
of up to three sections separated by commas.
Remove the surplus.
"));
                    UI::SetFocus(`id(`addd));
                    continue;
                }
            }

            list new_list_grouplist = UI::QueryWidget(`id(`grouplist),
                `SelectedItems );
	    if (user_type == "ldap")
	    {
		new_list_grouplist = merge (new_list_grouplist,
		    UI::QueryWidget(`id(`ldapgrouplist), `SelectedItems ));
	    }
            string new_grouplist = mergestring( new_list_grouplist, ",");
            integer new_i_uid    = tointeger( new_uid );

            // check the uid -- only for adding??
            if (new_i_uid != uid)
            {
		if( UsersCache::UIDExists( new_i_uid ) )
		{
		    // error popup
		    Report::Error(_("The user ID entered is reserved.
Select another user ID.
"));
		    UI::SetFocus(`id(`uid));
		    continue;
		}
		if (!UsersCache::CheckUIDInterval (new_i_uid, user_type))
		{
		    integer minimum = Users::min_uid[user_type]:0;
		    if (user_type == "system")
			minimum = 0;

		    // change the type to system?
		    if (user_type == "local" &&
			UsersCache::CheckUIDInterval (new_i_uid, "system"))
		    {
			if (! Popup::YesNo( sformat(
_("The selected user ID is a system ID,
because the ID is smaller than %1.
Really change type of user to 'system'?"), Users::max_uid["system"]:499 + 1 )))
			{
			    UI::SetFocus(`id(`uid));
			    continue;
			}
			new_type = "system";
		    }
		    // change the type to local?
		    else if (user_type == "system" &&
			     UsersCache::CheckUIDInterval (new_i_uid, "local"))
		    {
			if (! Popup::YesNo( sformat(
_("The selected user ID is a local ID,
because the ID is greater than %1.
Really change type of user to 'local'?"), Users::max_uid["system"]:499 )))
			{
			    UI::SetFocus(`id(`uid));
			    continue;
			}
			new_type = "local";
		    }
		    // uid not in valid interval
		    else
		    {
			Report::Error(sformat(
_("The selected user ID is not allowed.
Select a valid integer between %1 and %2.
"),  minimum, Users::max_uid[user_type]:60000 ));
			UI::SetFocus(`id(`uid));
			continue;
		    }
		}
            } // end of uid checks

            if ( defaultgroup != new_defaultgroup )
            {
                gid = lookup (Users::GetGroupByName(new_defaultgroup,user_type),
		    "gid", gid);
            }

            // check the homedirectory
            if ( home != new_home || what == "add_user" )
            {
                if( (nil != findfirstnotof( new_home, Users::valid_home_chars))
                 || (0 != findfirstof( new_home, "/"))
                 || (issubstring( new_home, "/.")))
                {
                    // error popup
                    Report::Error(_("The home directory may only contain the following characters:
a..zA..Z0..9_-/
Try again.
"));
                    UI::SetFocus(`id(`home));
                    continue;
                }

                if (!Mode::config &&
		    (user_type != "ldap" || Users::ldap_file_server))
                {
                    string home_path =
                        substring (new_home,0, findlastof(new_home,"/"));
                    home_path = Users::IsDirWritable (home_path);
                    if (home_path != "")
                    {
                        // error popup (%1 is part of home path, e.g. "/home")
                        Report::Error(sformat (_("The directory %1 is not writable.
Choose another path for the home directory.
"), home_path));
                        UI::SetFocus(`id(`home));
                        continue;
                    }
                }

            y2debug("newhome: %1,  org_home: %2", new_home, org_home);

            if ( (what == "edit_user" && ( new_home != org_home ))
                 || what == "add_user" )
            {
                create_home = Users::user_in_work["create_home"]:true;
                if( UsersCache::HomeExists(new_home) )
                {
                    // error popup
                    Report::Error(_("The home directory is used from another user.
Please try again."));
                    UI::SetFocus(`id(`home));
                    continue;
                }
                // do not check local directories in autoinst config
                if (SCR::Read(.target.size, new_home ) != -1 && !Mode::config &&
		    (user_type != "ldap" || Users::ldap_file_server))
                {
                    integer dir_uid = lookup (SCR::Read(.target.stat, new_home), "uid", -1);
                    string question =
// yes-no popup
_("The home directory selected already exists.
Use it and change its owner?");
                    if (new_i_uid == dir_uid) // chown is not needed (#25200)
                        question =
// yes-no popup
_("The home directory selected already exists
and is owned by the currently edited user.
Use this directory?
");
		    // maybe it is home of some user marked to delete...
		    else if (contains (Users::removed_homes, home))
			question = sformat(
// yes-no popup
_("The home directory selected (%1)
already exists as a former home directory of
a user currently marked for deletion.
Use this directory?
"), home);

                    if (! Popup::YesNo(question))
                    {
                        UI::SetFocus(`id(`home));
                        continue;
                    }
                    create_home = false;
                }
            }
            }

            if ((!contains(Users::all_shells, new_shell))&&(new_shell != shell))
            {
                // Yes-No popup
                if (! Popup::YesNo (_("If you select a nonexistent shell, the user
may be unable to log in. Continue?
")))
                    continue;
            }

            // check the grouplist
            if( new_grouplist != grouplist  )
            {
            if( nil == findfirstnotof( new_grouplist,
                    Users::valid_grouplist_chars ) )
            {
                foreach (`group, list_grouplist, ``{
                    // is not in new grouplist:
                    if (!contains (new_list_grouplist, group))
                    {
			term item = `item (`id (group), group, true);
                        // but is in initial one:
                        if (contains (additional_groups, item) ||
			    contains (additional_ldap_groups, item))
                            // -> so is removed:
                            removed = add (removed, group);
                        else
                            // -> probably NIS group (= no change):
                            new_list_grouplist = add (new_list_grouplist,group);
                    }
                });
		new_grouplist = mergestring( new_list_grouplist, ",");
            }
            else // this will never be reached... ?
            {
                // error popup
                Report::Error(_("The groupfield may contain only
letters and digits.
Please try again."));
                UI::SetFocus(`id(`grouplist));
                continue;
            }

            } // grouplist changed

            // update Users::user_in_work
            Users::user_in_work ["home"]  = new_home;
            Users::user_in_work ["shell"] = new_shell;
            Users::user_in_work ["gid"]   = gid;
            Users::user_in_work ["uid"]   = new_i_uid;
            Users::user_in_work ["grouplist"] = new_grouplist;
            Users::user_in_work ["groupname"] = new_defaultgroup;
            Users::user_in_work ["org_groupname"] = defaultgroup;
            Users::user_in_work ["removed_grouplist"] = removed;

	    if (user_type != new_type)
	    {
		Users::user_in_work ["org_type"]   = user_type;
		Users::user_in_work ["type"]	   = new_type;
	    }

            if ( create_home != Users::user_in_work ["create_home"]:true )
                Users::user_in_work ["create_home"] = create_home;
            if ( new_i_uid != uid )
	    {
                Users::user_in_work ["org_uid"] = uid;
	    }
            if ( addit_data != "" )
                Users::user_in_work ["addit_data"] = addit_data;
            if ( new_home != org_home && org_home == "")
                Users::user_in_work ["org_home"] = home;

        } // ret = `next
    } until (ret == `next || ret == `abort  || ret == `back || ret == `cancel);

    if ( ret == `next )
    {
	ret = string_to_symbol (what);
	if (user_type == "ldap")
	    ret = `ldap;
    }
    return ret;
}


/**
 * Details of adding/cloning/editing dialog
 * @return symbol for wizard sequencer
 */
global define symbol EditUserPasswordDialog() ``{

    map user		= Users::user_in_work;
    string username	= user["username"]:"";
    map shadow		= user["shadow"]:$[
	// workaround for LDAP users
	"last_change":	user["shadowLastChange"]:"0",
	"expire":	user["shadowExpire"]:"0",
	"inact":	user["shadowInactive"]:"",
	"max":		user["shadowMax"]:"",
	"min":		user["shadowMin"]:"",
	"warn":		user["shadowWarning"]:""
    ];
    list shadow_symbols = ["warn", "max", "min"];

    string last_change = shadow["last_change"]:"0";
    string expires = shadow["expire"]:"0";
    if (expires == "") expires = "0";

    string work = shadow["inact"]:"";
    if( work == "" ) work = sformat("%1", Users::pass_inact_days);
    integer inact = tointeger( work );

    work = shadow["max"]:"";
    if ( work == "" ) work = sformat("%1", Users::pass_max_days );
    integer max = tointeger( work );

    work = shadow["min"]:"";
    if( work == "") work = sformat("%1", Users::pass_min_days );;
    integer min = tointeger( work );

    work = shadow["warn"]:"";
    if( work == "") work = sformat("%1", Users::pass_warn_age );
    integer warn = tointeger( work );

    if (last_change != "0")
    {
        map out = SCR::Execute (.target.bash_output, sformat ("date --date='1970-01-01 00:00:01 %1 days' +\"%%x\"", last_change));
        // label
        last_change = UsersCache::Uncoding (out["stdout"]:_("unknown"));
    }
    else
    {
        // label
        last_change = _("never");
    }
    string exp_date = "";
    if (expires != "0" && expires != "-1" )
    {
        exp_date = lookup (SCR::Execute (.target.bash_output, (sformat ("date --date='1970-01-01 00:00:01 %1 days' ", expires) + "+\"%Y-%m-%d\"")), "stdout", "");
        // remove \n from the end
        exp_date = deletechars (exp_date, "\n");
    }
    term contents = `HBox (
        `HSpacing (3),
            `VBox (
                `VStretch(),
                // label
                `Top(`Left (`Label (sformat (_("Date of the last password change: %1"), last_change )))),
                `VSpacing (1),
                `HSquash(`VBox(
                    // intfield
                    `IntField (`id ("warn"), _("Days before Password Expiration to Issue &Warning"), -1, 99999, warn),
                    `VSpacing (0.5),
                    // intfield
                    `IntField (`id ("inact"), _("Days &after Password Expires with Usable Login"), -1, 99999, inact),
                    `VSpacing (0.5),
                    // intfield
                    `IntField (`id ("max"), _("Ma&ximum number of days for the same password"), -1, 99999, max),
                    `VSpacing (0.5),
                    // intfield
                    `IntField (`id ("min"), _("&Minimum number of days for the same password"), -1, 99999, min),
                    `VSpacing (0.5),
                    // textentry
                    `TextEntry (`id ("expire"), _("&Expiration date"), exp_date)
                )),
                `VStretch ()),
            `HSpacing (3));

    // dialog caption
    Wizard::SetContentsButtons(_("Password settings for user ") + username +":",
                    contents,
                    EditUserPasswordDialogHelp(),
                    Label::BackButton(),
                    Label::NextButton());

    // user input
    any ret = `next;
    repeat
    {
        ret = UI::UserInput();
        if( ret == `next )
        {
            string exp = UI::QueryWidget (`id ("expire"), `Value);
            if (exp != "" &&
                !regexpmatch (exp,"[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
            {
            // Trannslators: Don't reorder the letters YYYY-MM-DD!!!
            // The date must stay in this format
            Popup::Message(_("Expiration date must be in format YYYY-MM-DD"));
            UI::SetFocus(`id("expire"));
            continue;
            }
            // update the values in shadow map
            foreach(`shadowsymbol, shadow_symbols, ``{
                if ( shadow[shadowsymbol]:-2 != UI::QueryWidget (
                        `id(shadowsymbol), `Value))
                    shadow[shadowsymbol] = sformat ("%1",
                        UI::QueryWidget(`id(shadowsymbol), `Value));
            });
            integer new_inact = UI::QueryWidget(`id("inact"), `Value);
            if (new_inact != inact)
            {
                shadow["inact"] = sformat("%1", new_inact);
            }
            string new_exp_date = UI::QueryWidget(`id("expire"), `Value);
            if (new_exp_date != exp_date)
            {
                if (new_exp_date == "")
                    shadow["expire"] = user["type"]:"local"=="ldap"? "": "0";
                else
                {
                    map out = SCR::Execute(.target.bash_output,
                        sformat("date --date='%1 UTC' ", new_exp_date) + "+%s");
		    string seconds_s = deletechars(out["stdout"]:"0","\n");
                    if (seconds_s != "")
                    {
			integer days = (tointeger(seconds_s))/ (60*60*24);
                        shadow["expire"] = sformat("%1", days);
                    }
                }
            }
        }
    } until (ret == `next || ret == `abort  || ret == `back || ret == `cancel);

    if ( ret == `next )
    {
	ret = string_to_symbol (Users::user_in_work["what"]:"back");

	if (user["type"]:"local" != "ldap")
	    Users::user_in_work["shadow"] = eval (shadow);
	else
	{
	    foreach (`key, `value, shadow, ``{
		Users::user_in_work [Users::ldap_attrs_conversion[key]:key] =
		    value;
	    });
	}
    }

    return ret;
}

/**
 * Dialog for additional settings for LDAP users
 * @return symbol for wizard sequencer
 */
global define symbol LDAPSettingsDialog(string what) ``{

    import "LdapPopup";

    // use local copy here
    map object	= eval (
	(what == "user")? Users::user_in_work: Users::group_in_work);
    list items			= [];
    list used_attributes	= [];
    list new_attributes		= [];
    boolean modified		= false;

    // list of attributes that are edited elsewhere
    // They don't have to really be set for current user! (e.g.shadow*)
    // (There are LDAP names for shadow* in this list -> they cannot be in
    // ldap2yast, because no "translation to yast names" is needed.)
    list already_edited_keys = (what == "user") ?
	[ "username", "uid", "home", "givenName", "sn",
	"password", "objectClass", "shell", "gid",
	"shadowLastChange", "shadowWarning", "shadowInactive", "shadowExpire",
	"shadowMin", "shadowMax", "shadowFlag" ] :
	// and now for groups
	[ "groupname", "gid", "password", "objectClass", "userlist",
	"uniqueMember" ];

    list internal_keys = (what == "user") ? Users::user_internal_keys :
	Users::group_internal_keys;

    list required_attrs = (what == "user") ?
	Users::ldap_user_template["requiredAttribute"]:[] :
	Users::ldap_group_template["requiredAttribute"]:[];

    // generate table items from already existing values
    foreach (`attr, `val, object, ``{
	if (contains (internal_keys, attr))
	    return;
	if (contains (already_edited_keys, attr))
	    return;
	if (is (val, map))
	    return;
	list value = [];
	if (is (val, string))
	{
	    value = [ val ];
	    object [attr] = value;
	}
	else value = val;
	used_attributes = add (used_attributes, attr);
	items = add (items, `item (`id(attr), attr, mergestring(value,",")));
    });

    // generate table items with empty values (not set for this user/group yet)
    // we need to read available attributes from Ldap
    map ldap2yast = (what == "user") ? Users::ldap2yast_user_attrs :
	Users::ldap2yast_group_attrs;
    foreach (`class, object["objectClass"]:[], ``{
	foreach (`at, Ldap::GetAllAttributes (class), ``{
	    // remove already used (uid, uidNumber, homeDirectory etc.)
	    if (!haskey (object, ldap2yast [at]:at) &&
		!contains (already_edited_keys, ldap2yast [at]:at))
	    {
		object = add (object, at, []);
		new_attributes = add (new_attributes, at);
		items = add (items, `item (`id(at), at, ""));
	    }
	});
    });

    term contents = `HBox(`HSpacing (1.5), `VBox(
        `VSpacing(0.5),
	`Table(`id(`table), `opt(`notify), `header(
	    // table header 1/2
	    _("Attribute"),
	    // table header 2/2
	    _("Value")),
	    items),
        `HBox (
            `PushButton(`id(`edit), `opt(`key_F4), Label::EditButton()),
	    `HStretch()
	),
	`VSpacing (0.5)
	),
	`HSpacing (1.5));

    // dialog caption
    Wizard::SetContentsButtons(_("Additional LDAP Settings"),
        contents,
        LDAPSettingsDialogHelp(what),
        Label::BackButton(), Label::NextButton());

    any ret = `next;
    UI::SetFocus (`id(`table));
    repeat
    {
        ret = UI::UserInput();
	if ( ret == `edit || ret == `table)
	{
	    string attr		= UI::QueryWidget (`id(`table), `CurrentItem);
	    list value		= object [attr]:[];
	    value = LdapPopup::EditAttribute (attr, value, [],
		Ldap::SingleValued (attr), []);
	    if (value == object [attr]:[])
		continue;
	    UI::ChangeWidget (`id(`table),`Item(attr,1),mergestring(value,","));
	    object [attr] = value;
	}
        if ( ret == `next )
        {
	    // check for required attributes
	    boolean again = false;
	    foreach (`req, required_attrs, ``{
		if (again) return;
		if ((contains (used_attributes, req) ||
		     contains (new_attributes, req)) &&
		    object [req]:[] == [])
		    // question, %1 is attribute name
		    if (!Popup::YesNo (sformat (
_("The attribute '%1' is required for this object according
to its LDAP configuration, but it is currently empty.
Are you sure?"), req)))
			again = true;
	    });
	    if (again) continue;
	    // update global variables
	    foreach (`k,`v, object, ``{
		if (v != [] || contains (used_attributes, k))
		    if (what == "user")
			Users::user_in_work [k] = v;
		    else if (Users::group_in_work[k]:"" != v)
		    {
			modified = true;
			Users::group_in_work [k] = v;
		    }
	    });
         }
    } until (contains ([`next, `abort, `back, `cancel], ret));

    if ( ret == `next )
    {
	if ( what == "user")
	    // go to the forst user edit/add dialog
	    ret = string_to_symbol (object["what"]:"back");
	else if (modified && object["what"]:"" != "add_group")
	{
	    // if there was no change in previous dialog,
	    // "edit_group" was not set
	    Users::group_in_work ["what"] = "edit_group";
	}
    }
    return ret;
}


/**
 * Details of adding/editing group dialog
 * @param what "add_group" or "edit_group"
 * @return symbol for wizard sequencer
 */
global define symbol EditGroupDialog(string what ) ``{

//y2internal ("----------- group: %1", Users::group_in_work);

    map dialog_labels = $[
        "add_group": $[
            // dialog caption:
            "local":     _("Add a New Local Group"),
            // dialog caption:
            "system":     _("Add a New System Group"),
            // dialog caption:
            "ldap":     _("Add a New LDAP Group")
        ],
        "edit_group": $[
            // dialog caption:
            "local":     _("Edit an Existing Local Group"),
            // dialog caption:
            "system":     _("Edit an Existing System Group"),
            // dialog caption:
            "ldap":     _("Edit an Existing LDAP Group")
        ]
    ];

    if (what == "add_group")
    {
	if (!Users::Add("group", Users::group_in_work))
	    return `nosave;
    }

    // load group saved in group_in_work
    map group			= eval (Users::group_in_work);
    string  groupname		= group["groupname"]:"";
    string  password		= group["password"]:"x";
    integer gid			= group["gid"]:nil;
    // these are the users with this group as a default:
    string  more_users		= group["more_users"]:"";
    // these are users from /etc/group:
    string  userlist		= group["userlist"]:"";
    string  group_type		= group["type"]:nil;
    string  new_type		= group_type;
    list list_userlist		= splitstring (userlist, ",");
    list list_more_users	= splitstring (more_users, ",");
    list uniqueMember		= group["uniqueMember"]:[];
    string dn			= group["dn"]:"";
    string new_dn		= dn;
    map additional_users	= $[];
    list removed = [];

    // now, the additional userlist should be builded:
    if (group_type == "ldap")
    {
	additional_users = Users::BuildAdditionalLDAP (uniqueMember,more_users);
	list_userlist = uniqueMember;
    }
    else
        additional_users = Users::BuildAdditional (userlist, more_users);

    boolean more = false;
    if (size(list_more_users) > 0)
        more = true;

    // make dialog
    term contents = `HBox(
        `Left(`VBox(
            `VSpacing(1),
            // textentry label
            `Top(`TextEntry( `id(`groupname), _("&Group Name"), groupname )),
            // textentry label
            `Top(`TextEntry( `id(`gid), _("Group &ID (gid)"),
                sformat("%1", gid) )),
            `VSpacing(1),
            // User account information, first version of group password
            `Bottom(`Password(`id(`pw1), _("&Enter a Password"), "")),
            // User account information, second version of group password,
            // please use newline if it is longer than 48 characters
            `Bottom(`Password(`id(`pw2), _("Reenter the &Password"),  "")),
            `VSpacing(1)
        )),
        `HSpacing(2),
//        `HStretch(),
        `VBox(
            `VSpacing(1),
            // selection box label
            `MultiSelectionBox( `id(`userlist), _("&Members of this Group"),
                additional_users [`ulist]:[]),
            more ? `VSpacing(1) : `VSpacing (0),
            // selection box label
            more ? `MultiSelectionBox( `id(`more_users), "",
                additional_users [`more]:[]) : `VSpacing (0),
            `VSpacing(1)
        ));

    Wizard::SetContentsButtons(
        dialog_labels [ what, group_type ]:"",
	contents,
        EditGroupDialogHelp(more),
        Label::BackButton(), Label::NextButton());

    if( what == "add_group" ) UI::SetFocus(`id(`groupname));

    if( what == "edit_group" )
    {
        if( !contains (["x","*","!"], password) )
        {
	    UI::ChangeWidget(`id(`pw1), `Value, Users::default_pw);
	    UI::ChangeWidget(`id(`pw2), `Value, Users::default_pw);
        }
    }

    if (more)
    {
	// the group of users having this group as default - cannot be edited!
        UI::ChangeWidget (`id(`more_users), `Enabled, false);
    }

    any ret = `next;
    repeat
    {
        ret = UI::UserInput();

        if ( ret == `next  )
        {
            string pw1            = UI::QueryWidget(`id(`pw1),       `Value);
            string pw2            = UI::QueryWidget(`id(`pw2),       `Value);
            string new_groupname  = UI::QueryWidget(`id(`groupname), `Value);
            string new_gid        = UI::QueryWidget(`id(`gid),       `Value);
            list(string) new_users = UI::QueryWidget(`id(`userlist), `SelectedItems );

	    // --------------------------------- groupname checks
            if ( new_groupname == "" )
            {
                // groupname is empty (no group input).
                // error popup
                Report::Error(_("You didn't enter a groupname.
Please try again.
")) ;
                UI::SetFocus(`id(`groupname));
                continue;
            }

            if ( size( new_groupname ) < UsersCache::min_length_groupname ||
		 size( new_groupname ) > UsersCache::max_length_groupname )
            {
                // The groupname has incorrect length
                // error popup, %1 is minimum, %2 is maximum
                Report::Error(sformat(_("The group name must be between %1 and %2 characters in length.
Try again.
"),UsersCache::min_length_groupname, UsersCache::max_length_groupname)) ;
                UI::SetFocus(`id(`groupname)) ;
                continue;
            }

            string firstchar = substring( new_groupname, 0, 1);
            if ( ( ! (firstchar >= "A" && firstchar <= "z") ||
               nil != findfirstnotof(new_groupname, Users::valid_group_chars)))
            {
                // The groupname contains restricted characters
                // error popup
                Report::Error(_("The group name may contain only
letters, digits, \"-\", \".\", and \"_\"
and must begin with a letter.
Try again.
")) ;
                UI::SetFocus(`id(`groupname)) ;
                continue;
            }

            if ( (((what == "edit_group" ) && ( new_groupname != groupname ))
                 || ( what == "add_group" ))
                 &&  UsersCache::GroupnameExists(new_groupname))
            {
                // The entered groupname conflicts with some existing groupname
                // error popup
                Popup::Error(_("There is a conflict between the entered
group name and an existing group name.
Try another one.
"));
                UI::SetFocus(`id(`groupname)) ;
                continue;
            }

	    // --------------------------------- password checks
            if ( pw1 != pw2 )
            {
                // The two group password information do not match
                // error popup
                Report::Error(_("The first and the second version
of the password are different.
Please try again.")) ;

		clear_password_fields();
                continue;
            }

            // Use the old password (if any) if no passwords were entered.
            // only check pw1 here, its identical with pw2 as checked before
            if ( pw1 != "" && pw1 != Users::default_pw )
            {

	    integer min_length_pas = Users::pass_length [group_type,"min"]:5;
            if (size (pw1) < min_length_pas)
            {
                // The group password has incorrect length
                // error popup. %1 and %2 numbers (minimum and maximum)
                Report::Error(sformat(_("The password must have between %1 and %2 characters.\nPlease try again."),
                    Users::pass_length [group_type,"max"]:8, min_length_pas));
		clear_password_fields();
                continue;
            }
            if ( pw1 != "" )
            {
                if ( nil != findfirstnotof( pw1, Users::valid_password_chars ) )
                {
                    // The password contains incorrect characters
                    // error popup
                    Report::Error(_("The password may only contain the following characters:
0..9, a..z, A..Z, and any of \"#* ,.;:._-+!$%&/|\?{[()]}\".
Please try again."));
		    clear_password_fields();
		    continue;
                }
            }
	    if (!CheckPasswordMaxLength (pw1, group_type))
	    {
		clear_password_fields ();
		continue;
	    }

            password = Users::CryptPassword (pw1, group_type);
            }

            // need for update /etc/gshadow (! is for empty password)
            if( pw1 == "" ) password = "!";

	    // --------------------------------- gid checks
            integer new_i_gid = tointeger(new_gid);
            if( new_i_gid != gid)
            {
                if ( UsersCache::GIDExists(new_i_gid) && ( gid != new_i_gid ) )
                {
                    // error popup
                    Report::Error(_("The group ID entered is reserved.
Select a another group ID.
"));
                    UI::SetFocus(`id(`gid));
                    continue;
                }
		if (!UsersCache::CheckGIDInterval (new_i_gid, group_type))
		{
		    // change the type to system?
		    if (group_type == "local" &&
			UsersCache::CheckGIDInterval (new_i_gid, "system"))
		    {
			if (! Popup::YesNo( sformat(
_("The selected group ID is a system ID,
because the ID is smaller than %1.
Really change group type to 'system'?"), Users::max_gid["system"]:499 + 1 )))
			{
			    UI::SetFocus(`id(`gid));
			    continue;
			}
			new_type = "system";
		    }
		    // change the type to local?
		    else if (group_type == "system" &&
			     UsersCache::CheckGIDInterval (new_i_gid, "local"))
		    {
			if (! Popup::YesNo( sformat(
_("The selected group ID is a local ID,
because the ID is greater than %1.
Really change group type to 'local'?"), Users::max_gid["system"]:499 )))
			{
			    UI::SetFocus(`id(`gid));
			    continue;
			}
			new_type = "local";
		    }
		    // gid not in valid interval
		    else
		    {
			integer minimum = Users::min_gid [group_type]:0;
			if (group_type == "system")
			    minimum = 0;

			Report::Error(sformat(
_("The selected group ID is not allowed.
Select a valid integer between %1 and %2.
"),  minimum, Users::max_gid[group_type]:60000 ));
			UI::SetFocus(`id(`gid));
			continue;
		    }
		}
            }

	    // --------------------------------- update userlist
            string new_userlist   = "";
            foreach (`user, list_userlist, ``{
                if (!contains (new_users, user))
                    removed = add (removed, user);
            });
	    if (group_type != "ldap")
	    {
		new_userlist = mergestring(new_users, "," );
		new_users = [];
	    }

	    // --------------------------------- now everything should be OK
	    if (group_type == "ldap")
		ret = `ldap;
            // if something has changed
            if ( ((what == "edit_group") && (
                                (gid != new_i_gid)  ||
                                (groupname != new_groupname ) ||
                                (!contains (["x", "*", "!"], password)) ||
                                (userlist  != new_userlist  ) ||
				(uniqueMember != new_users)))
                 || (what == "add_group" ))
            {
                // save the current group changes in group_in_work
                group["what"]		= what;
                group["groupname"]	= new_groupname;
                group["password"]	= password;
                group["more_users"]	= more_users;
                group["gid"]		= new_i_gid;
                group["type"]		= group_type;
		if (group_type == "ldap")
		    group["uniqueMember"]= new_users;
		else
		    group["userlist"]	= new_userlist;

		if (group_type != new_type)
		{
		    group ["org_type"]   = group_type;
		    group ["type"]	 = new_type;
		}
                if (what == "edit_group")
                {
                    if (gid != new_i_gid)
                        group ["org_gid"] = gid;
                    if (removed != [])
                        group["removed_userlist"] = removed;
                    if (groupname != new_groupname)
		    {
                        group["org_groupname"] = groupname;
			if (group_type == "ldap")
			{
			    if (!haskey (group, "org_dn"))
				group ["org_dn"] = dn;
			    group ["dn"] = Users::CreateGroupDN (group);
			}
		    }
		}
		else
		{
		    if (group_type == "ldap")
		    {
			group = Users::SubstituteValues ("group", group);
			new_dn		= Users::CreateGroupDN (group);
			group ["dn"]	= new_dn;
			group ["org_dn"]= new_dn;
		    }
		}
		Users::group_in_work = eval (group);
            }
            else
            {
                // nothing has changed - no save
		if (group_type != "ldap")
		    ret = `back;
            }
        }
    } until ( contains ([`next, `abort, `back, `ldap], ret));

    return ret;
}

/**
 * The dialogs for setting defaults from /etc/defaults/useradd
 * @return symbol for wizard sequencer
 */
global define symbol DefaultsDialog() ``{

    string home		= Users::GetDefaultHome (true, "local");
    string shell	= Users::GetDefaultShell ("local");
    string skel		= Users::default_skel;
    integer gid		= Users::default_gid;
    string expire	= Users::default_expire;
    string inactive	= Users::default_inactive;
    string grouplist	= Users::GetDefaultGrouplist ("local");
    integer inact	= tointeger(inactive);
    string defaultgroup	= Users::GetDefaultGroupname ("local");
    string exp_date = "";
    list available_groups = [];
    list available_shells = Users::all_shells_items;

    foreach ( `grouptype, `groupset, UsersCache::groupnamelists, ``{
	// only local sets
	if (!contains (["local", "system"], grouptype))
	    return;
        foreach ( `group, groupset, ``{
            if ( group == defaultgroup )
                available_groups = add (available_groups,
                    `item( `id(group), group, true));
            else
                available_groups = add (available_groups,
                    `item( `id(group), group));
        });
    });

    if (expire != "0" && expire != "")
    {
        exp_date = lookup (SCR::Execute (.target.bash_output, (sformat (
		"date --date='1970-01-01 00:00:01 %1 days' ", expire) +
		"+\"%Y-%m-%d\"")), "stdout", "");
        // remove \n from the end
        exp_date = deletechars (exp_date, "\n");
    }

    term contents = `HBox(`HSpacing(1.5),
        `VBox(
            `VSpacing(0.2),
		// Frame label
	        `Frame(_("Set the Default Values for Adding New User"),`HBox(
		`HSpacing(2), `VBox(
                `ComboBox(`id(`defaultgroup), `opt(`hstretch),
                    // combobox label
                    _("D&efault Group"), available_groups ),
                // text entry
                `TextEntry( `id(`grouplist), _("Se&condary Groups"), grouplist),
                // text entry
                `ComboBox(`id(`shell), `opt(`hstretch, `editable),
                    // combobox label
                    _("Default &Login Shell"), available_shells),
		`HBox(
		    // text entry
		    `TextEntry(`id(`home), _("Path Prefix for &Home Directory"),
			home),
		    `VBox(
			`Label (""),
			`PushButton(`id(`brow_h),`opt(`key_F6), _("Bro&wse..."))
		    )
		),
		`HBox(
		    // text entry
		    `TextEntry(`id(`skel), _("&Skeleton for Home Directory"),
			skel),
		    `VBox(
			`Label (""),
			`PushButton(`id(`brow_s),`opt(`key_F7), _("Bro&wse..."))
		    )
		),
                // text entry
                `TextEntry( `id(`exp), _("Default E&xpiration Date"), exp_date),
                // intfield
                `IntField (`id (`inact), _("Days &after Password Expiration Login Is Usable"), -1, 99999, inact),
		`VSpacing (0.2)
                ),
              `HSpacing(2))),
            `VSpacing(0.2)),
        `HSpacing(1.5));

    Wizard::SetContentsButtons(
            // dialog label
            _("New User Defaults"),
            contents,
            DefaultsDialogHelp(),
            Label::BackButton(),
            Label::NextButton());

    UI::ChangeWidget(`id(`shell), `Value, shell);

    boolean modified = false;

    string new_home  = home;
    string new_shell = shell;
    string new_skel = skel;
    string new_defgroup = defaultgroup;
    string new_exp_date = exp_date;
    integer new_inact = inact;
    string new_expire = expire;
    string new_grouplist = grouplist;

    while (true)
    {
        modified = false;
        ret = UI::UserInput();
        if (ret == `back || ret == `abort || ret == `cancel) break;
	if ( ret == `brow_h)
	{
	    string dir = UI::QueryWidget(`id(`home),  `Value);
	    if (SCR::Read(.target.size, dir ) == -1)
		dir = home;
	    dir = UI::AskForExistingDirectory (dir, "");
	    if (dir != nil)
	    {
		UI::ChangeWidget (`id(`home), `Value, dir);
	    }
	}
	if ( ret == `brow_s)
	{
	    string dir = UI::QueryWidget(`id(`skel),  `Value);
	    if (SCR::Read(.target.size, dir ) == -1)
		dir = skel;
	    dir = UI::AskForExistingDirectory (dir, "");
	    if (dir != nil)
	    {
		UI::ChangeWidget (`id(`skel), `Value, dir);
	    }
	}
        if (ret == `next)
        {
            new_home  = UI::QueryWidget(`id(`home),  `Value);
            new_shell = UI::QueryWidget(`id(`shell), `Value);
            new_skel = UI::QueryWidget(`id(`skel), `Value);
            new_inact = UI::QueryWidget(`id(`inact), `Value);
            new_defgroup = UI::QueryWidget(`id(`defaultgroup),`Value);
            new_exp_date = UI::QueryWidget(`id(`exp),`Value);
	    new_grouplist = UI::QueryWidget(`id(`grouplist),`Value);
	    // check new grouplist...
	    if (new_grouplist != grouplist)
	    {
		list l_grouplist = [];
		list dont_exist = [];
		foreach (`g, splitstring (new_grouplist, ","), ``{
		    // check for group existence
		    if (!contains (UsersCache::groupnamelists["local"]:[],g) &&
			!contains (UsersCache::groupnamelists["system"]:[], g))
			dont_exist = union (dont_exist, [g]);
		    // filter out the duplicates
		    else l_grouplist = union (l_grouplist, [g]);
		});
		if (dont_exist != [])
		{
		    // error message
		    Report::Error(sformat (_("These groups do not exist in your system:
%1
Try again.
"), mergestring (dont_exist, ",")));

		    UI::SetFocus (`id(`grouplist));
		    continue;
		}
		new_grouplist = mergestring (l_grouplist, ",");
		UI::ChangeWidget (`id(`grouplist), `Value, new_grouplist);
		modified = true;
	    }
            // check the home existence
            if (home != new_home)
            {
                if (SCR::Read(.target.dir, new_home ) == nil)
                {
		    if (SCR::Read(.target.size, new_home ) != -1)
		    {
			// error message
			Report::Error(_("The entered path prefix for home is not a directory.
Try again.
"));
			UI::SetFocus(`id(`home));
			continue;
		    }
		    else
		    {
			// yes/no popup
			if (Popup::YesNo (_("The selected directory does not exist.
Create it now?
")))
			{
			    if (! SCR::Execute (.target.mkdir, new_home))
			    {
		                // error popup message
				Report::Error (sformat (_("Unable to create directory '%1'."), new_home));
				UI::SetFocus (`id(`home));
				continue;
			    }
			}
			else
			{
			    UI::SetFocus (`id(`home));
			    continue;
			}
		    }
                }
                modified = true;
            }
            // check the shell existence
            if (shell != new_shell)
            {
                if (! contains (Users::all_shells, new_shell))
                {
                    // Yes-No popup
                    if (! Popup::YesNo (_("If you select a nonexistent shell, the user
may be unable to log in. Continue?
")))
                        continue;
                }
                modified = true;
            }
            // check the skeleton existence
            if (skel != new_skel)
            {
                if (SCR::Read(.target.dir, new_skel ) == nil)
                {
                    Report::Error(_("The entered home directory skeleton is not a directory.
Try again.
"));
                    UI::SetFocus(`id(`skel));
                    continue;
                }
                modified = true;
            }
            // check the expire date
            if (exp_date != new_exp_date)
            {
                if (new_exp_date != "" && !regexpmatch (new_exp_date,
                    "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
                {
                    // Trannslators: Don't reorder the letters YYYY-MM-DD!!!
                    // The date must stay in this format
                    Popup::Message(_("Expiration date must be in format YYYY-MM-DD"));
                    UI::SetFocus(`id(`exp));
                    continue;
                }
                if (new_exp_date == "")
                    new_expire = "";
                else
                {
                    map out = SCR::Execute(.target.bash_output,
                        sformat("date --date='%1 UTC' ", new_exp_date) + "+%s");
                    string seconds_s = deletechars (out["stdout"]:"0", "\n");
                    if (seconds_s != "")
                    {
                        integer days = (tointeger(seconds_s))/ (60*60*24);
                        new_expire = sformat("%1", days);
                    }
                }
                modified = true;
            }
            if (defaultgroup != new_defgroup || inact != new_inact)
                modified = true;
            break;
        }
    }
    if (modified)
    {
        map new_defaults = $[
            "home": new_home,
            "shell": new_shell,
            "skel": new_skel,
            "group": sformat ("%1", lookup (
                Users::GetGroupByName (new_defgroup, "local"), "gid",gid)),
            "inactive": sformat("%1", new_inact),
            "expire": new_expire,
	    "groups": new_grouplist
        ];
        Users::SetDefaults(new_defaults, new_defgroup);
    }

    return ret;
}


/**
 * Choosing the user authentization method
 * @return symbol for sequencer
 */
global define symbol AuthentizationDialog() ``{

    /**
     * helper function to get information about authentication from
     * appropriate module
     * @param client
     * @return
     */
    define string get_module_data (string client) ``{

	string ret = "";
	Progress::off();
	if (!contains (installed, client))
	{
	    ret = Summary::NotConfigured();
	}
	else if (client == "ldap")
	{
	    import "Ldap";
	    Ldap::Read();
	    ret = Ldap::ShortSummary();
	}
	else if (client == "nis")
	{
	    import "Nis";
	    Nis::Read();
	    ret = Nis::ShortSummary();
	}
	else if (client == "nisplus")
	{
	    import "Nisplus";
	    Nisplus::Read();
	    ret = Nisplus::ShortSummary();
	}
	else if (client == "kerberos")
	{
	    import "Kerberos";
	    Kerberos::Read();
	    ret = Kerberos::ShortSummary();
	}
	else if (client == "samba")
	{
	    import "Samba";
	    Samba::Read();
	    ret = Samba::ShortSummary();
	}
	Progress::on();
	return ret;
    }

    /**
     * Reloads the configuration and updates the auth-widget contents
     */
    define void reload_config() ``{

        string summary = "";
	foreach (`client, available, ``{
	    summary = Summary::AddHeader (summary, sformat (
		"<font color=\"#8BC460\"><a href=\"%1\">%2</a></font>",
		client,
		deletechars (to_string [client]:"", "&")));
	    summary = Summary::AddLine (summary, get_module_data (client));
	});
        UI::ChangeWidget(`id(`summary), `Value, summary);
    }

    list configurable = [ "nis", "nisplus", "ldap", "kerberos", "samba" ];

    list available = [];
    list installed = [];
    list mb = [];

    map to_string = $[
        // just the name (do not translate)
        "nis"   : _("&NIS"),
        // just the name (do not translate)
        "nisplus"   : _("N&IS+"),
        // just the name (do not translate)
        "ldap"  : _("&LDAP"),
        // just the name (do not translate)
        "kerberos"  : _("&Kerberos"),
        // just the name (do not translate)
        "samba"  : _("&Samba"),
	 ];

    // name of module to call
    map call_module = $[
	"samba": "samba-client",
    ];

    foreach (`client, configurable, ``{
	string package = sformat ("yast2-%1-client", client);
        if (Require::IsPackageAvailable (package))
	{
	    available = add (available, client);
	    mb = add (mb, `item(`id(client), to_string[client]:""));
	}
        if (Require::AreAllPackagesInstalled ([package]))
	    installed = add (installed, client);
    });

    term contents = `HBox(
        `HSpacing(4),
        `VBox(
            `VSpacing(0.5),
            `RichText (`id(`summary), ""),
            `VSpacing( 0.5 ),
            // button label
	    `MenuButton(`opt(`key_F4), _("&Configure..."), mb),
            `VSpacing (0.5)
        ),
        `HSpacing(4)
    );

    // dialog title
    string title = _("Authentication and User Data Sources");

    Wizard::SetContentsButtons (title, contents, AuthentizationDialogHelp(),
        Label::BackButton(), Label::OKButton());

    reload_config();

    any button = nil;
    boolean changed = false;
    do
    {
        button = UI::UserInput();
        if (contains (configurable, button))
        {
	    if (!contains (installed, button))
	    {
		string package = sformat ("yast2-%1-client", button);
		if ( Require::RequireAndConflictTargetButtons ( [package], [],
		    // popup label (%1 is package to install)
		    sformat (_("Package %1 is not installed.
Install it now?
"), package), Label::OKButton(), Label::CancelButton()))
		{
		    installed = add (installed, button);
		}
		else continue;
	    }
            if (Call::Function (call_module[button]:button, []) == `next)
	    {
		changed = true;
		reload_config ();
		UI::ChangeWidget (`id(`back), `Enabled, false);
	    }
        }
    } while ( !contains ([`next, `abort, `back, `cancel], button) );

    if (changed)
    {
	boolean was_nis_available = Users::is_nis_available;
	Users::ReadSourcesSettings();
	// enabling NIS could add + lines!
	// TODO what about some general solution?
	if (was_nis_available != Users::is_nis_available)
	{
	    if (Users::is_nis_available) // nis enabled now
	    {
		Users::plus_passwd	= "+::::::";
		Users::plus_group	= "+:::";
		Users::plus_shadow	= "+";
	    }
	}
	// LDAP settings could be modified...??? (re_read_ldap)
	// FIXME Ldap::file_server wasn't updated
	// autologin could have been changed
        Users::BuildMenuButtonItems();
    }
    return button;
}


/**
 * Just giving paramaters for commiting user
 * @return symbol for wizard sequencer
 */
global define symbol UserSave() ``{

    Users::Commit("user", true);
    // adding only one user during install
    if (Mode::cont && Users::start_dialog == "user_add" )
        return `save;
    else
    return `next;
}

/**
 * Just giving paramaters for commiting group
 * @return symbol for wizard sequencer
 */
global define symbol GroupSave() ``{

    Users::Commit("group", true);

    return `next;
}

/**
 * Helper function, converting some strings to symbols
 *  (for later use by wizard sequencer)
 * @param to_convert original string
 * @return converted symbol
 */
global define symbol string_to_symbol (string to_convert) ``{

    map to_symbol = $[
	"back":		`back,
	"add_user":	`add_user,
	"edit_user":	`edit_user
    ];
    return to_symbol [to_convert]:`back;
}

/**
 * Helper function for user/group dialog:
 * invalidate any old password and clear password inputfields
 */
global define void clear_password_fields () ``{

    password = "";
    UI::ChangeWidget(`id(`pw1), `Value, "");
    UI::ChangeWidget(`id(`pw2), `Value, "");
    UI::SetFocus(`id(`pw1));
}


/* EOF */
}
