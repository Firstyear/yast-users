/**
 * File:	include/users/dialogs.ycp
 * Package:	Configuration of users and groups
 * Summary:	Dialogs definitions
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "users";

import "Wizard";
import "Mode";
import "Report";

import "Users";
import "UsersCache";
import "Summary"; // only for AuthDialog? TODO

include "ui/common_messages.ycp";
include "ui/common_popups.ycp";
include "ui/file_popups.ycp";

include "users/helps.ycp";
include "users/routines.ycp";


/**
 * Function that adds or edits a user.
 * @param what "add_user" or "edit_user"
 * @return symbol for wizard sequencer
 */
global define symbol EditUserDialog(string what) ``{

y2internal ("----------- user: %1", Users::user_in_work);
    /**
     * Invalidate any old password
     * Clear password inputfields
     */
    define void clear_password_fields () ``{

	password = "";
        UI::ChangeWidget(`id(`pw1), `Value, "");
	UI::ChangeWidget(`id(`pw2), `Value, "");
        UI::SetFocus(`id(`pw1));
    }

    map org_user = Users::user_in_work["org_user"]:eval(Users::user_in_work);

    if (Users::start_dialog == "user_add" && Mode::cont && Users::use_next_time)
    {
        Users::user_in_work = Users::saved_user;
        Users::use_next_time = false;
    }
    boolean create_home = Users::user_in_work["create_home"]:true;
    string  username    = Users::user_in_work["username"]:"";
    string  fullname    = Users::user_in_work["fullname"]:"";
    string tmp_fullname = fullname; // for login proposing
    integer gid         = Users::user_in_work["gid"]:Users::default_gid;
    string  groupname   = Users::user_in_work["groupname"]:nil;

    if (groupname == nil || groupname == "")
    {
        if (what == "add_user")
            groupname = Users::default_groupname;
        else
        {
            // it wasn't generated outside
            groupname = lookup (Users::GetGroupFromAll(gid), "groupname", "");
            Users::user_in_work["groupname"] = groupname;
        }
    }
    string  org_groupname   = Users::user_in_work["org_groupname"]:groupname;
    string  home        = Users::user_in_work["home"]:Users::default_home;
    string  org_home    = Users::user_in_work["org_home"]:home;
    string  shell       = Users::user_in_work["shell"]:Users::default_shell;
    string  password    = Users::user_in_work["password"]:"";
    string  grouplist   = Users::user_in_work["grouplist"]:"empty";
    string  user_type   = Users::user_in_work["type"]:nil;
    list removed_grouplist = Users::user_in_work["removed_grouplist"]:[];
    string org_username = Users::user_in_work["org_username"]:username;
    string addit_data	= Users::user_in_work["addit_data"]:"";
    string modified_flag = Users::user_in_work["modified"]:"no";

    if (user_type == nil)
    {
        user_type = "local";
        // nis user cannot be added from client
        if (what == "add_user")
	{
	    integer i = size (Users::current_users) - 1;
	    while (i >= 0 )
	    {
		if (Users::current_users[i]:"local" != "nis")
		    user_type = Users::current_users[i]:"local";
		i = i - 1;
	    }
	}
        UsersCache::user_type = user_type;
    }
    string  mail	= Users::user_in_work["mail"]:"";
    string givenName = "";
    string sn = "";
    if (user_type == "ldap")
    {
	givenName = Users::user_in_work["givenName"]:
	    SplitFullName(`givenName, fullname);
	sn = Users::user_in_work["sn"]:SplitFullName(`sn, fullname);
    }

    map dialog_labels = $[
        "add_user": $[
            // dialog caption:
            "local":    _("Add a New Local User"),
            // dialog caption:
            "system":	_("Add a New System User"),
            // dialog caption:
            "ldap":     _("Add a New LDAP User")
        ],
        "edit_user": $[
            // dialog caption:
            "local":    _("Edit an Existing Local User"),
            // dialog caption:
            "system":	_("Edit an Existing System User"),
            // dialog caption:
            "ldap":	_("Edit an Existing LDAP User"),
            // dialog caption:
            "nis":	_("Edit an Existing NIS User")
        ]
    ];

    // grouplist wasnt fully generated while reading nis & ldap users
    if ( (user_type == "nis" || user_type == "ldap") &&
         !Users::user_in_work["grouplist_read"]:false)
    {
        // this set is necessary for "nis" users
        Users::user_in_work["grouplist_read"] = true;
        grouplist = Users::FindGroupsBelongUser (username);
        Users::user_in_work["grouplist"] = grouplist;
    }

    if ( grouplist == "empty")
    {
        if (what == "add_user")
            grouplist = Users::GetDefaultGrouplist(user_type);
        else
            grouplist = "";
    }

    integer uid = Users::user_in_work["uid"]:nil;
    if ( uid ==  nil )
    {
        uid = UsersCache::NextFreeUid(); // this uses user_type
        if ( uid == nil )
        {
            // error label
            Report::Error(_("There is no free UID for this type of user."));
            return `nosave;
        }
    }
    integer org_uid = Users::user_in_work["org_uid"]:uid;

    map shadow = Users::user_in_work["shadow"]:$[];
    if (shadow == $[] && what == "add_user" )
    {
        shadow = Users::GetDefaultShadow();//default_shadow??
    }
    else if (shadow == $[])
    {
        shadow = eval (Users::shadow[user_type, username]:$[]);
    }
    Users::user_in_work["what"] = what; // is it necessary here ??

    term name_entries =
        // text entry
	`TextEntry (`id(`fullname), _("Full User Name"), fullname);
    if (user_type == "ldap")
    {
	name_entries = `VBox(
            // text entry
            `TextEntry(`id(`givenName), _("F&irst Name"), givenName),
            // text entry
            `TextEntry(`id(`sn),  _("&Last Name"),  sn ));
    }

    term detailsmorebox =
        `HBox(
            // push button
            `PushButton(`id(`details),`opt(`key_F2), _("&Details...")),
            `VStretch(),
            `PushButton(`id(`passwordsettings),`opt(`key_F7),
		// push button label
                _("&Password settings")),
            `VStretch());

    if( Mode::cont && Users::start_dialog == "user_add" )
    {
        detailsmorebox = add(detailsmorebox,
            `PushButton(`id(`additional), `opt(`key_F3),
                // push button
                _("Additional Users/&Groups")));
        detailsmorebox = `VBox (
            // checkbox label
            `CheckBox (`id (`root_mail),_("Receive S&ystem Mail"),
                Users::root_mail != ""),
            `VStretch (),
            detailsmorebox);
    }

    boolean do_not_edit = (user_type == "nis");

    term contents =
        `HSquash(`VBox(
            `VStretch(),
            `VBox(
                // label text
                do_not_edit ? `Label(_("Only additional group memberships 
can be changed for non-local users.
")) : `VSpacing (0),
                do_not_edit ? `VSpacing (1) : `VSpacing (0),
		name_entries
            ),
            `VSquash(
            `HBox(
                // input field for login name
                `Bottom(`TextEntry(`id(`username), _("&User Login"), username)),
                (what != "add_user") ? `HSpacing (0)
                    // push button to generate login from first and last name
                    : `Bottom(`PushButton(`id(`propose), _("&Suggestion")))
            )),
            // first version of user password
            `Password(`id(`pw1), _("&Enter a Password"), ""),
            // second version of user password, retyped to avoid typos
            // please use newline if it is longer than 48 characters
            `Password(`id(`pw2), _("Re-enter the Password for &Verification"), ""),
            `VStretch(),
            detailsmorebox ));

    Wizard::SetContentsButtons(
            dialog_labels [ what, user_type ]:"",
            contents,
            EditUserDialogHelp(Mode::cont && Users::start_dialog == "user_add",
		user_type, what),
            UI::BackButtonLabel(),
            UI::NextButtonLabel());

    // TODO edit values for NIS users
    if (do_not_edit)
    {
        UI::ChangeWidget (`id(`fullname), `Enabled, false);
        UI::ChangeWidget (`id(`username), `Enabled, false);
        UI::ChangeWidget (`id(`pw1), `Enabled, false);
        UI::ChangeWidget (`id(`pw2), `Enabled, false);
        UI::ChangeWidget (`id(`passwordsettings), `Enabled, false);
    }
    //TODO: kerberos passwords editing: Users::kerberos_auth != "required")

    UI::ChangeWidget (`id (`username), `ValidChars, Users::valid_logname_chars);

    if ( what == "add_user" )
    {
        if ( !Mode::cont )
            Wizard::ReplaceNextButton (`PushButton (`id (`next),
                // change of button label
                `opt(`key_F10, `default), _("&Create")));
        else
            Wizard::ReplaceNextButton (`PushButton (`id (`next), `opt(`default),
                UI::NextButtonLabel()));
    }

    if ( what == "add_user" )
    {
	if (user_type == "ldap")
	    UI::SetFocus(`id(`givenName));
	else
	    UI::SetFocus(`id(`fullname));
    }

    if (user_type == "system")
    {
        UI::ChangeWidget(`id(`propose), `Enabled, false );
    }

    if( password != "")
    {
        UI::ChangeWidget(`id(`pw1), `Value, Users::default_pw);
        UI::ChangeWidget(`id(`pw2), `Value, Users::default_pw);
    }

    any ret = `next;
    repeat
    {
        ret = UI::UserInput();

        username	= UI::QueryWidget(`id(`username), `Value);

	if (! contains ([`back, `cancel, `abort], ret))
	{
	    if (user_type == "ldap")
	    {
		// Form the fullname for LDAP user
		// sn (surname) and cn (fullname) are required attributes,
		// they cannot be empty
		givenName	= UI::QueryWidget(`id(`givenName), `Value);
		sn		= UI::QueryWidget(`id(`sn ), `Value);

		if (sn == "")
		{
		    if (givenName == "")
		    {
			sn = username;
		    }
		    else
		    {
			sn = givenName;
			givenName = "";
		    }
		}
		fullname = givenName + ((givenName != "") ? " " : "") + sn;
		UI::ChangeWidget(`id(`givenName), `Value, givenName);
		UI::ChangeWidget(`id(`sn), `Value, sn);
	    }
	    else
	    {
		fullname	= UI::QueryWidget(`id(`fullname), `Value);
		if (findfirstof(fullname, Users::invalid_gecos_chars) != nil)
		{
		    // error message
		    Report::Error(_("
The full user name cannot contain
: or , characters.
Try again.
"));
		    UI::SetFocus(`id(`fullname));
		    continue;
		}
	    }
	}

        // generate a login name from first and last name
        if (ret == `propose) // hide propose for editing  && what == "add_user")
        {
	    if (tmp_fullname != fullname)
	    {
		UsersCache::proposal_count = -1;
		tmp_fullname = fullname;
	    }
	    username = UsersCache::ProposeUsername( fullname );
            UI::ChangeWidget(`id(`username), `Value, username);
	    UI::SetFocus (`id(`username));
        }

        // only in continue mode
        if( ret == `additional )
        {
            if (UI::QueryWidget(`id(`pw1), `Value) == "" &&
                UI::QueryWidget(`id(`pw2),`Value) == ""  &&
                UI::QueryWidget(`id(`username), `Value) == "" &&
                UI::QueryWidget(`id(`fullname), `Value) == "")
            ret = `nosave;
        }

        boolean details = ( ret == `details || ret == `passwordsettings );

        if (( ret == `next || ret == `additional || details ) && !do_not_edit)
        {
            // check the settings
            string pw1   = UI::QueryWidget(`id(`pw1), `Value);
            string pw2   = UI::QueryWidget(`id(`pw2), `Value);

            if ( username == "")
            {
            // The user login field is empty, this is allowed if the
            // system is part of a network with (e.g.) NIS user management.
            if (Mode::cont && ret == `next && Users::start_dialog == "user_add")
            {
                // yes-no popup headline
                if (  UI::YesNoHeadlinePopup(_("Empty user login"),
                // yes-no popup contents
                 _("Leaving the user name empty only makes sense
in a network environment with an authentication server.

Are you sure?
")))
                {
                    ret = `nextmodule;
                    break;
                }
                UI::SetFocus(`id(`username));
                continue;
            }
            else
            {
                // The username is empty (no user input).
                // error popup
                Report::Error(_("You didn't enter a username.
Please try again.
"));
                UI::SetFocus(`id(`username));
                continue;
            }
            }

	    // FIXME: where this constants come from??
            if  (  ( size( username ) < 2 || size( username ) > 32 ) )
            {

                // The username don't have a size between 2 and 32 characters.
                // error popup
                Report::Error(_("The username must be between 2 and 32 characters in length.
Please try again.
"));
                UI::SetFocus(`id(`username));
                continue;
            }

            string firstchar = substring(username, 0, 1);

            if ((! ((firstchar >= "A" && firstchar <= "z" )
                    || firstchar == "_")
                || nil!=findfirstnotof(username, Users::valid_logname_chars)))
            {

                // The login name contains invalid characters
                // error popup
                Report::Error(_("The user login may contain only
letters, digits, \"-\", \".\" and \"_\"
and must begin with a letter or \"_\".
Please try again.
"));
                UI::SetFocus(`id(`username));
                continue;
            }

            // check login against passwd contents
            if ( (username != lookup( Users::user_in_work , "username",""))
                 && UsersCache::UsernameExists(username))
            {

                // Entered login name conflicts with some existing login
                // error popup
                Report::Error(_("There is a conflict between the entered
login name and some existing username.

Please try another one.
"));
                UI::SetFocus(`id(`username));
                continue;
            }

            // build default home dir
            if ( home == Users::default_home || home == "")
            {
                home = home + username;
            }

            if (!details)
            {
            if ( home != org_home )
            {
                // new popup for existing dir
                if (UsersCache::HomeExists(home))
                {
                    // error popup
                    Report::Error(_("The default home directory is used from another user.
Please press button Details and edit home directory."));
                    home = Users::default_home;
                    continue;
                }
                // do not check in autoinstal config and for ldap client
                if ((user_type != "ldap" || Users::ldap_file_server) &&
                    !Mode::config && create_home &&
                    SCR::Read(.target.size, home ) != -1)
                {
                    integer dir_uid = lookup (SCR::Read(.target.stat, home), "uid", -1);
                    string question = sformat(
// yes-no popup, %1 is home directory
_("The home directory selected (%1) already exists.
Use it and change its owner?"), home);
                    if (uid == dir_uid) // chown is not needed (#25200)
                        question = sformat(
// yes-no popup
_("The home directory selected (%1)
already exists and is owned by currently edited user.
Use this directory?"), home);

		    // maybe it is home of some user marked to delete...
		    else if (contains (Users::removed_homes, home))
			question = sformat(
// yes-no popup
_("The home directory selected (%1)
already exists as a former home directory of
some user currently marked for deletion.
Use this directory?"), home);

                    if (! UI::YesNoPopup(question))
                    {
                        home = Users::default_home;
                        continue;
                    }
                    create_home = false;
                }
                // do not check in autoinstal config and for ldap client
                if ((user_type != "ldap" || Users::ldap_file_server) &&
                    !Mode::config && what == "add_user")
                {
                    string home_path =
                        substring (home,0, findlastof(home,"/"));
                    home_path = Users::IsDirWritable (home_path);
                    if (home_path != "")
                    {
                        // error popup (%1 is part of home path, e.g. "/home")
                        Report::Error(sformat (_("The directory %1 is not writable.
Press Details and edit the home directory."), home_path));
                        home = Users::default_home;
                        continue;
                    }
                }
            }
            }

            if ( pw1 != pw2 )
            {
                // The two user password information do not match
                // error popup
                Report::Error(_("The first and the second version
of the password are different.
Please try again."));
		clear_password_fields ();
                continue;
            }

            // Use the old password (if any) if no passwords were entered.
            // only check pw1 here, its identical with pw2 as checked before
            if ( pw1 !=  Users::default_pw )
            {
            if ( pw1 == "" && !details )
            {
		// No password was entered
                // error popup
                Report::Error(_("You didn't enter a password.\nPlease try again."));
		clear_password_fields ();
                continue;
            }
            if (size (pw1) < Users::min_length_pas && pw1 != "")
            {
                // Password is too short
                // error popup. %1 and %2 are numbers (typical 5 and 8)
                Report::Error(sformat(_("The password must have between %1 and %2 characters.\nPlease try again."),
                    Users::min_length_pas, Users::max_length_pas));
		clear_password_fields ();
                continue;
            }
            if ( size(pw1) >=  Users::min_length_pas )
            {
                if ( nil != findfirstnotof( pw1, Users::valid_password_chars ))
                {

                // The user password contains restricted characters
                // error popup
                Report::Error(_("The password may only contain the following characters:
0..9, a..z, A..Z, and any of \"#* ,.;:._-+!$%&/|\?{[()]}\".
Please try again."));
		clear_password_fields ();
                continue;
                }
            }
            /* password check against cracklib FIXME */
            if (Users::use_cracklib)
            {
                string out = CrackPassword (username, pw1);
                if (out != "" && out != "OK")
                {
                    // error message of cracklib
                    Report::Error(out);
		    clear_password_fields ();
                    continue;
                }
            }
            if (Users::obscure_checks && !details)
            {
                string obs = CheckObscurity (username, pw1);
                if (obs != "OK" && !UI::YesNoPopup (obs))
                {
		    clear_password_fields ();
                    continue;
                }
            }
	    if (!CheckPasswordMaxLength (pw1))
	    {
		clear_password_fields ();
		continue;
	    }
            if (pw1 != "x" && pw1 != "")
            {
                // to use with autoinst.
                if (Users::user_in_work["encrypted"]:true)
                    password = Users::CryptPassword (pw1);
                }
                else password = pw1;

                shadow["password"] = password;
                shadow["last_change"] = Users::LastChangeIsNow();
            }

            // use Users::Add/Edit?
            Users::user_in_work = $[
                     "what"        :  what,
                     "fullname"    :  fullname,
                     "gid"         :  gid,
                     "groupname"   :  groupname,
                     "home"        :  home,
                     "password"    :  password,
                     "shell"       :  shell,
                     "uid"         :  uid,
                     "username"    :  username,
                     "grouplist"   :  grouplist,
                     "shadow"      :  shadow,
                     "create_home" :  create_home,
                     "type"        :  user_type,
                     "grouplist_read": true // usable for "nis" or "ldap"
            ];

            // something has changed -> new entry
            if ( what != "add_user" )
            {
                if (home !=org_home)
                    Users::user_in_work["org_home"] = org_home;
                if ( org_username != username && org_username !="")
                    Users::user_in_work["org_username"] = org_username;
                if ( org_groupname != groupname)
                    Users::user_in_work["org_groupname"] = org_groupname;
                if ( org_uid != uid )
                {
                    Users::user_in_work["org_uid"] = org_uid;
                    UsersCache::focusline_user = uid;
                }
                if ( removed_grouplist != [] )
                    Users::user_in_work["removed_grouplist"]=removed_grouplist;
                // save original map (for check if something has realy changed)
                if ( ! do_not_edit )
                    Users::user_in_work ["org_user"] = org_user;
            }
            if (modified_flag != "no")
                Users::user_in_work ["modified"] = modified_flag;
	    if ( user_type == "ldap" )
	    {
		Users::user_in_work ["givenName"] = givenName;
		Users::user_in_work ["sn"] = sn;
                Users::user_in_work ["mail"] = mail;
	    }
            else if ( addit_data != "")
                Users::user_in_work ["addit_data"] = addit_data;

            y2debug ("edited user: %1", Users::user_in_work );
        }

    } until ( ret == `next || details || ret == `abort  || ret == `back ||
              ret == `cancel || ret == `additional || ret == `nosave );

    // only in inst-sys
    // create more users and groups
    // leave sequencer and start it again with new Users::start_dialog
    if (Users::start_dialog == "user_add" && Mode::cont)
    {
        Users::root_mail = UI::QueryWidget (`id (`root_mail), `Value)
            ? username : "";
    }
    if( ret == `additional ||  ret == `nosave )
    {
        // suring installation the first user is stored
        // (to show it when clicking `back from Summary dialog)
        Users::saved_user = Users::user_in_work;
    }
    return ret;
}


/**
 * Details of adding/cloning/editing dialog
 * @return symbol for wizard sequencer
 */
global define symbol EditUserDetailsDialog( ) ``{

    //load the current usersettings from Users::user_in_work
    string what           = Users::user_in_work["what"]:"no";
    string username       = Users::user_in_work["username"]:"";
    string fullname       = Users::user_in_work["fullname"]:"";
    string home           = Users::user_in_work["home"]:"";
    string org_home       = Users::user_in_work["org_home"]:"";
    boolean create_home   = Users::user_in_work["create_home"]:true;
    string shell          = Users::user_in_work["shell"]:"";
    string grouplist      = Users::user_in_work["grouplist"]:"";
    integer uid           = Users::user_in_work["uid"]:Users::max_uid;
    integer gid           = Users::user_in_work["gid"]:Users::max_gid;
    string user_type      = Users::user_in_work["type"]:"local";
    string defaultgroup   = Users::user_in_work["groupname"]:"";
    // for LDAP only:
    string mail          = Users::user_in_work["mail"]:"";

    // additional parts of GECOS (shown by `finger <username>`) (passwd only)
    string addit_data	= Users::user_in_work["addit_data"]:"";

    list available_shells = Users::all_shells_items;
    list available_groups = [];
    list additional_groups = [];
    list additional_ldap_groups = [];
    list list_grouplist = splitstring (grouplist, ",");
    list removed = [];

    /* fill the list available_groups and set the user default group true */
    foreach ( `grouptype, `groupset, UsersCache::groupnamelists, ``{
        if (grouptype == "local" || grouptype == "system" ||
            (grouptype == "ldap" && user_type == "ldap"))
	{
          foreach ( `group, groupset, ``{

            if (user_type == "ldap")
            {
                if (grouptype == "ldap")
                {
                    if ( group == defaultgroup )
                        available_groups = add (available_groups,
                            `item( `id(group), group, true));
                    else
                        available_groups = add (available_groups,
                            `item( `id(group), group));
                    if ( contains (list_grouplist, group))
                        additional_ldap_groups = add (additional_ldap_groups,
                            `item( `id(group), group, true ));
                    else
                        additional_ldap_groups = add (additional_ldap_groups,
                            `item( `id(group), group, false));
                }
                else
                {
		    // if there is a group with same name, use only that
		    // with type "ldap"
		    if ( contains (UsersCache::groupnamelists["ldap"]:[],group))
			return;
                    if ( contains (list_grouplist, group))
                        additional_groups = add (additional_groups,
                            `item( `id(group), group, true ));
                    else
                        additional_groups = add (additional_groups,
                            `item( `id(group), group, false));
                }
            }
            else
            {
                if ( group == defaultgroup )
                    available_groups = add (available_groups,
                        `item( `id(group), group, true));
                else
                    available_groups = add (available_groups,
                        `item( `id(group), group));
                if ( contains (list_grouplist, group))
                    additional_groups = add (additional_groups,
                        `item( `id(group), group, true ));
                else
                    additional_groups = add (additional_groups,
                        `item( `id(group), group, false));
            }
          });
	}
    });

    boolean do_not_edit = (user_type == "nis");
    term edit_defaultgroup = `ComboBox(`id(`defaultgroup), `opt(`hstretch),
        // combobox label
        _("Default &group"), available_groups );
    term edit_shell = `ComboBox(`id(`shell), `opt(`hstretch, `editable),
        // combobox label
        _("Login &shell"), available_shells );

    term additional_data = `Empty();
    if (user_type == "ldap")
        additional_data =
            // textentry label
            `Top(`TextEntry( `id(`mail), _("&E-Mail Address"), mail ));
    else if (user_type == "nis")
        additional_data = `Empty();
    else
        additional_data =
            // textentry label
            `Top(`TextEntry(`id(`addd), _("&Additional User Information:"),
                addit_data));

    term browse = `Empty();
    if (!do_not_edit && (user_type != "ldap" || Users::ldap_file_server))
        browse =
            // button label
	    `VBox(
	    `Label (""),
            `PushButton( `id(`browse), `opt(`key_F6), _("Bro&wse...")));

    term contents =
        `HBox(
          `HSpacing(1),
          `VBox(
           `VSpacing(0.5),
           // label
           do_not_edit ? `Label(_("Only additional group memberships 
can be changed for non-local users.")) : `VSpacing (0),
           do_not_edit ? `VSpacing (1) : `VSpacing (0),
           // frame label, user name follows
           `VSpacing(0.5),
           `Frame(sformat(_("Detailed Profile for User \"%1\""),
		username),
           `HBox(
		`HSpacing (0.5),
                `VBox(
		    `VSpacing (0.5),
                    // textentry label
                    `Top(`TextEntry( `id(`uid), _("User &ID (uid)"),
                        sformat("%1",uid ))),
                    `Top(`HBox (
			// textentry label
			`TextEntry( `id(`home), _("&Home Directory"), home ),
			browse)),
                    additional_data,
                    `Top(edit_shell),
                    `Top(edit_defaultgroup),
                    `VStretch()
                ),
                `HSpacing(2),
		`VBox(
		    `VSpacing (0.5),
		    `Top(`MultiSelectionBox( `id(`grouplist),
			// selection box label
			_("Additional Group &Membership"), additional_groups)),
		    (user_type == "ldap")
		    ? `MultiSelectionBox( `id(`ldapgrouplist),
			// selection box label
			_("Additional &LDAP Groups"), additional_ldap_groups)
		    : `Empty()
		    ),
		`HSpacing (0.5)
            )),
            `VSpacing(0.5)
           ),
           `HSpacing(1)
        );

    // dialog caption
    Wizard::SetContentsButtons(_("Add/Edit User Properties - Details"),
                    contents,
                    EditUserDetailsDialogHelp(user_type),
                    UI::BackButtonLabel(),
                    UI::NextButtonLabel());

    if (do_not_edit)
    {
        UI::ChangeWidget (`id (`uid), `Enabled, false);
        UI::ChangeWidget (`id (`home), `Enabled, false);
        UI::ChangeWidget (`id (`shell), `Enabled, false);
        UI::ChangeWidget (`id (`defaultgroup), `Enabled, false);
    }
    if (user_type == "ldap")
    {
        if (what == "edit_user" && !Users::ldap_file_server)
            UI::ChangeWidget (`id (`home), `Enabled, false);
    }

    UI::ChangeWidget(`id(`shell),    `Value,   shell );

    // user input
    any ret = `next;
    repeat
    {
        ret = UI::UserInput();
	if ( ret == `browse)
	{
	    string dir = home;
	    if (SCR::Read(.target.size, home ) == -1)
		dir = Users::default_home;
	    dir = PopupDir (dir);
	    if (dir != "")
	    {
		if ( (findlastof( dir, "/") + 1) == size(dir) )
		    dir = substring (dir, 0, size(dir)-1);
		UI::ChangeWidget (`id(`home), `Value, dir);
	    }
	    // TODO: add directory checks here...
	}
        if ( ret == `next )
        {
            string  new_home  = UI::QueryWidget(`id(`home),  `Value);
	    if ( (findlastof( new_home, "/") + 1) == size(new_home) )
		new_home = substring (new_home, 0, size(new_home)-1);
            string  new_shell = UI::QueryWidget(`id(`shell), `Value);
            string  new_uid   = UI::QueryWidget(`id(`uid),   `Value);
            string  new_defaultgroup = UI::QueryWidget(`id(`defaultgroup),`Value);
            if (do_not_edit) // check for Ena/Dis
            {
                new_home = home;
                new_shell = shell;
                new_uid = sformat("%1", uid);
                new_defaultgroup = defaultgroup;
            }
            if (user_type == "ldap")
            {
                if (what == "edit_user" && !Users::ldap_file_server)
                    new_home = home;
                mail =  UI::QueryWidget(`id(`mail),   `Value);
                // email should be at least a@b.cc
                if (mail != "" &&
                    ((size (mail) < 6) ||
                     (findfirstof ("@", mail) < 0) ||
                     (findfirstof (".", mail) < 0)))
                    {
                        // warning message
                        UI::ErrorPopup (_("Enter a valid e-mail address"));
                        UI::SetFocus(`id(`mail));
                        continue;
                    }
            }
	    // additional data in GECOS field
            if (user_type == "local" || user_type == "system")
            {
                addit_data  = UI::QueryWidget(`id(`addd),  `Value);
                if (findfirstof(addit_data, ":") != nil)
                {
                    // error message
                    Report::Error(_("The \"Additional User Information\" entry cannot 
contain a colon (:).  Try again.
"));
                    UI::SetFocus(`id(`addd));
                    continue;
                }
                list add_l = splitstring (addit_data, ",");
                if (size (add_l) > 3 )
                {
                    // error message
                    Report::Error(_("The \"Additional User Information\" entry can consist
of up to three sections separated by commas.
Remove the surplus.
"));
                    UI::SetFocus(`id(`addd));
                    continue;
                }
            }

            list new_list_grouplist = UI::QueryWidget(`id(`grouplist),
                `SelectedItems );
	    if (user_type == "ldap")
	    {
		new_list_grouplist = merge (new_list_grouplist,
		    UI::QueryWidget(`id(`ldapgrouplist), `SelectedItems ));
	    }
            string new_grouplist = mergestring( new_list_grouplist, ",");
            integer new_i_uid    = tointeger( new_uid );

            // check the uid -- only for adding??
            if (new_i_uid != uid)
            {
            if( ! ( new_i_uid >= 0  && new_i_uid <= Users::max_uid )  ||
                nil != findfirstnotof( new_uid , Users::valid_id_chars ) )
            {
                // error popup, %1 is integer
                string error = sformat(_("The selected User ID is not allowed.
Select a valid integer between 0 and %1.
"),  Users::max_uid );
                Report::Error( error );
                UI::SetFocus(`id(`uid));
                continue;
            }
            if( UsersCache::UIDExists( new_i_uid ) )
            {
                // error popup
                Report::Error(_("The user ID entered is reserved.
Select a another user ID.
"));
                UI::SetFocus(`id(`uid));
                continue;
            }
            if( new_i_uid <= Users::max_system_uid && user_type == "local")
            {
                // tell the max_system_uid
                // error popup
                string error = sformat(_("The selected user ID is a system ID,
because the ID is smaller than %1. 
Really create a new system user?
"),  Users::max_system_uid );
                if( ! UI::YesNoPopup( error ))
                {
                UI::SetFocus(`id(`uid));
                continue;
                }
                // change user_type
                user_type = "system";
            }
            } // end of uid checks

            if ( defaultgroup != new_defaultgroup )
            {
                gid = lookup (Users::GetGroupByName (new_defaultgroup, user_type), "gid", gid);
                // TODO change groupname?
            }

            // check the homedirectory
            if ( home != new_home || what == "add_user" )
            {
                if( (nil != findfirstnotof( new_home, Users::valid_home_chars))
                 || (0 != findfirstof( new_home, "/"))
                 || (issubstring( new_home, "/.")))
                {
                    // error popup
                    Report::Error(_("The home directory may only contain the following characters:
a..zA..Z0..9_-/
Try again.
"));
                    UI::SetFocus(`id(`home));
                    continue;
                }

                if (!Mode::config &&
		    (user_type != "ldap" || Users::ldap_file_server))
                {
                    string home_path =
                        substring (new_home,0, findlastof(new_home,"/"));
                    home_path = Users::IsDirWritable (home_path);
                    if (home_path != "")
                    {
                        // error popup (%1 is part of home path, e.g. "/home")
                        Report::Error(sformat (_("The directory %1 is not writable.
Choose another path for the home directory.
"), home_path));
                        UI::SetFocus(`id(`home));
                        continue;
                    }
                }

            y2debug("newhome: %1,  org_home: %2", new_home, org_home);

            if ( (what == "edit_user" && ( new_home != org_home ))
                 || what == "add_user" )
            {
                create_home = Users::user_in_work["create_home"]:true;
                if( UsersCache::HomeExists(new_home) )
                {
                    // error popup
                    Report::Error(_("The home directory is used from another user.
Please try again."));
                    UI::SetFocus(`id(`home));
                    continue;
                }
                // do not check local directories in autoinst config
                if (SCR::Read(.target.size, new_home ) != -1 && !Mode::config &&
		    (user_type != "ldap" || Users::ldap_file_server))
                {
                    integer dir_uid = lookup (SCR::Read(.target.stat, new_home), "uid", -1);
                    string question =
// yes-no popup
_("The home directory selected already exists.
Use it and change its owner?");
                    if (new_i_uid == dir_uid) // chown is not needed (#25200)
                        question =
// yes-no popup
_("The home directory selected already exists
and is owned by currently edited user.
Use this directory?");
		    // maybe it is home of some user marked to delete...
		    else if (contains (Users::removed_homes, home))
			question = sformat(
// yes-no popup
_("The home directory selected (%1)
already exists as a former home directory of
some user currently marked for deletion.
Use this directory?"), home);

                    if (! UI::YesNoPopup(question))
                    {
                        UI::SetFocus(`id(`home));
                        continue;
                    }
                    create_home = false;
                }
            }
            }

            if ((!contains(Users::all_shells, new_shell))&&(new_shell != shell))
            {
                // Yes-No popup
                if (! UI::YesNoPopup (_("If you select a nonexistent shell, the user
may be unable to log in. Continue?
")))
                    continue;
            }

            // check the grouplist
            if( new_grouplist != grouplist  )
            {
            if( nil == findfirstnotof( new_grouplist,
                    Users::valid_grouplist_chars ) )
            {
                foreach (`group, list_grouplist, ``{
                    // is not in new grouplist:
                    if (!contains (new_list_grouplist, group))
                    {
			term item = `item (`id (group), group, true);
                        // but is in initial one:
                        if (contains (additional_groups, item) ||
			    contains (additional_ldap_groups, item))
                            // -> so is removed:
                            removed = add (removed, group);
                        else
                            // -> probably NIS group (= no change):
                            new_list_grouplist = add (new_list_grouplist,group);
                    }
                });
		new_grouplist = mergestring( new_list_grouplist, ",");
            }
            else // this will never be reached... ?
            {
                // error popup
                Report::Error(_("The groupfield may contain only
letters and digits.
Please try again."));
                UI::SetFocus(`id(`grouplist));
                continue;
            }

            } // grouplist changed

            // update Users::user_in_work
            Users::user_in_work ["home"]  = new_home;
            Users::user_in_work ["shell"] = new_shell;
            Users::user_in_work ["gid"]   = gid;
            Users::user_in_work ["uid"]   = new_i_uid;
            Users::user_in_work ["grouplist"] = new_grouplist;
            Users::user_in_work ["groupname"] = new_defaultgroup;
            Users::user_in_work ["org_groupname"] = defaultgroup;
            Users::user_in_work ["removed_grouplist"] = removed;

            if ( create_home != Users::user_in_work ["create_home"]:true )
                Users::user_in_work ["create_home"] = create_home;
            if ( new_i_uid != uid )
                Users::user_in_work ["org_uid"] = uid;
            if ( mail != "")
                Users::user_in_work ["mail"] = mail;
            if ( addit_data != "" )
                Users::user_in_work ["addit_data"] = addit_data;
            if ( new_home != org_home && org_home == "")//TODO only after 1st change
                Users::user_in_work ["org_home"] = home;

        } // ret = `next
    } until (ret == `next || ret == `abort  || ret == `back || ret == `cancel);

    // TODO ugly!
    if ( ret == `next )
    {
	if (what == "add_user")
	    ret = `add_user;
	else
	    ret = `edit_user;
    }
    y2warning ("ret : %1", ret);
    return ret;
}


/**
 * Details of adding/cloning/editing dialog
 * @return symbol for wizard sequencer
 */
global define symbol EditUserPasswordDialog() ``{

    string username  = Users::user_in_work["username"]:"";
    map shadow       = Users::user_in_work["shadow"]:$[];
    list auto_shadow_symbols = ["warn", "max", "min"];

    string last_changed = shadow["last_change"]:"0";
    string last_change = "";
    string expires = shadow["expire"]:"0";
    if (expires == "") expires = "0";

    string work = shadow["inact"]:"";
    if( work == "" ) work = sformat("%1", Users::pass_inact_days);
    integer inact = tointeger( work );

    work = shadow["max"]:"";
    if ( work == "" ) work = sformat("%1", Users::pass_max_days );
    integer max = tointeger( work );

    work = shadow["min"]:"";
    if( work == "") work = sformat("%1", Users::pass_min_days );;
    integer min = tointeger( work );

    work = shadow["warn"]:"";
    if( work == "") work = sformat("%1", Users::pass_warn_age );
    integer warn = tointeger( work );

    if (last_changed != "0")
    {
        map out = SCR::Execute (.target.bash_output, sformat ("date --date='1970-01-01 00:00:01 %1 days' +\"%%x\"", last_changed));
        // label
        last_change = UsersCache::Uncoding (out["stdout"]:_("unknown"));
    }
    else
    {
        // label
        last_change = _("never");
    }
    string exp_date = "";
    if (expires != "0" )
    {
        exp_date = lookup (SCR::Execute (.target.bash_output, (sformat ("date --date='1970-01-01 00:00:01 %1 days' ", expires) + "+\"%Y-%m-%d\"")), "stdout", "");
        // remove \n from the end
        exp_date = substring(exp_date,0,size(exp_date)-1);
    }
    term contents = `HBox (
        `HSpacing (3),
            `VBox (
                `VStretch(),
                // label
                `Top(`Left (`Label (sformat (_("Date of the last password change: %1"), last_change )))),
                `VSpacing (1),
                `HSquash(`VBox(
                    // intfield
                    `IntField (`id ("warn"), _("Issue &warning how many days before password expiration?"), -1, 99999, warn),
                    `VSpacing (0.5),
                    // intfield
                    `IntField (`id ("inact"), _("How many days &after password expires is the login usable?"), -1, 99999, inact),
                    `VSpacing (0.5),
                    // intfield
                    `IntField (`id ("max"), _("Ma&ximum number of days for the same password"), -1, 99999, max),
                    `VSpacing (0.5),
                    // intfield
                    `IntField (`id ("min"), _("&Minimum number of days for the same password"), -1, 99999, min),
                    `VSpacing (0.5),
                    // textentry
                    `TextEntry (`id ("expire"), _("&Expiration date"), exp_date)
                )),
                `VStretch ()),
            `HSpacing (3));

    // dialog caption
    Wizard::SetContentsButtons(_("Password settings for user ") + username +":",
                    contents,
                    EditUserPasswordDialogHelp(),
                    UI::BackButtonLabel(),
                    UI::NextButtonLabel());

    // user input
    any ret = `next;
    repeat
    {
        ret = UI::UserInput();
        if( ret == `next )
        {
            string exp = UI::QueryWidget (`id ("expire"), `Value);
            if (exp != "" &&
                !regexpmatch (exp,"[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
            {
            // Trannslators: Don't reorder the letters YYYY-MM-DD!!!
            // The date must stay in this format
            UI::MessagePopup(_("Expiration date must be in format YYYY-MM-DD"));
            UI::SetFocus(`id("expire"));
            continue;
            }
            // update the values in shadow map
            foreach(`autosymbol, auto_shadow_symbols, ``{
                if ( shadow[autosymbol]:-2 != UI::QueryWidget (
                        `id(autosymbol), `Value))
                    shadow[autosymbol] = sformat ("%1",
                        UI::QueryWidget(`id(autosymbol), `Value));
            });
            integer new_inact = UI::QueryWidget(`id("inact"), `Value);
            if (new_inact != inact)
            {
                shadow["inact"] = sformat("%1", new_inact);
            }
            string new_exp_date = UI::QueryWidget(`id("expire"), `Value);
            if (new_exp_date != exp_date)
            {
                if (new_exp_date == "")
                    shadow["expire"] = 0;
                else
                {
                    map out = SCR::Execute(.target.bash_output,
                        sformat("date --date='%1' ", new_exp_date) + "+%s");
                    string days_s = out["stdout"]:"0\n";
                    if (days_s != "")
                    {
                        days_s = substring(days_s, 0, size(days_s)-1);
                        // +3600 ... this looks like a bug??
                        // "date --date='1970-01-01' +%s" gives "-3600"
                        integer days = (tointeger(days_s) + 3600)/ (60*60*24);
                        shadow["expire"] = sformat("%1", days);
                    }
                }
            }
        }
    } until (ret == `next || ret == `abort  || ret == `back || ret == `cancel);

//    if ( ret == `next ) ret = Users::user_in_work["what"]:`back;
    // TODO ugly!
    if ( ret == `next )
    {
	if (Users::user_in_work["what"]:"no" == "add_user")
	    ret = `add_user;
	else
	    ret = `edit_user;
    }
    y2warning ("ret : %1", ret);

    Users::user_in_work["shadow"] = shadow;

    return ret;
}


/**
 * Details of adding/editing group dialog
 * @param what "add_group" or "edit_group"
 * @return symbol for wizard sequencer
 */
global define symbol EditGroupDialog(string what ) ``{

    map dialog_labels = $[
        "add_group": $[
            // dialog caption:
            "local":     _("Add a New Local Group"),
            // dialog caption:
            "system":     _("Add a New System Group"),
            // dialog caption:
            "ldap":     _("Add a New LDAP Group")
        ],
        "edit_group": $[
            // dialog caption:
            "local":     _("Edit an Existing Local Group"),
            // dialog caption:
            "system":     _("Edit an Existing System Group"),
            // dialog caption:
            "ldap":     _("Edit an Existing LDAP Group")
        ]
    ];

    // load group saved in group_in_work
    string  groupname   = Users::group_in_work["groupname"]:"";
    string  password    = Users::group_in_work["password"]:"x";
    integer gid         = Users::group_in_work["gid"]:nil;
    // these are the users with this group as a default:
    string  more_users  = Users::group_in_work["more_users"]:"";
    // these are users from /etc/group:
    string  userlist    = Users::group_in_work["userlist"]:"";
    string  group_type  = Users::group_in_work["type"]:nil;
    list list_userlist = splitstring (userlist, ",");
    list list_more_users = splitstring (more_users, ",");
    map additional_users = $[];
    list removed = [];

    if (group_type == nil)
    {
        group_type = "local";
        if (what == "add_group")
	{
	    integer i = size (Users::current_groups) - 1;
	    while (i >= 0 )
	    {
		if (Users::current_groups[i]:"local" != "nis")
		    group_type = Users::current_groups[i]:"local";
		i = i - 1;
	    }
	}
        UsersCache::group_type = group_type;
    }

    if (group_type == "nis")
    {
        return `nosave;
    }

    if( gid == nil )
    {
        gid = UsersCache::NextFreeGid();
        if ( gid == nil )
        {
            // error label
            Report::Error(_("There is no free GID for this type of group."));
            return `nosave;
        }
    }

    // now, the additional userlist should be builded:
    additional_users = Users::BuildAdditional (userlist, more_users);

    boolean more = false;
    if (size(list_more_users) > 0)
        more = true;

    // make dialog
    term contents = `HBox(
        `Left(`VBox(
            `VSpacing(1),
            // textentry label
            `Top(`TextEntry( `id(`groupname), _("&Group Name"), groupname )),
            // textentry label
            `Top(`TextEntry( `id(`gid), _("Group &ID (gid)"),
                sformat("%1", gid) )),
            `VSpacing(1),
            // User account information, first version of group password
            `Bottom(`Password(`id(`pw1), _("&Enter a Password"), "")),
            // User account information, second version of group password,
            // please use newline if it is longer than 48 characters
            `Bottom(`Password(`id(`pw2), _("Re-enter the &Password"),  "")),
            `VSpacing(1)
        )),
        `HSpacing(2),
        `HStretch(),
        `VBox(
            `VSpacing(1),
            // selection box label
            `MultiSelectionBox( `id(`userlist), _("&Members of this Group"),
                additional_users [`ulist]:[]),
            more ? `VSpacing(1) : `VSpacing (0),
            // selection box label
            more ? `MultiSelectionBox( `id(`more_users), "",
                additional_users [`more]:[]) : `VSpacing (0),
            `VSpacing(1)
        ));

    Wizard::SetContentsButtons(
        dialog_labels [ what, group_type ]:"",
	contents,
        EditGroupDialogHelp(more),
        UI::BackButtonLabel(), UI::NextButtonLabel());

    if( what == "add_group" && ! Mode::cont)
        Wizard::ReplaceNextButton (`PushButton (`id (`next),
            // push button
	    `opt(`key_F10, `default), _("&Create")));

    if( what == "add_group" ) UI::SetFocus(`id(`groupname));

    if( what == "edit_group" )
    {
        if( password != "x"  )
        {
	    UI::ChangeWidget(`id(`pw1), `Value, Users::default_pw);
	    UI::ChangeWidget(`id(`pw2), `Value, Users::default_pw);
        }
    }

    if (more)
    {
	// the group of users having this group as default - cannot be edited!
        UI::ChangeWidget (`id(`more_users), `Enabled, false);
    }

    /*
    if (group_type == "ldap")
    {
        UI::ChangeWidget (`id(`userlist), `Enabled, false);
        UI::ChangeWidget(`id(`pw1), `Enabled, false);
        UI::ChangeWidget(`id(`pw2), `Enabled, false);
    }
    */

    any ret = `next;
    repeat
    {
        ret = UI::UserInput();

        if ( ret == `next  )
        {
            string pw1            = UI::QueryWidget(`id(`pw1),       `Value);
            string pw2            = UI::QueryWidget(`id(`pw2),       `Value);
            string new_groupname  = UI::QueryWidget(`id(`groupname), `Value);
            string new_gid        = UI::QueryWidget(`id(`gid),       `Value);
            list(string) new_users = UI::QueryWidget(`id(`userlist), `SelectedItems );
            string new_userlist   = "";
            list l_new_userlist = [];

            if ( new_groupname == "" )
            {
                // There is a check whether the information from the UI is
                // correct and complete.  The new_groupname is empty (no group
                //  input).
                // error popup
                Report::Error(_("You didn't enter a groupname.
Please try again.
")) ;
                UI::SetFocus(`id(`groupname));
                continue;
            }

            if  ( ( size( new_groupname ) < 2 || size( new_groupname ) > 8 ) )
            {
                // There is a check whether the information from the UI is
                // correct and complete.  The groupname must have a size
                // between 2 and 8 characters.
                // error popup
                Report::Error(_("The groupname must be between 2 and 8 characters in length.
Please try again.
")) ;
                UI::SetFocus(`id(`groupname)) ;
                continue;
            }

            string firstchar = substring( new_groupname, 0, 1);
            if ( ( ! (firstchar >= "A" && firstchar <= "z") ||
               nil != findfirstnotof(new_groupname, Users::valid_group_chars)))
            {
                // TODO: change a popup according to new options (bug 24891)
                // There is a check whether the information from the UI is
                // correct and complete.  The groupname may contain only
                // certain characters and must begin with a letter.
                // error popup
                Report::Error(_("The groupname may contain only
lower case letters and digits
and must begin with a letter.
Please try again.
")) ;
                UI::SetFocus(`id(`groupname)) ;
                continue;
            }

            if ( (((what == "edit_group" ) && ( new_groupname != groupname ))
                 || ( what == "add_group" ))
                 &&  UsersCache::GroupnameExists(new_groupname))
            {
                // Tell the user that the groupname he entered conflicts with
                // predefined groupnames in the groups file.
                // error popup
                UI(`ErrorPopup(_("There is a conflict between the entered
groupname and a predefined groupname.
Please try another one.
")));
                UI::SetFocus(`id(`groupname)) ;
                continue;
            }

            if (  pw1 != pw2 )
            {
                // There is a check whether the information from the UI is
                // correct and complete.  The two group password information
                // do not match
                // error popup
                Report::Error(_("The first and the second version
of the password are different.
Please try again.")) ;
                // Invalidate any old password
                password = "x";

                // clear password inputfields in this case
                UI::ChangeWidget(`id(`pw1), `Value, "");
                UI::ChangeWidget(`id(`pw2), `Value, "");

                UI::SetFocus(`id(`pw1)) ;
                continue;
            }

            // Use the old password (if any) if no passwords were entered.
            // only check pw1 here, its identical with pw2 as checked before
            if (  ( pw1 != "") &&
              ( (pw1 != Users::default_pw) && (pw2 != Users::default_pw))  )
            {

            if (size (pw1) < Users::min_length_pas)
            {
                // There is a check whether the information from the
                // UI is correct and complete.  The group password
                // information must have a minimal size
                // error popup. %1 and %2 numbers
                Report::Error(sformat(_("The password must have between %1 and %2 characters.\nPlease try again."),
                            Users::min_length_pas,
                            Users::max_length_pas));
                password = "x";

                // clear password inputfields in this case
                UI::ChangeWidget(`id(`pw1), `Value, "");
                UI::ChangeWidget(`id(`pw2), `Value, "");
                UI::SetFocus(`id(`pw1));
                continue;
            }
            if (size(pw1) > Users::max_length_pas)
            {
                // yes-no popup. %1 number (typical 8)
                if (!UI::YesNoPopup (sformat(_("The password is longer than %1 characters. It will be truncated to %1 characters."),
                            Users::max_length_pas)))
                {
                    password = "x";
                    UI::ChangeWidget(`id(`pw1), `Value, "");
                    UI::ChangeWidget(`id(`pw2), `Value, "");
                    UI::SetFocus(`id(`pw1));
                    continue;
                }
            }

            if ( pw1 != "" )
            {
                if ( nil != findfirstnotof( pw1, Users::valid_password_chars ) )
                {
                    // There is a check whether the information from the
                    // UI is correct and complete.  The group password may
                    // contain only certain characters
                    // error popup
                    Report::Error(_("The password may only contain the following characters:
0..9, a..z, A..Z, and any of \"#* ,.;:._-+!$%&/|\?{[()]}\".
Please try again."));
                    password = "x";

                    // clear password inputfields in this case
                    UI::ChangeWidget(`id(`pw1), `Value, "");
                    UI::ChangeWidget(`id(`pw2), `Value, "");

                    UI::SetFocus(`id(`pw1));
                    continue;
                }
            }

            password = Users::CryptPassword (pw1);
            }

            // need for update /etc/gshadow --- ???
            if( pw1 == "" ) password = "*";

            // check the gid
            integer new_i_gid = tointeger(new_gid);

            if( new_i_gid != gid)
            {

                if( (!( new_i_gid >= 0  && ( new_i_gid <=  Users::max_gid ))
                     && ( new_i_gid != nil )) ||
                     nil !=  findfirstnotof( new_gid, Users::valid_id_chars ))
                {
                // error popup %1 is number
                Report::Error(sformat(_("The selected Group ID is not allowed.
Please select a valid integer between 0 and %1"),  Users::max_gid));
                UI::SetFocus(`id(`gid));
                continue;
                }


                if ( UsersCache::GIDExists(new_i_gid) && ( gid != new_i_gid ) )
                {
                    // error popup
                    Report::Error(_("The inputted Group ID is reserved.
Please select a another Group ID"));
                    UI::SetFocus(`id(`gid));
                    continue;
                }

                if ( ( what == "edit_group" ) &&
                     ( new_i_gid <= Users::max_system_gid) &&
                     ( group_type == "local" ) )
                {
                    // error popup
                    Report::Error(_("The inputted Group ID is a system ID.
Please try again."));
                    UI::SetFocus(`id(`gid));
                    continue;
                }

                if ( (what == "edit_group" ) &&
                     (new_i_gid > Users::max_system_gid ) &&
                     ( group_type == "system" ))
                {
                    // error popup
                    Report::Error(_("The inputted Group ID is not a system ID.
Please try again."));
                    UI::SetFocus(`id(`gid));
                    continue;

                }
                if (new_i_gid > Users::max_system_gid && group_type == "system")
                    group_type = "local";
                if (new_i_gid <= Users::max_system_gid && group_type == "local")
                    group_type = "system";
            }

            foreach (`user, list_userlist, ``{
                if (!contains (new_users, user))
                    removed = add (removed, user);
            });
            new_userlist = mergestring(new_users, "," );

            // if something has changed
            if ( ((what == "edit_group") && (
                                (gid != new_i_gid)  ||
                                (groupname != new_groupname ) ||
                                (password  != "x" && password != "*") ||
                                (userlist  != new_userlist  )))
                 || (what == "add_group" ))
            {
                 //save the current group in group_in_work
                Users::group_in_work = $[
                      "what"            : what,
                      "groupname"       : new_groupname,
                      "password"        : password,
                      "userlist"        : new_userlist, // save changes??
                      "more_users"      : more_users,
                      "gid"             : new_i_gid,
                      "type"            : group_type
                ];
                if (what == "edit_group")
                {
                    if (gid != new_i_gid)
                    {
                        Users::group_in_work ["org_gid"] = gid;
                        // this is a hack for table focus
                        UsersCache::focusline_group = new_i_gid;
                    }
                    if (removed != [])
                        Users::group_in_work["removed_userlist"] = removed;
                    if (groupname != new_groupname)
                        Users::group_in_work["org_groupname"] = groupname;
                }
            }
            else
            {
                // nothing has changed - no save
                ret = `back;
            }
        }
    } until ( ret == `next || ret == `abort || ret == `back || ret == `cancel );

    return ret;
}

/**
 * The dialogs for setting defaults from /etc/defaults/useradd
 * @return symbol for wizard sequencer
 */
global define symbol DefaultsDialog() ``{

// FIXME: add label, that this is about local users! (and adapt ldap ones)

    string home = Users::default_home;
    string shell = Users::default_shell;
    string skel = Users::default_skel;
    integer gid = Users::default_gid;
    string expire = Users::default_expire;
    string inactive = Users::default_inactive;
    integer inact = tointeger(inactive);
    string defaultgroup = Users::default_groupname;
    string exp_date = "";
    list available_groups = [];
    list available_shells = Users::all_shells_items;

    foreach ( `grouptype, `groupset, UsersCache::groupnamelists, ``{ // not all sets!!
        foreach ( `group, groupset, ``{
            if ( group == defaultgroup )
                available_groups = add (available_groups,
                    `item( `id(group), group, true));
            else
                available_groups = add (available_groups,
                    `item( `id(group), group));
        });
    });

    if (expire != "0" && expire != "")
    {
        exp_date = lookup (SCR::Execute (.target.bash_output, (sformat (
		"date --date='1970-01-01 00:00:01 %1 days' ", expire) +
		"+\"%Y-%m-%d\"")), "stdout", "");
        // remove \n from the end
        exp_date = substring(exp_date,0,size(exp_date)-1);
    }

    term contents = `HBox(`HSpacing(1.5),
        `VBox(
            `VSpacing(0.5),
			// Frame label
	        `Frame(_("Set the default values for adding new user"),`HBox(
              `HSpacing(2), `VBox(
                `VSpacing(0.5),
                `ComboBox(`id(`defaultgroup), `opt(`hstretch),
                    // combobox label
                    _("D&efault Group"), available_groups ),
                `VSpacing(0.5),
                // text entry
                `ComboBox(`id(`shell), `opt(`hstretch, `editable),
                    // combobox label
                    _("Default &Login Shell"), available_shells),
                `VSpacing(0.5),
                // text entry
                `TextEntry( `id(`home), _("Path Prefix for &Home Directory"),
                    home),
                `VSpacing(0.5),
                // text entry
                `TextEntry( `id(`skel), _("&Skeleton for Home Directory"),skel),
                `VSpacing(0.5),
                // text entry
                `TextEntry( `id(`exp), _("Default E&xpiration Date"), exp_date),
                `VSpacing(0.5),
                // intfield
                `IntField (`id (`inact), _("Days &after Password Expiration Login Is Usable"), -1, 99999, inact),
                `VSpacing(0.5)
                ),
              `HSpacing(2))),
            `VSpacing(0.5)),
        `HSpacing(1.5));

    Wizard::SetContentsButtons(
            // dialog label
            _("New User Defaults"),
            contents,
            DefaultsDialogHelp(),
            BackButtonLabel(),
            NextButtonLabel());

    UI::ChangeWidget(`id(`shell), `Value, shell);

    boolean modified = false;

    string new_home  = home;
    string new_shell = shell;
    string new_skel = skel;
    string new_defgroup = defaultgroup;
    string new_exp_date = exp_date;
    integer new_inact = inact;
    string new_expire = expire;

    while (true)
    {
        modified = false;
        ret = UI::UserInput();
        if (ret == `back || ret == `abort) break;
        if (ret == `next)
        {
            new_home  = UI::QueryWidget(`id(`home),  `Value);
            new_shell = UI::QueryWidget(`id(`shell), `Value);
            new_skel = UI::QueryWidget(`id(`skel), `Value);
            new_inact = UI::QueryWidget(`id(`inact), `Value);
            new_defgroup = UI::QueryWidget(`id(`defaultgroup),`Value);
            new_exp_date = UI::QueryWidget(`id(`exp),`Value);
            // check the home existence
            if (home != new_home)
            {
                if (SCR::Read(.target.dir, new_home ) == nil)
                {
                    Report::Error(_("The entered path prefix for home is not a directory.
Try again.
"));
                    UI::SetFocus(`id(`home));
                    continue;
                }
                modified = true;
            }
            // check the shell existence
            if (shell != new_shell)
            {
                if (! contains (Users::all_shells, new_shell))
                {
                    // Yes-No popup
                    if (! UI::YesNoPopup (_("If you select a nonexistent shell, the user
may be unable to log in. Continue?
")))
                        continue;
                }
                modified = true;
            }
            // check the skeleton existence
            if (skel != new_skel)
            {
                if (SCR::Read(.target.dir, new_skel ) == nil)
                {
                    Report::Error(_("The entered home directory skeleton is not a directory.
Try again.
"));
                    UI::SetFocus(`id(`skel));
                    continue;
                }
                modified = true;
            }
            // check the expire date
            if (exp_date != new_exp_date)
            {
                if (new_exp_date != "" && !regexpmatch (new_exp_date,
                    "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
                {
                    // Trannslators: Don't reorder the letters YYYY-MM-DD!!!
                    // The date must stay in this format
                    UI::MessagePopup(_("Expiration date must be in format YYYY-MM-DD"));
                    UI::SetFocus(`id(`exp));
                    continue;
                }
                if (new_exp_date == "")
                    new_expire = "";
                else
                {
                    map out = SCR::Execute(.target.bash_output,
                        sformat("date --date='%1' ", new_exp_date) + "+%s");
                    string days_s = out["stdout"]:"0\n";
                    if (days_s != "")
                    {
                        days_s = substring(days_s, 0, size(days_s)-1);
                        integer days = (tointeger(days_s) + 3600)/ (60*60*24);
                        new_expire = sformat("%1", days);
                    }
                }
                modified = true;
            }
            if (defaultgroup != new_defgroup || inact != new_inact)
                modified = true;
            break;
        }
    }
    if (modified)
    {
        map new_defaults = $[
            "home": new_home,
            "shell": new_shell,
            "skel": new_skel,
            "group": sformat ("%1", lookup (
                Users::GetGroupByName (new_defgroup, "local"), "gid",gid)),
            "inactive": sformat("%1", new_inact),
            "expire": new_expire
        ];
        Users::SetDefaults(new_defaults, new_defgroup);
    }

    Wizard::RestoreAbortButton();
    return ret;
}


// FIXME: comment
global define symbol AuthentizationDialog() ``{

    list configurable = [ "nis", "nisplus", "ldap", "kerberos" ];

    // check which yast2 modules are available TODO: to some initialization...
    list available = [];
    list installed = [];
    list mb = [];

    map to_string = $[
        // just the name (do not translate)
        "nis"   : _("&NIS"),
        // just the name (do not translate)
        "nisplus"   : _("N&IS+"),
        // just the name (do not translate)
        "ldap"  : _("&LDAP"),
        // just the name (do not translate)
        "kerberos"  : _("&Kerberos") ];

    foreach (`client, configurable, ``{
	string package = sformat ("yast2-%1-client", client);
        if (Require::IsPackageAvailable (package))
	{
	    available = add (available, client);
	    mb = add (mb, `item(`id(client), to_string[client]:""));
	}
        if (Require::AreAllPackagesInstalled ([package]))
	    installed = add (installed, client);
    });

    define string additional_info (list labels, list values, boolean enabled)``{

	// FIXME: ugly in ncurses!
	string ret = "";
	integer i = 0;
	foreach (`value, values, ``{
	    if (value == "")
		value = _("Not Configured");
	    if (ret != "")
		ret = ret + "<br>";
	    ret = sformat ("%1<b>%2</b> %3", ret, labels[i]:"", value);
	    i = i + 1;
	});
	if (!enabled)
	{
	    if (ret != "")
		ret = ret + "<br>";
	    ret = sformat(_("%1Client Not Enabled"), ret);
	}
	return ret;
    }

    /**
     * helper function to get information about authentication from
     * appropriate module
     * @param client
     * @return
     */
    define string get_module_data (string client) ``{

	string ret = "";
	Progress::off();
	if (!contains (installed, client))
	{
	    ret = Summary::NotConfigured();
	}
	else if (client == "ldap")
	{
	    import "Ldap"; //FIXME: import here?
	    Ldap::Read();
	    string server = Ldap::server;
	    string domain = Ldap::GetDomain();
	    ret = additional_info ( [
		_("Server:"),
		_("Domain:") ], [ server, domain ],  Ldap::start);
	}
	else if (client == "nis")
	{
	    import "Nis"; //FIXME: import here?
	    Nis::Read();
	    string servers = mergestring (Nis::servers,"<br>");
	    string domain = Nis::GetDomain();
	    ret = additional_info ( [
		_("Servers:"),
		_("Domain:") ], [ servers, domain ], Nis::start);
	}
	else if (client == "nisplus")
	{
	    import "Nisplus"; //FIXME: import here?
	    Nisplus::Read();
	    string server = Nisplus::server;
	    string domain = Nisplus::GetDomain();
	    ret = additional_info ( [
		_("Server:"),
		_("Domain:") ], [ server, domain ], Nisplus::start);
	}
	else if (client == "kerberos")
	{
	    import "Kerberos"; //FIXME: import here?
	    Kerberos::Read();
	    string kdc = Kerberos::kdc;
	    string domain = Kerberos::default_domain;
	    string realm = Kerberos::default_realm;
	    ret = additional_info ( [
		_("Server:"),
		_("Default Domain:"),
		_("Default Realm:") ],
		[ kdc, domain, realm ], Kerberos::use_pam_krb);
	}
	Progress::on();
	return ret;
    }

    /**
     * Realoads the configuration and updates the widget contents
     */
    define void reload_config() ``{

        string summary = "";
	foreach (`client, available, ``{
	    summary = Summary::AddHeader (summary, sformat (
		"<font color=\"#8BC460\"><a href=\"%1\">%2</a></font>",
		client,
		deletechars (to_string [client]:"", "&")));
	    summary = Summary::AddLine (summary, get_module_data (client));
	});
        UI::ChangeWidget(`id(`summary), `Value, summary);
    }

    string help_text = "";

    term contents = `HBox(
        `HSpacing(4),
        `VBox(
            `VSpacing(0.5),
            `RichText (`id(`summary), ""),
            `VSpacing( 0.5 ),
            // button label
	    `MenuButton(`opt(`key_F4), _("&Configure..."), mb),
            `VSpacing (0.5)
        ),
        `HSpacing(4)
    );

    // dialog title
    string title = _("Authentication and User Sources");

    Wizard::SetContentsButtons (title, contents, help_text,
        UI::BackButtonLabel(), UI::NextButtonLabel());

    reload_config();

    any button = nil;

    do
    {
        button = UI::UserInput();
        if (contains (["kerberos", "ldap", "nis", "nisplus"], button))
        {
	    if (!contains (installed, button))
	    {
		string package = sformat ("yast2-%1-client", button);
		if ( Require::RequireAndConflictButtons ( [package], [],
		    // popup label (%1 is package to install)
		    sformat (_("Package %1 is not installed.
Install it now?
"), package), UI::OKButtonLabel(), UI::CancelButtonLabel()))
		{
		    installed = add (installed, button);
		}
		else continue;
	    }
            WFM::CallModule(button, WFM::Args ());
            reload_config ();
        }
    } while ( !contains ([`next, `abort, `back, `cancel], button) );

    if (button == `next) // TODO: check when really needed
    {
	Users::ReadSourcesSettings();
        Users::BuildMenuButtonItems();
    }
    return button;
}

/**
 * Just giving paramaters for commiting user
 * @return symbol for wizard sequencer
 */
global define symbol UserSave() ``{

    Users::Commit("user", true);
    // adding only one user during install
    if (Mode::cont && Users::start_dialog == "user_add" )
        return `save;
    else
    return `next;
}

/**
 * Just giving paramaters for commiting group
 * @return symbol for wizard sequencer
 */
global define symbol GroupSave() ``{

    Users::Commit("group", true);

    return `next;
}

/* EOF */
}
