/**
 * File:	include/users/dialogs.ycp
 * Package:	Configuration of users and groups
 * Summary:	Dialogs definitions
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "users";

import "Wizard";
import "Mode";
import "Report";
import "Progress";
import "Summary";
import "Require";
import "Autologin";
import "Call";
import "Ldap";
import "LdapPopup";


import "Users";
import "UsersCache";
import "UsersLDAP";
import "UsersPlugins";

import "Label";
import "Popup";

include "users/helps.ycp";
include "users/routines.ycp";

string default_pw	= "******";

/**
 * Helper function, converting some strings to symbols
 *  (for later use by wizard sequencer)
 * @param to_convert original string
 * @return converted symbol
 */
define symbol string_to_symbol (string to_convert) ``{

    map to_symbol = $[
	"back":		`back,
	"add_user":	`add_user,
	"edit_user":	`edit_user
    ];
    return to_symbol [to_convert]:`back;
}

define integer GetInt (map data, string key, integer default_value) {

    if (is (data[key]:nil, integer))
	return data[key]:default_value;
    if (is (data[key]:nil, string) && data[key]:nil != "")
	return tointeger (data[key]:sformat ("%1", default_value));
    return default_value;
}

define string GetString (map data, string key, string default_value) {

    if (data[key]:nil != nil)
	return sformat ("%1", data[key]:nil);
    return default_value;
}

/**
 * Upperase letters were used in username! (see bug #26409)
 * In these popup, ask user what to do.
 */
define symbol AskForUppercasePopup (string username) ``{

    symbol ret = `ok;

    if (username != tolower (username) && !Users::NotAskUppercase () &&
	Require::IsAnyPackageInstalled (["sendmail", "postfix"]))
    {
	// The login name contains uppercase 1/3
	string text = _("<p>
You have used uppercase letters in the user login entry.</p>") +

        // The login name contains uppercase 2/3
_("<p>This could cause problems with delivering the mail
to this user, because mail systems generally do not
support case-sensitive names.<br>
You could solve this problem by editing the alias table.</p>
") +

        // The login name contains uppercase 3/3
_("<p>Really use the entered value?</p>");

	UI::OpenDialog (`opt(`decorated), `HBox(`VSpacing (14),
	    `VBox (
		`HSpacing(50),
		`RichText (`id(`rt), text),
		`CheckBox (`id(`ch), `opt(`notify),
		    // checkbox label
		    _("Do Not Show This Message &Again")),
		`HBox(
		    `PushButton (`id(`ok),`opt(`key_F10), Label::YesButton()),
		    `PushButton (`id(`no),`opt(`key_F9), Label::NoButton())
		)
	    ))
	);
	do {
	    ret = (symbol) UI::UserInput();
	}
	while (!contains ([`cancel, `ok, `no], ret));

	if (ret != `cancel)
	{
	    Users::SetAskUppercase ((boolean)UI::QueryWidget(`id(`ch),`Value));
	}
	UI::CloseDialog();
    }
    return ret;
}

/**
 * Function that adds or edits a user.
 * @param what "add_user" or "edit_user"
 * @return symbol for wizard sequencer
 */
define symbol EditUserDialog (string what) ``{

    // Maybe we have returned to the first "add user dialog"
    // during installation workflow:
    if (Users::StartDialog ("user_add") && Mode::cont && Users::UseNextTime ())
    {
	Users::RestoreCurrentUser ();
	Users::SetUseNextTime (false);
    }

    // use local map here...
    map<string,any>user	= Users::GetCurrentUser ();

    if (user == $[])
    {
	Users::AddUser ($[]);
	user = Users::GetCurrentUser ();
    }
    string user_type	= user["type"]:"local";
    string username	= user["uid"]:"";
    string cn		= "";
    // in LDAP, cn is list of strings
    if (is (user["cn"]:nil, list))
	cn	= user["cn",0]:"";
    else
	cn	= user["cn"]:"";
    string tmp_fullname	= cn; // for login proposing
    string default_home = Users::GetDefaultHome (user_type);
    string home		= user["homedirectory"]:default_home;
    string org_home	= user["org_homedirectory"]:home;
    string password	= user["userpassword"]:"x";
    string org_username = user["org_uid"]:username;
    boolean create_home	= user["create_home"]:true;
    integer uid		= GetInt (user, "uidnumber", nil);
    string dn		= user["dn"]:"";

    // only for LDAP users:
    string sn		= "";
    if (is (user["sn"]:nil, list))
	sn	= user["sn",0]:SplitFullName(`sn, cn);
    else
	sn	= user["sn"]:SplitFullName(`sn, cn);
    string givenname		= "";
    if (is (user["givenname"]:nil, list))
	givenname	= user["givenname",0]:SplitFullName(`givenname, cn);
    else if (is (user["givenname"]:nil, string))
	givenname	= user["givenname"]:SplitFullName(`givenname, cn);

    boolean do_not_edit = (user_type == "nis");

    map dialog_labels = $[
        "add_user": $[
            // dialog caption:
            "local":    _("Add a New Local User"),
            // dialog caption:
            "system":	_("Add a New System User"),
            // dialog caption:
            "ldap":     _("Add a New LDAP User")
        ],
        "edit_user": $[
            // dialog caption:
            "local":    _("Edit an Existing Local User"),
            // dialog caption:
            "system":	_("Edit an Existing System User"),
            // dialog caption:
            "ldap":	_("Edit an Existing LDAP User"),
            // dialog caption:
            "nis":	_("Edit an Existing NIS User")
        ]
    ];

    term name_entries =
        // text entry
	`TextEntry (`id(`cn), _("&Full User Name"), cn);

    if (user_type == "ldap")
    {
	name_entries = `VBox(
            // text entry
            `TextEntry(`id(`givenname), _("F&irst Name"), givenname),
            // text entry
            `TextEntry(`id(`sn),  _("&Last Name"),  sn ));
    }

    term fields = `VBox(
	`VStretch(),
	`VBox(
	    // label text
	    do_not_edit ? `Label(_("Only additional group memberships
can be changed for non-local users.
")) : `VSpacing (0),
	    do_not_edit ? `VSpacing (1) : `VSpacing (0),
	    name_entries
	),
	`VSquash(
	    `HBox(
		// input field for login name
		`Bottom(`TextEntry(`id(`username), _("&User Login"), username)),
		(what != "add_user")
		    ? `HSpacing (0)
		    // push button to generate login from first and last name
		    : `Bottom(`PushButton(`id(`propose), _("&Suggestion"))))
	),
	// first version of user password
	`Password(`id(`pw1), _("P&assword"), ""),
	// second version of user password, retyped to avoid typos
	// please use newline if it is longer than 48 characters
	`Password(`id(`pw2), _("&Verify Password:"), "")
    );

    term optionbox = `Empty();
    term buttonbox = `VBox(
	`PushButton(`id(`passwordsettings),`opt(`key_F7, `hstretch),
	    // push button label
	    _("&Password Settings...")),
	// push button label
	`PushButton(`id(`details),`opt(`key_F2, `hstretch), _("&Details..."))
    );

    boolean complex_layout = Mode::cont && Users::StartDialog ("user_add");

    term enable_term	= `Empty();
    if ( complex_layout )
    {
	term checkboxes = `VBox(
	    // checkbox label
	    `Left( `CheckBox (`id (`root_mail),_("Receive S&ystem Mail"),
		Users::GetRootMail () != "") ),
	    `VSpacing (0.5),
	    // checkbox label
	    `Left( `CheckBox (`id (`autologin),_("A&uto Login"),
		Autologin::used) )
	);
	optionbox = `HBox(
			  `HStretch(),
			  `HVCenter( `HVSquash( checkboxes ) ),
			  `HSpacing( 1 ),
			  `HVCenter( `HVSquash( buttonbox  ) ),
			  `HSpacing( 1 )
			  );
    }
    else
    {
	optionbox = `HVCenter ( `HSquash( buttonbox  ) );
	if (what == "edit_user" && !do_not_edit)
	{
	    // helptext
	    string enable_help	= _("<p>If you want to disallow this user to
log in, check <b>Disable User Login</b> option.</p>");

	    enable_term = `VBox (
		`VSpacing (1),
		// check box label
		`CheckBox (`id(`ena), _("Disable User Login")),
		`VSpacing (0.5)
	    );
	    /*
	    term checkboxes = `VBox(
		// checkbox label
		`Left( `CheckBox (`id (`ena),_("Disable User Login")))
	    );
	    optionbox = `HBox(
			  `HStretch(),
			  `HVCenter( `HVSquash( checkboxes ) ),
			  `HSpacing( 1 ),
			  `HVCenter( `HVSquash( buttonbox  ) ),
			  `HSpacing( 1 )
			  );
	    */
	}
    }

    term contents = `VBox(
	`VSpacing(),
	// Frame title
	`Frame( _("User Data"), `HVSquash(
	    `VBox(
		`VSpacing( 0.5 ),
		`HBox( `HSpacing( 2 ),
		       `VBox(
			     `HSquash( fields ),
			     `VSpacing( 1 ),
			     `VSquash( `Top( optionbox ) )
			     ),
		       `HSpacing( 2 )),
		`VSpacing( 0.5 )
	    )
	))
    );


    if ( complex_layout )
    {
	contents = add ( contents, `VBox (
	    `VSpacing (0.5),
	    `HCenter(`PushButton(`id(`additional), `opt(`key_F3),
		// push button
		_("User &Management") ) ),
	    `VSpacing (0.5))
	);
    }
    contents = `VCenter (contents);

    Wizard::SetContentsButtons(
            dialog_labels [ what, user_type ]:"",
            contents,
            EditUserDialogHelp (
		Mode::cont && Users::StartDialog ("user_add"),
		user_type, what),
            Label::BackButton(), Label::NextButton());

    if (do_not_edit)
    {
        UI::ChangeWidget (`id(`cn), `Enabled, false);
        UI::ChangeWidget (`id(`username), `Enabled, false);
        UI::ChangeWidget (`id(`pw1), `Enabled, false);
        UI::ChangeWidget (`id(`pw2), `Enabled, false);
        UI::ChangeWidget (`id(`passwordsettings), `Enabled, false);
    }

    UI::ChangeWidget (`id (`username), `ValidChars, Users::ValidLognameChars());

    if (what == "add_user" && !Mode::cont)
    {
	// change of button label
	Wizard::SetNextButton(`next, _("&Create") );
    }

    if ( what == "add_user" )
    {
	if (user_type == "system")
	    UI::ChangeWidget(`id(`propose), `Enabled, false );
	if (user_type == "ldap")
	    UI::SetFocus(`id(`givenname));
	else
	    UI::SetFocus(`id(`cn));
    }

    if( password != "")
    {
        UI::ChangeWidget(`id(`pw1), `Value, default_pw);
        UI::ChangeWidget(`id(`pw2), `Value, default_pw);
    }

    if (complex_layout && !Autologin::available)
    {
	UI::ChangeWidget(`id(`autologin), `Enabled, false);
	UI::ChangeWidget(`id(`autologin), `Value, false);
    }

    boolean details	= false;
    symbol ret		= `next;

    /**
     * Helper function for user dialog:
     * invalidate any old password and clear password inputfields
     */
    define void clear_password_fields () ``{
	password = "";
	ret = `notnext;
	UI::ChangeWidget(`id(`pw1), `Value, "");
	UI::ChangeWidget(`id(`pw2), `Value, "");
	UI::SetFocus(`id(`pw1));
    }

    repeat
    {
        ret = (symbol) UI::UserInput();

	if (ret == nil) continue;

        username	= (string) UI::QueryWidget(`id(`username), `Value);

	if (! contains ([`back, `cancel, `abort], ret))
	{
	    if (user_type == "ldap")
	    {
		// Form the fullname for LDAP user
		// sn (surname) and cn (fullname) are required attributes,
		// they cannot be empty
		givenname = (string) UI::QueryWidget(`id(`givenname), `Value);
		sn	  = (string) UI::QueryWidget(`id(`sn ), `Value);

		map ldap_user_defaults = UsersLDAP::GetUserDefaults ();
		// create default cn/sn if they are not marked for substitution
		if (sn == "" &&
		    (what == "edit_user" ||
		    !haskey (ldap_user_defaults, "sn")))
		{
		    if (givenname == "")
		    {
			sn = username;
		    }
		    else
		    {
			sn = givenname;
			givenname = "";
		    }
		}
		if (cn == "" &&
		    // no substitution when editing:
		    (what == "edit_user" ||
		    // cn should not be substitued:
		    !haskey (ldap_user_defaults, "cn")))
		{
		    // if 'givenname' or 'sn' should be substitued, wait for it
		    // and do not create cn now:
		    if (!haskey (ldap_user_defaults, "sn") &&
			!haskey (ldap_user_defaults, "givenname"))
		    {
			cn = givenname + ((givenname != "") ? " " : "") + sn;
		    }
		}
		UI::ChangeWidget(`id(`givenname), `Value, givenname);
		UI::ChangeWidget(`id(`sn), `Value, sn);
	    }
	    else
	    {
		cn	= (string) UI::QueryWidget(`id(`cn), `Value);
		string error = Users::CheckFullname (cn);
		if (error != "")
		{
		    Report::Error (error);
		    UI::SetFocus(`id(`cn));
		    ret = `notnext;
		    continue;
		}
	    }
	    // TODO the lists should remain
	    user ["cn"]	= cn;
	    user ["givenname"] = givenname;
	    user ["sn"] = sn;
	}

        // generate a login name from first and last name
        if (ret == `propose)
        {
	    string to_propose = (issubstring (cn, "%") || cn == "") ?
		givenname + " " + sn : cn;
	    if (tmp_fullname != to_propose)
	    {
		UsersCache::ResetProposing ();
		tmp_fullname = to_propose;
	    }
	    username = UsersCache::ProposeUsername (
		filterchars (to_propose, Users::ValidLognameChars() + " "));
            UI::ChangeWidget(`id(`username), `Value, username);
        }

        // only in continue mode
        if( ret == `additional )
        {
            if (UI::QueryWidget(`id(`username), `Value) == "" &&
                UI::QueryWidget(`id(`cn), `Value) == "")
		ret = `nosave;
        }

        details = (contains ([`details,`passwordsettings], ret));

	if (ret == `passwordsettings && user_type == "ldap")
	{
	    list ocs = maplist (string oc, user["objectclass"]:[], ``(tolower (oc)));
	    if (!contains (ocs, "shadowaccount"))
	    {
		/*
		// error, do not translate 'shadowaccount' (LDAP user parameter)
		Popup::Error (_("User does not have 'shadowAccount' as the Object Class,
so the password settings cannot be edited.
"));
		*/
		ocs = add (ocs, "shadowaccount");
		user["objectclass"]	= ocs;
		foreach (string k, any v, Users::GetDefaultShadow ("ldap"), ``{
		    if (!haskey (user, k))
			user[k]	= v;
		});
	    }
	}

        if (( ret == `next || ret == `additional || details ) && !do_not_edit)
        {
	    // map returned from Check*UI functions
	    map error_map			= $[];
	    // map with id's of confirmed questions
	    map<string,integer> ui_map	= $[];


	    // --------------------------------- username checks, part 1/2
	    // empty username during installation (next module)
	    if (username == "" && ret ==`next && Users::StartDialog("user_add"))
	    {
		// The user login field is empty, this is allowed if the
		// system is part of a network with (e.g.) NIS user management.
		// yes-no popup headline
		if (Popup::YesNoHeadline(_("Empty user login"),
		    // yes-no popup contents
		    _("Leaving the user name empty only makes sense
in a network environment with an authentication server.
Are you sure?")))
		{
		    ret = `nextmodule;
		    break;
		}
		UI::SetFocus(`id(`username));
		ret = `notnext;
		continue;
	    }
	    string error = Users::CheckUsername (username);
	    if (error != "")
	    {
                Report::Error (error);
                UI::SetFocus(`id(`username));
		ret = `notnext;
                continue;
	    }
	    user["uid"]		= username;

	    // --------------------------------- uid check (for nil value)
	    if (!details && uid == nil)
	    {
		error = Users::CheckUID (uid);
		if (error != "")
		{
		    Report::Error (error);
		    UI::SetFocus(`id(`details));
		    ret = `notnext;
		    continue;
		}
	    }

	    // --------------------------------- password checks
            string pw1   = (string) UI::QueryWidget(`id(`pw1), `Value);
            string pw2   = (string) UI::QueryWidget(`id(`pw2), `Value);

            if ( pw1 != pw2 )
            {
                // The two user password information do not match
                // error popup
                Report::Error(_("The first and the second version
of the password are different.
Please try again."));
		clear_password_fields ();
                continue;
            }
            if (pw1 != "x" && (pw1 != "" || !details) && pw1 != default_pw)
            {
		error = Users::CheckPassword (pw1);
		if (error != "")
		{
		    Report::Error (error);
		    clear_password_fields ();
		    continue;
		}
		boolean failed			= false;
		do
		{
		    error_map = Users::CheckPasswordUI (username, pw1, ui_map);
		    if (error_map != $[])
		    {
			if (!Popup::YesNo (error_map ["question"]:""))
			{
			    failed = true;
			}
			else
			    ui_map[ error_map["question_id"]:"" ] = 1;
		    }
		} while (error_map != $[] && !failed);

		// FIXME use some checkbox... !
		if (pw1 == "")
		{
		    user["disabled"]	= true;
		}

		if (failed)
		{
		    clear_password_fields ();
		    continue;
		}
		// if "encryted" flag is present, password won't be encrypted
		if (user["encrypted"]:false)
		    user["encrypted"]	= false;
		user ["userpassword"]		= pw1;
		user ["shadowlastchange"]	= Users::LastChangeIsNow();
	    }

            // build default home dir
            if (home == "" || home == default_home || issubstring (home,"%"))
            {
		// LDAP: maybe value of homedirectory should be substituted?
		if ( user_type == "ldap" && issubstring (home, "%") )
		{
		    user = UsersLDAP::SubstituteValues ("user", user);
		    home = user["homedirectory"]:default_home;
		}
		if ( home == default_home  || home == "")
                    home = home + username;
            }

	    // -------------------------------------- directory checks
	    if (!details && home != org_home) {
		error = Users::CheckHome (home);
		if (error != "")
		{
		    Report::Error (error);
		    ret = `notnext;
		    continue;
		}
		boolean failed			= false;
		do
		{
		    error_map = Users::CheckHomeUI (uid, home, ui_map);
		    if (error_map != $[])
		    {
			if (!Popup::YesNo (error_map ["question"]:""))
			    failed = true;
			else
			    ui_map[ error_map["question_id"]:"" ] = 1;
		    }
		} while (error_map != $[] && !failed);

		if (failed)
		{
		    ret = `notnext;
		    continue;
		}
	    }
	    user["homedirectory"]	= home;

	    // --------------------------------- username checks, part 2/2
            if (what == "add_user" || username != org_username)
	    {
		if (AskForUppercasePopup (username) != `ok)
		{
		    UI::SetFocus(`id(`username));
		    ret = `notnext;
		    continue;
		}
            }
	    // ------------------------- last check of all (because of plugins)
	    if (!details)
	    {
		error = Users::CheckUser (user);
		if (error != "")
		{
		    Report::Error (error);
		    ret = `notnext;
		    continue;
		}
	    }

	    // --------------------------------- now everything should be OK:
	    // --------------------------------- save the settings
	    if (haskey (user, "check_error"))
	    {
		user = remove (user, "check_error");
	    }
	    if ( what == "edit_user" )
            {
		Users::EditUser (user);
            }
	    else
	    {
		Users::AddUser (user);
	    }
	}
	if ((ret == `abort || ret == `cancel) && ReallyAbort () != `abort)
	{
	    ret = `notnext;
	}
    }
    until ( contains ([`next,`abort,`back,`cancel,`additional,`nosave],
	    ret) || (details && ret != `notnext) );

    if (Users::StartDialog ("user_add") && Mode::cont)
    {
        Users::SetRootMail (
	    (boolean)UI::QueryWidget(`id (`root_mail), `Value) ? username : "");
	if (Autologin::available)
	{
	    Autologin::user = (boolean)UI::QueryWidget (`id (`autologin),`Value)
		? username : "";
	    Autologin::used = (boolean)UI::QueryWidget(`id (`autologin),`Value);
	}
    }
    if ( ret == `additional ||  ret == `nosave )
    {
        // ensuring installation the first user is stored
        // (to show it when clicking `back from Summary dialog)
	Users::SaveCurrentUser ();
	Users::SetStartDialog ("users");
    }
    return ret;
}

/**
 * Details of adding/cloning/editing dialog
 * @return symbol for wizard sequencer
 */
define symbol EditUserDetailsDialog( ) ``{

    map<string,any>user	= Users::GetCurrentUser ();

    // load the current usersettings from Users::user_in_work
    string user_type	= user["type"]:"local";
    string what         = user["what"]:"no";
    string username     = user["uid"]:"";
    string cn		= user["cn"]:"";
    string home         = user["homedirectory"]:"";
    string org_home     = user["org_homedirectory"]:"";
    boolean create_home = user["create_home"]:true;
    string shell        = user["loginshell"]:"";
    map<string,integer> groups		= user["grouplist"]:$[];
    integer uid	= GetInt (user, "uidnumber", UsersCache::GetMaxUID (user_type));
    integer gid	= GetInt (user, "gidnumber", UsersCache::GetMaxGID (user_type));
    string defaultgroup = user["groupname"]:"";

    // additional parts of GECOS (shown by `finger <username>`) (passwd only)
    string addit_data	= user["addit_data"]:"";

    list available_shells	= Users::AllShells ();
    list available_groups	= [];
    list additional_groups	= [];
    list additional_ldap_groups	= [];
    list removed = [];
    string grouplist		= "";

    string new_type = user_type;

    map<string,map<string,integer> > all_groupnames	=
	UsersCache::GetAllGroupnames ();

    // fill the list available_groups and set the user default group true
    foreach (string grouptype, map<string,integer> groupmap, all_groupnames, ``{
        if (grouptype == "local" || grouptype == "system" ||
            (grouptype == "ldap" && user_type == "ldap"))
	{
          foreach (string group, integer val, groupmap, ``{

            if (user_type == "ldap")
            {
                if (grouptype == "ldap")
                {
                    if ( group == defaultgroup )
                        available_groups = add (available_groups,
                            `item( `id(group), group, true));
                    else
                        available_groups = add (available_groups,
                            `item( `id(group), group));
                    if ( haskey (groups, group))
                        additional_ldap_groups = add (additional_ldap_groups,
                            `item( `id(group), group, true ));
                    else
                        additional_ldap_groups = add (additional_ldap_groups,
                            `item( `id(group), group, false));
                }
                else
                {
		    // if there is a group with same name, use only that
		    // with type "ldap"
		    if ( all_groupnames ["ldap",group]:0 == 1 )
			return;
                    if ( haskey (groups, group))
                        additional_groups = add (additional_groups,
                            `item( `id(group), group, true ));
                    else
                        additional_groups = add (additional_groups,
                            `item( `id(group), group, false));
                }
            }
            else
            {
                if ( group == defaultgroup )
                    available_groups = add (available_groups,
                        `item( `id(group), group, true));
                else
                    available_groups = add (available_groups,
                        `item( `id(group), group));
                if ( haskey (groups, group))
                    additional_groups = add (additional_groups,
                        `item( `id(group), group, true ));
                else
                    additional_groups = add (additional_groups,
                        `item( `id(group), group, false));
            }
          });
	}
    });
    // backup NIS groups of user (they are not shown in dialog)
    map<string,integer> nis_groups	= $[];
    foreach (string group, integer val, groups, ``{
	if (all_groupnames ["nis", group]:0 == 1)
	    nis_groups [group] = 1;
    });

    if (defaultgroup == "")
    {
        available_groups = add (available_groups,
	    // group name is not known (combobox item):
	    `item( `id(""), _("(not known)"), true));
    }

    boolean do_not_edit = (user_type == "nis");
    term edit_defaultgroup = `ComboBox(`id(`defaultgroup), `opt(`hstretch),
        // combobox label
        _("Default &group"), available_groups );
    term edit_shell = `ComboBox(`id(`shell), `opt(`hstretch, `editable),
        // combobox label
        _("Login &shell"), available_shells );

    term additional_data = `Empty();
    if (user_type == "system" || user_type == "local")
        additional_data =
            // textentry label
            `Top(`TextEntry(`id(`addd), _("&Additional User Information:"),
                addit_data));

    term browse = `VBox(
	`Label (""),
	// button label
        `PushButton( `id(`browse), `opt(`key_F6), _("Bro&wse...")));

    term home_w = `VBox(
	// textentry label
	`TextEntry( `id(`home), _("&Home Directory"), home )
    );

    term contents = `HBox(
          `HSpacing(1),
          `VBox(
           `VSpacing(0.5),
           // label
           do_not_edit ? `Label(_("Only additional group memberships
can be changed for non-local users.")) : `VSpacing (0),
           do_not_edit ? `VSpacing (1) : `VSpacing (0),
           // frame label, user name follows
           `VSpacing(0.5),
           `Frame(sformat(_("Detailed Profile for User \"%1\""),
		username),
           `HBox(
		`HSpacing (1),
                `VBox(
		    `VSpacing (0.5),
                    // textentry label
                    `Top(`TextEntry( `id(`uid), _("User &ID (uid)"),
                        sformat("%1",uid ))),
                    `Top(`HBox ( home_w, browse)),
                    additional_data,
                    `Top(edit_shell),
                    `Top(edit_defaultgroup),
                    `VStretch()
                ),
                `HSpacing(2),
		`VBox(
		    `VSpacing (0.5),
		    `Top(`MultiSelectionBox( `id(`grouplist),
			// selection box label
			_("Additional Group &Membership"), additional_groups)),
		    (user_type == "ldap")
		    ? `MultiSelectionBox( `id(`ldapgrouplist),
			// selection box label
			_("Additional &LDAP Groups"), additional_ldap_groups)
		    : `Empty()
		    ),
		`HSpacing (1)
            )),
            `VSpacing(0.5)
           ),
           `HSpacing(1)
    );

    // dialog caption
    Wizard::SetContentsButtons(_("Add/Edit User Properties - Details"),
                    contents,
                    EditUserDetailsDialogHelp(user_type),
                    Label::BackButton(),
                    Label::NextButton());

    if (do_not_edit)
    {
        UI::ChangeWidget (`id (`uid), `Enabled, false);
        UI::ChangeWidget (`id (`home), `Enabled, false);
        UI::ChangeWidget (`id (`shell), `Enabled, false);
        UI::ChangeWidget (`id (`defaultgroup), `Enabled, false);
        UI::ChangeWidget (`id (`browse), `Enabled, false);
    }
    if (user_type == "ldap" && !Ldap::file_server)
    {
        UI::ChangeWidget (`id (`browse), `Enabled, false);
    }

    UI::ChangeWidget(`id(`shell), `Value, shell);

    // user input
    any ret = `next;
    repeat
    {
        ret = UI::UserInput();
	if (ret == `browse)
	{
	    string dir = home;
	    if (SCR::Read(.target.size, home ) == -1)
	    {
		dir = Users::GetDefaultHome (new_type);
	    }
	    dir = UI::AskForExistingDirectory (dir, "");
	    if (dir != nil)
	    {
		if ( (findlastof( dir, "/") + 1) == size(dir) )
		    dir = substring (dir, 0, size(dir)-1);
		UI::ChangeWidget (`id(`home), `Value, dir);
	    }
	}
        if (ret == `next)
        {
	    // map returned from Check*UI functions
	    map<string,string> error_map	= $[];
	    // map with id's of confirmed questions
	    map<string,integer> ui_map		= $[];

            string  new_shell = (string)UI::QueryWidget(`id(`shell), `Value);
            string  new_uid   = (string)UI::QueryWidget(`id(`uid),   `Value);
            string  new_defaultgroup = (string)
		UI::QueryWidget(`id(`defaultgroup),`Value);
            string  new_home  = (string) UI::QueryWidget(`id(`home),  `Value);
	    if ((findlastof (new_home, "/") + 1) == size (new_home))
	    {
		new_home = substring (new_home, 0, size(new_home)-1);
	    }

            if (do_not_edit)
            {
                new_home	= home;
                new_shell	= shell;
                new_uid		= sformat("%1", uid);
                new_defaultgroup = defaultgroup;
            }
            integer new_i_uid    = tointeger (new_uid);

	    // additional data in GECOS field (passwd only)
            if (new_type == "local" || new_type == "system")
            {
                addit_data  = (string) UI::QueryWidget(`id(`addd),  `Value);
		string error = Users::CheckGECOS (addit_data);
		if (error != "")
		{
		    Report::Error (error);
		    UI::SetFocus(`id(`addd));
		    ret = `notnext;
		    continue;
		}
            }

            // check the uid
            if (new_i_uid != uid)
            {
		string error = Users::CheckUID (new_i_uid);
		if (error != "")
		{
		    Report::Error (error);
		    UI::SetFocus(`id(`uid));
		    ret = `notnext;
		    continue;
		}
		error_map = Users::CheckUIDUI (new_i_uid, ui_map);
		if (error_map != $[])
		{
		    if (!Popup::YesNo (error_map ["question"]:""))
		    {
			ret = `notnext;
			UI::SetFocus(`id(`uid));
			continue;
		    }
		    new_type = error_map["question_id"]:"local";
		    UsersCache::SetUserType (new_type);
		}
            } // end of uid checks

            if ( defaultgroup != new_defaultgroup )
            {
                gid = lookup (Users::GetGroupByName (new_defaultgroup,new_type),
		    "gidnumber", gid);
            }

            // check the homedirectory
            if (home != new_home || what == "add_user")
            {
		string error = Users::CheckHome (new_home);
		if (error != "")
		{
		    Report::Error (error);
		    UI::SetFocus(`id(`home));
		    ret = `notnext;
		    continue;
		}
		boolean failed			= false;
		do
		{
		    error_map = Users::CheckHomeUI(new_i_uid, new_home, ui_map);
		    if (error_map != $[])
		    {
			if (!Popup::YesNo (error_map ["question"]:""))
			    failed = true;
			else
			    ui_map[ error_map["question_id"]:"" ] = 1;
		    }
		} while (error_map != $[] && !failed);

		if (failed)
		{
		    ret = `notnext;
		    UI::SetFocus(`id(`home));
		    continue;
		}
	    }

	    error_map = Users::CheckShellUI (new_shell, ui_map);
	    if (error_map != $[])
	    {
		if (!Popup::YesNo (error_map ["question"]:""))
		{
		    ret = `notnext;
		    UI::SetFocus(`id(`shell));
		    continue;
		}
	    }

	    // generate new map of groups (NIS groups were not shown!)
	    map new_groups	= listmap (string group, (list<string>)
		    UI::QueryWidget(`id(`grouplist), `SelectedItems), ``{
			return $[ group : 1 ];
	    });
	    if (new_type == "ldap")
	    {
		foreach (string group, (list<string>)
		    UI::QueryWidget (`id(`ldapgrouplist),`SelectedItems), ``{
			new_groups = add (new_groups, group, 1);
		});
	    }
	    // now add NIS groups again (were not shown in dialog)
	    foreach (string group, integer val, nis_groups, ``{
		if (!haskey (new_groups, group))
		    new_groups = add (new_groups, group, 1);
	    });

            // update Users::user_in_work
	    map<string,any> user = $[
		"homedirectory"		: new_home,
		"loginshell"		: new_shell,
		"gidnumber"		: gid,
		"uidnumber"		: new_i_uid,
		"grouplist"		: new_groups,
		"groupname"		: new_defaultgroup,
		"type"			: new_type,
		"create_home"		: create_home,
		"addit_data"		: addit_data,
	    ];
	    if (what == "add_user")
	    {
		Users::AddUser (user);
	    }
	    else
	    {
		Users::EditUser (user);
	    }
        } // ret = `next
    } until (ret == `next || ret == `abort  || ret == `back || ret == `cancel);

    return (symbol)ret;
}


/**
 * Details of adding/cloning/editing dialog
 * @return symbol for wizard sequencer
 */
define symbol EditUserPasswordDialog() ``{

    map<string,any>user	= Users::GetCurrentUser ();

    map<string,any>shadow	= $[];

    string username	= user["uid"]:"";
    string user_type	= user["type"]:"local";
    list<string> shadow_symbols =
	["shadowwarning", "shadowmax", "shadowmin", "shadowinactive"];

    string last_change	= GetString (user, "shadowlastchange", "0");
    string expires	= GetString (user, "shadowexpire", "0");
    if (expires == "")
	expires = "0";

    //TODO correct default values
    integer inact = GetInt (user, "shadowinactive", 0);
    integer max	= GetInt (user, "shadowmax", 0);
    integer min = GetInt (user, "shadowmin", 0);
    integer warn = GetInt (user, "shadowwarning", 0);

    if (last_change != "0")
    {
        map out = (map)SCR::Execute (.target.bash_output, sformat ("date --date='1970-01-01 00:00:01 %1 days' +\"%%x\"", last_change));
        // label (date of last password change)
	last_change = out["stdout"]:_("unknown");
    }
    else
    {
        // label (date of last password change)
        last_change = _("never");
    }
    string exp_date = "";
    if (expires != "0" && expires != "-1" && expires != "")
    {
        exp_date = lookup ((map)SCR::Execute (.target.bash_output, (sformat ("date --date='1970-01-01 00:00:01 %1 days' ", expires) + "+\"%Y-%m-%d\"")), "stdout", "");
        // remove \n from the end
        exp_date = deletechars (exp_date, "\n");
    }
    term contents = `HBox (
        `HSpacing (3),
            `VBox (
                `VStretch(),
                `Top(`Left (`Label (sformat (
		    // label
		    _("Date of the last password change: %1"), last_change )))),
                `VSpacing (1),
                `HSquash(`VBox(
                    `IntField (`id ("shadowwarning"),
			// intfield label
			_("Days before Password Expiration to Issue &Warning"),
			-1, 99999, warn),
                    `VSpacing (0.5),
                    `IntField (`id ("shadowinactive"),
			// intfield label
			_("Days &after Password Expires with Usable Login"),
			-1, 99999, inact),
                    `VSpacing (0.5),
                    `IntField (`id ("shadowmax"),
			// intfield label
			_("Ma&ximum number of days for the same password"),
			-1, 99999, max),
                    `VSpacing (0.5),
                    `IntField (`id ("shadowmin"),
			// intfield label
			_("&Minimum number of days for the same password"),
			-1, 99999, min),
                    `VSpacing (0.5),
                    `TextEntry (`id ("shadowexpire"),
			// textentry label
			_("&Expiration date"), exp_date)
                )),
                `VStretch ()),
            `HSpacing (3));

    Wizard::SetContentsButtons (
	// dialog caption, %1 is user name
	sformat (_("Password Settings for User %1"), username),
        contents,
        EditUserPasswordDialogHelp(),
        Label::BackButton(),
        Label::NextButton());

    // user input
    any ret = `next;
    repeat
    {
        ret = UI::UserInput();
        if( ret == `next )
        {
            string exp = (string)UI::QueryWidget (`id ("shadowexpire"), `Value);
            if (exp != "" &&
                !regexpmatch (exp,"[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
            {
		// popup text: Don't reorder the letters YYYY-MM-DD!!!
		// The date must stay in this format
		Popup::Message(_("Expiration date must be in format YYYY-MM-DD"));
		UI::SetFocus(`id("expire"));
		ret = `notnext;
		continue;
            }
            // update the values in shadow map
            foreach (string shadowsymbol, shadow_symbols, ``{
                if (user[shadowsymbol]:nil != UI::QueryWidget (
                        `id(shadowsymbol), `Value))
		{
                    shadow[shadowsymbol] = sformat ("%1",
                        UI::QueryWidget(`id(shadowsymbol), `Value));
		}
            });
            string new_exp_date = (string)
		UI::QueryWidget(`id("shadowexpire"),`Value);
            if (new_exp_date != exp_date)
            {
                if (new_exp_date == "")
		    // TODO why it is different for LDAP?
                    shadow["shadowexpire"] = user_type == "ldap" ? "" : "0";
                else
                {
                    map out = (map)SCR::Execute(.target.bash_output,
                        sformat("date --date='%1 UTC' ", new_exp_date) + "+%s");
		    string seconds_s = deletechars(out["stdout"]:"0","\n");
                    if (seconds_s != "")
                    {
			integer days = (tointeger(seconds_s))/ (60*60*24);
                        shadow["shadowexpire"] = sformat("%1", days);
                    }
                }
            }
        }
    } until (ret == `next || ret == `abort  || ret == `back || ret == `cancel);

    if ( ret == `next )
    {
	string what = user["what"]:"back";

	if (what == "add_user")
	    Users::AddUser (shadow);
	else if (what == "edit_user")
	    Users::EditUser (shadow);

	ret = string_to_symbol (what);
    }
    return (symbol)ret;
}

/**
 * Dialog with additional settings, provided by extern plugins
 * @return symbol for wizard sequencer
 */
define symbol PluginDialog (string what) ``{

    map<string, any> object	= (what == "user") ?
	Users::GetCurrentUser (): Users::GetCurrentGroup ();

    // UsersPlugins will filter out plugins we cannot use for given type
    map plugin_clients	= UsersPlugins::Apply ("GUIClient",
	$[ "what"	: what,
	   "type"	: object["type"]:""
//	   "plugins" entry not present => apply for all present plugins
// (limited only to user/group type)
	],
	$[]
    );
    // remove empty clients
    plugin_clients = filter (string plugin, string client,
	(map<string,string>) plugin_clients, ``(client != ""));

    symbol ret			= `not_next;
    if (size (plugin_clients) == 0)
    {
	ret = `next;
    }
    else
    {
	map client2plugin	= $[];
	list<string> clients	= maplist (string plugin, string client,
	    (map<string,string>) plugin_clients, ``{

		client2plugin [client]	= plugin;
		return client;
	});

	string client		= clients[0]:"";
	string plugin		= client2plugin[client]:client;

	// dialog caption
	string caption	= _("Additional User Settings");

	if (what == "group")
	    // dialog caption
	    caption	= _("Additional Group Settings");

	// helptxt for plugin dialog 1/2
	string help	= _("<p>Here you can see the list of 'Plug-ins' - the 
extensions of User and Group configuration.</p>") +

	"FIXME" +

	// helptxt for plugin dialog 2/2
	_("<p>You can start particular plug-in by pushing the <b>Launch</b> button.</p>");

	list items = [];
	foreach (string cl, clients, ``{
	    any summary = WFM::CallFunction (cl,
		["Summary", $[ "what" : what ] ]);
	    string pl  = client2plugin[cl]:cl;
	    if (is (summary, string))
		items = add (items, `item(`id(cl),
		    contains (object["plugins"]:[], pl) ?
			UI::Glyph (`CheckMark) : " ",
		    summary)
		);
	});
	term contents = `VBox(
	    `Table (`id(`table), `opt(`notify), `header (
		" ",
		// table header
	        _("Plug-in Description")), items),
	    `HBox (
		// pushbutton label
		`PushButton (`id(`change), `opt(`key_F3), _("&Add/Remove Plugin")),
		// pushbutton label
		`Right (`PushButton(`id(`run), `opt(`key_F6), _("&Launch")))
	    ),
	    `VSpacing (0.5)
	);

	// dialog caption
	Wizard::SetContentsButtons(caption, contents, help,
	    Label::BackButton(), Label::NextButton());
	UI::ChangeWidget (`id(`table),`CurrentItem, client);
	repeat
	{
	    ret		= (symbol) UI::UserInput();
	    client	= (string) UI::QueryWidget (`id(`table),`CurrentItem);
	    plugin	= client2plugin[client]:client;

	    if (ret == `table || ret == `change)
	    {
		ret = contains (object["plugins"]:[], plugin) ? `del : `add;
	    }
	    if (ret == `add)
	    {
		UI::ChangeWidget (`id(`table), `Item (client,0), UI::Glyph (`CheckMark));
		if (what == "user")
		{
		    Users::AddUserPlugin (plugin);
		    object = Users::GetCurrentUser ();
		}
		else
		{
//FIXME		    Users::AddGroupPlugin (plugin);
		    object = Users::GetCurrentGroup ();
		}
	    }
	    if (ret == `del)
	    {
		map out	= UsersPlugins::Apply ("PluginRemovable",
		    $[ "what"	: what,
		       "type"	: object["type"]:"",
		       "plugins": [ plugin ],
		    ], $[]);
		// check if plugin _could_ be deleted!
		if (haskey (out, plugin) && ! (out[plugin]:false))
		{
		    // popup message
		    Popup::Message (_("This Plug-in cannot be removed."));
		    ret = `not_next;
		    continue;
		}
		UI::ChangeWidget (`id(`table), `Item (client,0), " ");
		if (what == "user")
		{
		    Users::RemoveUserPlugin (plugin);
		    object = Users::GetCurrentUser ();
		}
		/* TODO
		else
		{
		    Users::RemoveGroupPlugin (plugin);
		    object = Users::GetCurrentGroup ();
		}
		*/
	    }
	    if (ret == `run)
	    {
		// first, add the plugin if necessary
		if (!contains (object["plugins"]:[], plugin))
		{
		    if (what == "user")
		    {
			Users::AddUserPlugin (plugin);
			object = Users::GetCurrentUser ();
		    }
		    else
		    {
//FIXME			Users::AddGroupPlugin (plugin);
			object = Users::GetCurrentGroup ();
		    }

		}
		any plugin_ret = WFM::CallFunction (client, ["Dialog", $[
		    "what"	: what ], object ]);
		if (plugin_ret == `next)
		{
		    // update the map of changed object
		    object	= (what == "user") ?
			Users::GetCurrentUser (): Users::GetCurrentGroup ();
		}
	    }
	    if (ret == `abort || ret == `cancel)
	    {
		if (ReallyAbort() != `abort)
		    ret = `not_next;
	    }
	} until (contains ([`next, `abort, `back], ret));
    }

    if ( ret == `next )
    {
	if (what == "user") {
	    string what_user = object["what"]:"back";
	    ret = string_to_symbol (what_user);
	}
    }
    return ret;
}

/**
 * Details of adding/editing group dialog
 * @param what "add_group" or "edit_group"
 * @return symbol for wizard sequencer
 */
define symbol EditGroupDialog (string what ) ``{

    // create a local copy of current group
    map<string,any> group	= Users::GetCurrentGroup ();
    string  groupname		= group["cn"]:"";
    string  password		= group["userpassword"]:"x";
    integer gid			= GetInt (group, "gidnumber", -1);
    // these are the users with this group as a default:
    map<string,integer> more_users	= group["more_users"]:$[];
    // these are users from /etc/group:
    map<string,integer> userlist	= group["userlist"]:$[];
    string group_type		= group["type"]:"";
    string new_type		= group_type;
    string dn			= group["dn"]:"";
    string new_dn		= dn;
    list additional_users	= [];
    list removed		= [];
    string member_attribute	= UsersLDAP::GetMemberAttribute ();

    if (group_type == "ldap")
    {
	userlist		= group[member_attribute]:$[];
    }
    additional_users		= UsersCache::BuildAdditional (group);

    integer i = 0;
    list more_users_items	= [];
    foreach (string u, integer val, more_users, ``{
	if (i <42)
	    more_users_items = add (more_users_items, `item (`id(u), u, true ));
	if (i == 42)
	    more_users_items = add (more_users_items,
		`item (`id("-"), "...", false ));
	i = i + 1;
    });

    boolean more = size (more_users) > 0;

    map dialog_labels = $[
        "add_group": $[
            // dialog caption:
            "local":	_("Add a New Local Group"),
            // dialog caption:
            "system":	_("Add a New System Group"),
            // dialog caption:
            "ldap":     _("Add a New LDAP Group")
        ],
        "edit_group": $[
            // dialog caption:
            "local":     _("Edit an Existing Local Group"),
            // dialog caption:
            "system":	_("Edit an Existing System Group"),
            // dialog caption:
            "ldap":     _("Edit an Existing LDAP Group")
        ]
    ];

    // make dialog
    term contents = `HBox(
        `Left(`VBox(
            `VSpacing(1),
            // textentry label
            `Top(`TextEntry( `id(`groupname), _("&Group Name"), groupname )),
            // textentry label
            `Top(`TextEntry( `id(`gid), _("Group &ID (gid)"),
                sformat("%1", gid) )),
            `VSpacing(1),
            // User account information, first version of group password
            `Bottom(`Password(`id(`pw1), _("&Enter a Password"), "")),
            // User account information, second version of group password,
            // please use newline if it is longer than 48 characters
            `Bottom(`Password(`id(`pw2), _("Reenter the &Password"),  "")),
            `VSpacing(1)
        )),
        `HSpacing(2),
        `VBox(
            `VSpacing(1),
	    `ReplacePoint (`id(`rpuserlist),
		// selection box label
		`MultiSelectionBox( `id(`userlist), _("&Members of this Group"),
		    [])
	    ),
            more ? `VSpacing(1) : `VSpacing (0),
            // selection box label
            more ? `MultiSelectionBox ( `id(`more_users), "",
                more_users_items) : `VSpacing (0),
            `VSpacing(1)
        ));

    Wizard::SetContentsButtons(
        dialog_labels [ what, group_type ]:"",
	contents,
        EditGroupDialogHelp(more),
        Label::BackButton(), Label::NextButton());

    if( what == "add_group" ) UI::SetFocus(`id(`groupname));

    if( what == "edit_group" )
    {
        if( !contains (["x","*","!"], password) )
        {
	    UI::ChangeWidget(`id(`pw1), `Value, default_pw);
	    UI::ChangeWidget(`id(`pw2), `Value, default_pw);
        }
    }

    if (more)
    {
	// the group of users having this group as default - cannot be edited!
        UI::ChangeWidget (`id(`more_users), `Enabled, false);
    }
    // add items later (when there is a huge amount of them, it takes long
    // time to display, so display at least the rest of the dialog)
    if (size (additional_users) > 0)
    {
	UI::ReplaceWidget (`id(`rpuserlist),
	    `MultiSelectionBox( `id(`userlist), _("&Members of this Group"),
		additional_users));
    }

    symbol ret = `next;

    // Helper function for group dialog:
    // invalidate any old password and clear password inputfields
    define void clear_password_fields () ``{

	password = "";
	ret = `notnext;
	UI::ChangeWidget(`id(`pw1), `Value, "");
	UI::ChangeWidget(`id(`pw2), `Value, "");
	UI::SetFocus(`id(`pw1));
    }

    repeat
    {
        ret = (symbol) UI::UserInput();

	if ((ret == `abort || ret == `cancel) && ReallyAbort () != `abort)
	{
	    ret = `notnext;
	}
        if (ret == `next)
        {
	    // map returned from Check*UI functions
	    map error_map			= $[];
	    // map with id's of confirmed questions
	    map<string,integer> ui_map		= $[];

            string pw1          = (string) UI::QueryWidget(`id(`pw1), `Value);
            string pw2          = (string)UI::QueryWidget(`id(`pw2),`Value);
            string new_gid	= (string)UI::QueryWidget(`id(`gid), `Value);
            integer new_i_gid	= tointeger(new_gid);
            string new_groupname	= (string)
		UI::QueryWidget(`id(`groupname), `Value);

	    // --------------------------------- groupname checks
	    string error = Users::CheckGroupname (new_groupname);
	    if (error != "")
	    {
		Report::Error (error);
                UI::SetFocus (`id(`groupname));
		ret = `notnext;
		continue;
	    }
	    // --------------------------------- password checks
            if ( pw1 != pw2 )
            {
                // The two group password information do not match
                // error popup
                Report::Error(_("The first and the second version
of the password are different.
Please try again.")) ;

		clear_password_fields();
                continue;
            }
            if ( pw1 != "" && pw1 != default_pw )
            {
		error = Users::CheckPassword (pw1);
		if (error != "")
		{
		    Report::Error (error);
		    clear_password_fields ();
		    continue;
		}
		password = pw1;
		if (group["encrypted"]:false)
		    group["encrypted"]	= false;
            }

	    // --------------------------------- gid checks
            if ( new_i_gid != gid)
	    {
		error = Users::CheckGID (new_i_gid);
		if (error != "")
		{
		    Report::Error (error);
		    UI::SetFocus (`id(`gid));
		    ret = `notnext;
		    continue;
		}
		error_map = Users::CheckGIDUI (new_i_gid, ui_map);
		if (error_map != $[])
		{
		    if (!Popup::YesNo (error_map ["question"]:""))
		    {
			ret = `notnext;
			UI::SetFocus(`id(`gid));
			continue;
		    }
		    new_type = error_map["question_id"]:"local";
		    UsersCache::SetGroupType (new_type);
		}
	    }

	    // --------------------------------- update userlist
	    map new_userlist = listmap (string user, (list<string>)
		UI::QueryWidget (`id(`userlist), `SelectedItems), ``{
		    return $[ user: 1 ];
	    });

	    // --------------------------------- now everything should be OK
            group["cn"]			= new_groupname;
            group["userpassword"]	= password;
            group["more_users"]		= more_users;
            group["gidnumber"]		= new_i_gid;
            group["type"]		= new_type;
	    if (group_type == "ldap")
	    {
		group[member_attribute]	= new_userlist;
		ret			= `ldap; // additional settings
	    }
	    else
	    {
		group["userlist"]	= new_userlist;
	    }

	    if (what == "edit_group")
		Users::EditGroup (group);
	    else
		Users::AddGroup (group);
        }
    } until ( contains ([`next, `abort, `back, `ldap, `cancel], ret));
    return ret;
}

/**
 * The dialogs for setting defaults from /etc/defaults/useradd
 * @return symbol for wizard sequencer
 */
define symbol DefaultsDialog() ``{

    string home		= Users::GetDefaultHome ("local");
    string shell	= Users::GetDefaultShell ("local");
    integer gid		= Users::GetDefaultGID ("local");
    string defaultgroup	= Users::GetDefaultGroupname ("local");

    map defaults	= Users::GetLoginDefaults ();
    string skel		= defaults["skel"]:"/etc/skel";
    string expire	= defaults["expire"]:"";
    string inactive	= defaults["inactive"]:"";
    integer inact	= tointeger (inactive);

    map<string,integer> groups	= Users::GetDefaultGrouplist ("local");

    string grouplist	= mergestring (
	(list<string>) maplist (string g,integer i, groups, ``(g)), ",");

    string exp_date		= "";
    list available_groups	= [];
    list available_shells	= Users::AllShells ();

    map<string,map<string,integer> > all_groupnames	=
	UsersCache::GetAllGroupnames ();

    foreach (string grouptype, map<string,integer> groupmap, all_groupnames, ``{
	// only local sets
	if (!contains (["local", "system"], grouptype))
	    return;
        foreach (string group, integer val, groupmap, ``{
            if ( group == defaultgroup )
                available_groups = add (available_groups,
                    `item( `id(group), group, true));
            else
                available_groups = add (available_groups,
                    `item( `id(group), group));
        });
    });

    if (expire != "0" && expire != "")
    {
        exp_date = lookup ((map)SCR::Execute (.target.bash_output, (sformat (
		"date --date='1970-01-01 00:00:01 %1 days' ", expire) +
		"+\"%Y-%m-%d\"")), "stdout", "");
        exp_date = deletechars (exp_date, "\n");
    }

    term contents = `HBox(`HSpacing(1.5),
        `VBox(
            `VSpacing(0.2),
		// Frame label
	        `Frame(_("Set the Default Values for Adding New User"),`HBox(
		`HSpacing(2), `VBox(
                `ComboBox(`id(`defaultgroup), `opt(`hstretch),
                    // combobox label
                    _("D&efault Group"), available_groups ),
                // text entry
                `TextEntry( `id(`grouplist), _("Se&condary Groups"), grouplist),
                // text entry
                `ComboBox(`id(`shell), `opt(`hstretch, `editable),
                    // combobox label
                    _("Default &Login Shell"), available_shells),
		`HBox(
		    // text entry
		    `TextEntry(`id(`home), _("Path Prefix for &Home Directory"),
			home),
		    `VBox(
			`Label (""),
			`PushButton(`id(`brow_h),`opt(`key_F6), _("Bro&wse..."))
		    )
		),
		`HBox(
		    // text entry
		    `TextEntry(`id(`skel), _("&Skeleton for Home Directory"),
			skel),
		    `VBox(
			`Label (""),
			`PushButton(`id(`brow_s),`opt(`key_F7), _("Bro&wse..."))
		    )
		),
                // text entry
                `TextEntry( `id(`exp), _("Default E&xpiration Date"), exp_date),
                // intfield
                `IntField (`id (`inact), _("Days &after Password Expiration Login Is Usable"), -1, 99999, inact),
		`VSpacing (0.2)
                ),
              `HSpacing(2))),
            `VSpacing(0.2)),
        `HSpacing(1.5));

    Wizard::SetContentsButtons(
            // dialog label
            _("New User Defaults"),
            contents,
            DefaultsDialogHelp(),
            Label::BackButton(),
            Label::NextButton());

    UI::ChangeWidget(`id(`shell), `Value, shell);

    boolean modified = false;

    string new_home  = home;
    string new_shell = shell;
    string new_skel = skel;
    string new_defgroup = defaultgroup;
    string new_exp_date = exp_date;
    integer new_inact = inact;
    string new_expire = expire;
    string new_grouplist = grouplist;

    symbol ret = `next;
    while (true)
    {
        modified = false;
        ret = (symbol) UI::UserInput();
        if (ret == `back || ret == `abort || ret == `cancel) break;
	if ( ret == `brow_h)
	{
	    string dir = (string) UI::QueryWidget(`id(`home),  `Value);
	    if (SCR::Read(.target.size, dir ) == -1)
		dir = home;
	    dir = UI::AskForExistingDirectory (dir, "");
	    if (dir != nil)
	    {
		UI::ChangeWidget (`id(`home), `Value, dir);
	    }
	}
	if ( ret == `brow_s)
	{
	    string dir = (string) UI::QueryWidget(`id(`skel),  `Value);
	    if (SCR::Read(.target.size, dir ) == -1)
		dir = skel;
	    dir = UI::AskForExistingDirectory (dir, "");
	    if (dir != nil)
	    {
		UI::ChangeWidget (`id(`skel), `Value, dir);
	    }
	}
        if (ret == `next)
        {
            new_home  = (string)UI::QueryWidget(`id(`home),  `Value);
            new_shell = (string)UI::QueryWidget(`id(`shell), `Value);
            new_skel = (string)UI::QueryWidget(`id(`skel), `Value);
            new_inact = (integer)UI::QueryWidget(`id(`inact), `Value);
            new_defgroup = (string)UI::QueryWidget(`id(`defaultgroup),`Value);
            new_exp_date = (string)UI::QueryWidget(`id(`exp),`Value);
	    new_grouplist = (string)UI::QueryWidget(`id(`grouplist),`Value);
	    // check new grouplist...
	    if (new_grouplist != grouplist)
	    {
		list<string> l_grouplist = [];
		list<string> dont_exist = [];
		foreach (string g, splitstring (new_grouplist, ","), ``{
		    // check for group existence
		    if (all_groupnames["local", g]:0 == 0 &&
			all_groupnames["system", g]:0 == 0)
			dont_exist = (list<string>) union (dont_exist, [g]);
		    // filter out the duplicates
		    else l_grouplist = (list<string>) union (l_grouplist, [g]);
		});
		if (dont_exist != [])
		{
		    // error message
		    Report::Error(sformat (_("These groups do not exist in your system:
%1
Try again.
"), mergestring (dont_exist, ",")));

		    UI::SetFocus (`id(`grouplist));
		    ret = `notnext;
		    continue;
		}
		new_grouplist = mergestring (l_grouplist, ",");
		UI::ChangeWidget (`id(`grouplist), `Value, new_grouplist);
		modified = true;
	    }
            // check the home existence
            if (home != new_home)
            {
                if (SCR::Read(.target.dir, new_home ) == nil)
                {
		    if (SCR::Read(.target.size, new_home ) != -1)
		    {
			// error message
			Report::Error(_("The entered path prefix for home is not a directory.
Try again.
"));
			UI::SetFocus(`id(`home));
			ret = `notnext;
			continue;
		    }
		    else
		    {
			// yes/no popup
			if (Popup::YesNo (_("The selected directory does not exist.
Create it now?
")))
			{
			    if (!(boolean)SCR::Execute(.target.mkdir, new_home))
			    {
		                // error popup message
				Report::Error (sformat (_("Unable to create directory '%1'."), new_home));
				UI::SetFocus (`id(`home));
				ret = `notnext;
				continue;
			    }
			}
			else
			{
			    UI::SetFocus (`id(`home));
			    ret = `notnext;
			    continue;
			}
		    }
                }
                modified = true;
            }
            // check the shell existence
            if (shell != new_shell)
            {
                if (! contains (available_shells, new_shell))
                {
                    // Yes-No popup
                    if (! Popup::YesNo (_("If you select a nonexistent shell, the user
may be unable to log in. Continue?
")))
		    {
			ret = `notnext;
                        continue;
		    }
                }
                modified = true;
            }
            // check the skeleton existence
            if (skel != new_skel)
            {
                if (SCR::Read(.target.dir, new_skel ) == nil)
                {
                    Report::Error(_("The entered home directory skeleton is not a directory.
Try again.
"));
                    UI::SetFocus(`id(`skel));
		    ret = `notnext;
                    continue;
                }
                modified = true;
            }
            // check the expire date
            if (exp_date != new_exp_date)
            {
                if (new_exp_date != "" && !regexpmatch (new_exp_date,
                    "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
                {
                    // Trannslators: Don't reorder the letters YYYY-MM-DD!!!
                    // The date must stay in this format
                    Popup::Message(_("Expiration date must be in format YYYY-MM-DD"));
                    UI::SetFocus(`id(`exp));
		    ret = `notnext;
                    continue;
                }
                if (new_exp_date == "")
                    new_expire = "";
                else
                {
                    map out = (map) SCR::Execute(.target.bash_output,
                        sformat("date --date='%1 UTC' ", new_exp_date) + "+%s");
                    string seconds_s = deletechars (out["stdout"]:"0", "\n");
                    if (seconds_s != "")
                    {
                        integer days = (tointeger(seconds_s))/ (60*60*24);
                        new_expire = sformat("%1", days);
                    }
                }
                modified = true;
            }
            if (defaultgroup != new_defgroup || inact != new_inact)
                modified = true;
            break;
        }
    }
    if (modified)
    {
        map<string,string> new_defaults = $[
            "home": new_home,
            "shell": new_shell,
            "skel": new_skel,
            "group": sformat ("%1", lookup (
                Users::GetGroupByName (new_defgroup, "local"),"gidnumber",gid)),
            "inactive": sformat("%1", new_inact),
            "expire": new_expire,
	    "groups": new_grouplist
        ];
        Users::SetLoginDefaults (new_defaults, new_defgroup);
    }

    return ret;
}


/**
 * Choosing the user authentization method
 * @return symbol for sequencer
 */
define symbol AuthentizationDialog() ``{

    list<string> configurable = [ "nis", "ldap", "kerberos", "samba" ];

    list<string> available = [];
    list<string> installed = [];
    list mb = [];

    map to_string = $[
        // just the name (do not translate)
        "nis"   : _("&NIS"),
        // just the name (do not translate)
        "nisplus"   : _("N&IS+"),
        // just the name (do not translate)
        "ldap"  : _("&LDAP"),
        // just the name (do not translate)
        "kerberos"  : _("&Kerberos"),
        // just the name (do not translate)
        "samba"  : _("&Samba"),
    ];

    // name of module to call
    map call_module = $[
	"samba": "samba-client",
    ];

    /**
     * helper function to get information about authentication from
     * appropriate module
     * @param client
     * @return
     */
    define string get_module_data (string client) ``{

	string ret = "";
	Progress::off();
	if (!contains (installed, client))
	{
	    ret = Summary::NotConfigured();
	}
	else if (client == "ldap")
	{
	    Ldap::Read();
	    ret = Ldap::ShortSummary();
	}
	else if (client == "nis")
	{
	    WFM::CallFunction ("nis_auto", ["Read"]);
	    any a = WFM::CallFunction ("nis_auto", ["ShortSummary"]);
	    if (is (a,string))
		ret = (string) a;
	}
	else if (client == "kerberos")
	{
	    WFM::CallFunction ("kerberos-client_auto", ["Read"]);
	    any a = WFM::CallFunction ("kerberos-client_auto",["ShortSummary"]);
	    if (is (a,string))
		ret = (string) a;
	}
	else if (client == "samba")
	{
	    WFM::CallFunction ("samba-client_auto", ["Read"]);
	    any a = WFM::CallFunction ("samba-client_auto", ["ShortSummary"]);
	    if (is (a,string))
		ret = (string) a;
	}
	Progress::on();
	return ret;
    }

    /**
     * Reloads the configuration and updates the auth-widget contents
     */
    define void reload_config() ``{

        string summary = "";
	foreach (string client, available, ``{
	    summary = Summary::AddHeader (summary, sformat (
		"<font color=\"#8BC460\"><a href=\"%1\">%2</a></font>",
		client,
		deletechars (to_string [client]:"", "&")));
	    summary = Summary::AddLine (summary, get_module_data (client));
	});
        UI::ChangeWidget(`id(`summary), `Value, summary);
    }


    foreach (string client, configurable, ``{
	string package = sformat ("yast2-%1-client", client);
        if (Require::IsPackageAvailable (package))
	{
	    available = add (available, client);
	    mb = add (mb, `item(`id(client), to_string[client]:""));
	}
        if (Require::AreAllPackagesInstalled ([package]))
	    installed = add (installed, client);
    });

    term contents = `HBox(
        `HSpacing(4),
        `VBox(
            `VSpacing(0.5),
            `RichText (`id(`summary), ""),
            `VSpacing( 0.5 ),
            // button label
	    `MenuButton(`opt(`key_F4), _("&Configure..."), mb),
            `VSpacing (0.5)
        ),
        `HSpacing(4)
    );

    // dialog title
    string title = _("Authentication and User Data Sources");

    Wizard::SetContentsButtons (title, contents, AuthentizationDialogHelp(),
        Label::BackButton(), Label::OKButton());

    reload_config();

    any button = nil;
    boolean changed = false;
    do
    {
        button = UI::UserInput();
        if (is (button,string) && contains (configurable, (string) button))
        {
	    if (!contains (installed, (string) button))
	    {
		string package = sformat ("yast2-%1-client", button);
		if ( Require::RequireAndConflictTargetButtons ( [package], [],
		    // popup label (%1 is package to install)
		    sformat (_("Package %1 is not installed.
Install it now?
"), package), Label::OKButton(), Label::CancelButton()))
		{
		    installed = add (installed, (string) button);
		}
		else
		{
		    button = `notnext;
		    continue;
		}
	    }
            if (WFM::CallFunction (
		(string)lookup (call_module,button,button), []) == `next)
	    {
		changed = true;
		reload_config ();
		Wizard::DisableBackButton();
	    }
        }
    } while (! (is (button,symbol) &&
	contains ([`next, `abort, `back, `cancel], (symbol) button) ));

    if (changed)
    {
	boolean was_nis_available = Users::NISAvailable ();
	Users::ReadSourcesSettings();
	// enabling NIS could add + lines:
	if (was_nis_available != Users::NISAvailable ())
	{
	    if (Users::NISAvailable ()) // nis enabled now
	    {
		Users::SetPlusPasswd ("+::::::");
		Users::SetPlusGroup ("+:::");
		Users::SetPlusShadow ("+");
	    }
	}
    }
    return (symbol) button;
}


/**
 * Just giving paramaters for commiting user
 * @return symbol for wizard sequencer
 */
define symbol UserSave() ``{

    Users::CommitUser ();
    // adding only one user during install
    if (Mode::cont && Users::StartDialog ("user_add") )
        return `save;
    else
	return `next;
}

/**
 * Check the group parameters and commit it if all is OK
 * @return symbol for wizard sequencer
 */
define symbol GroupSave() ``{

    map <string,any> group = Users::GetCurrentGroup ();
    // do not check group which should be deleted
    if (group["what"]:"" != "delete_group")
    {
	string error = Users::CheckGroup (group);
	if (error != "")
	{
	    Report::Error (error);
	    return `back;
	}
    }
    Users::CommitGroup ();
    return `next;
}

/* EOF */
}
