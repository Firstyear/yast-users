/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

/**
 * Returns a map of LDAP users
 * @param dir directory, where prebuilded map is stored as a file
 */
global define map ReadLDAPUsers(string dir) ``{

    return (SCR::Read(.target.ycp, dir + "/ldap.ycp"));
}

/**
 * Returns a map of LDAP users
 * @param dir directory, where prebuilded map is stored as a file
 */
global define map ReadLDAPUsersByName(string dir) ``{

    return (SCR::Read(.target.ycp, dir + "/ldap_byname.ycp"));
}

/**
 * Returns a map of LDAP groups
 * @param dir directory, where prebuilded map is stored as a file
 */
global define map ReadLDAPGroups(string dir)``{

    return SCR::Read(.target.ycp, dir + "/group_ldap.ycp");
}

/**
 * Returns a map of LDAP groups
 * @param dir directory, where prebuilded map is stored as a file
 */
global define map ReadLDAPGroupsByName(string dir)``{

    return SCR::Read(.target.ycp, dir + "/group_ldap_byname.ycp");
}

/**
 * Writing modified LDAP users with cpu
 * @param ldap_groups map of all ldap groups
 * @param server true if this machine is LDAP server
 * @param dir temporary directory to store config and secret data
 * @param pass bind password to LDAP server
 */
global define boolean WriteLDAPUsers(map ldap_users, boolean server, string dir, string pass)``{

// check for cpu existence ...

    // register agent for manipulating with cpu.cfg
    path agent_path = .etc.cpu_cfg;
    string path_to_cfg = dir + "/cpu.cfg";
    string tmpfile = dir + "/etc_cpu_cfg";
    SCR::Execute(.target.bash, sformat("/bin/cp /etc/cpu.cfg %1", path_to_cfg));

    string agent_data = sformat ("%1

`ag_ini(
  IniAgent(
    \"%2\",
    $[ \"options\" : [ \"ignore_case\", \"global_values\", \"flat\" ],
       \"comments\" : [ \"^#.*\", \"^[ \\t]*$\", ],
       \"params\" : [
		 $[ \"match\" : [ \"^[ \\t]*([^::]*[^ \\t::])[ \\t]*::[ \\t]*(.*[^ \\t]|)[ \\t]*$\" , \"%%s::%%s\"],],
       ]
	]
))", agent_path, path_to_cfg);
    SCR::Write (.target.string, tmpfile, agent_data);
    SCR::RegisterAgent (agent_path, tmpfile);

    // change the cfg file
    string shadow_file = dir + "/shadowfile";
    SCR::Write(.etc.cpu_cfg."shadow_file", shadow_file);
    if (pass != "")
        SCR::Write(.etc.cpu_cfg."bind_pass", pass);

    // save also ldap_host bind_dn, base_dn, user_base etc. !!

    string skel = SCR::Read(.etc.cpu_cfg."skel_dir");
    // other values??

    // save the cfg file
    SCR::Write (.etc.cpu_cfg, "force");

    foreach (`uid, `user, ldap_users, ``{

        integer gid         = user["gid"]:nil; // default values??
        string  username    = user["username"]:"";
        string  org_username = user["org_username"]:username;
        string  forename    = user["forename"]:"";
        string  surname     = user["surname"]:"";
        string  home        = user["home"]:"";
        string  org_home    = user["org_home"]:home;
        string  shell       = user["shell"]:"";
        string  password    = user["password"]:"";
        string  groupname   = user["groupname"]:"";
        symbol  action      = user["modified"]:`nothing;

        if (action == `nothing)
            return;

        string command = "/usr/bin/cpu -v";

        // save password to shadowfile (check the encryption?)
        SCR::Write(.target.string, shadow_file,
            sformat("%1:%2", org_username, password));

        if (action == `added)
        {
            command = sformat (
            "%1 useradd -f %2 -u %3 -g %4 -d %5 -s %6 -S %7",
            command, path_to_cfg, uid, gid, home, shell, username);

            if (forename != "")
                command = command + " -F " + forename;
            if (surname != "")
                command = command + " -L " + surname;

            // on server, we can create the home
            if (server)
            {
                command = sformat("%1; /bin/cp -r %2 %3", command, skel, home);
                command = sformat("%1; /bin/chown -R %2:%3 %4",
                    command, username, groupname, home);
            }
        }
        else if (action == `deleted)
        {
            command = sformat ("%1 userdel -f %2 %3",
                command, path_to_cfg, username);
            if (server && user["delete_home"]:false)
            {
                y2milestone ("The directory %1 is beeing deleted", home);
                command = sformat("%1 ; /bin/rm -rf %2", command, home);
            }
        }
        else if (action == `edited)
        {

            // password for command-line cannot be crypted ??
            command = sformat (
            "%1 usermod -f %2 -u %3 -s %4 -g %5 %6",
            command, path_to_cfg, uid, shell, gid, org_username);

            if (forename != "")
                command = command + " -F " + forename;
            if (surname != "")
                command = command + " -L " + surname;

            if (org_username != username)
                command = sformat ("%1 -l %2", command, username);

            if (server && home != org_home)
            {
                y2milestone ("The directory %1 is moved to %2", org_home, home);
                command = sformat("%1; /bin/mv %2 %3", command, org_home, home);
            }
        }

        SCR::Execute(.target.bash, command);
    });

    // remove the cfg and shadowfile files
    SCR::Execute(.target.bash, "/bin/rm " + path_to_cfg + " " + shadow_file);
    return true;
}

/**
 * Writing modified LDAP groups using cpu
 * @param ldap_groups map of all ldap groups
 * @param dir temporary directory to store config and secret data
 * @param pass bind password to LDAP server
 */
global define boolean WriteLDAPGroups(map ldap_groups, string dir, string pass)``{

    // register agent for manipulating with cpu.cfg
    path agent_path = .etc.cpu_cfg;
    string path_to_cfg = dir + "/cpu.cfg";
    string tmpfile = dir + "/etc_cpu_cfg";
    SCR::Execute(.target.bash, sformat("/bin/cp /etc/cpu.cfg %1", path_to_cfg));

    string agent_data = sformat ("%1

`ag_ini(
  IniAgent(
    \"%2\",
    $[ \"options\" : [ \"ignore_case\", \"global_values\", \"flat\" ],
       \"comments\" : [ \"^#.*\", \"^[ \\t]*$\", ],
       \"params\" : [
		 $[ \"match\" : [ \"^[ \\t]*([^::]*[^ \\t::])[ \\t]*::[ \\t]*(.*[^ \\t]|)[ \\t]*$\" , \"%%s::%%s\"],],
       ]
	]
))", agent_path, path_to_cfg);
    SCR::Write (.target.string, tmpfile, agent_data);
    SCR::RegisterAgent (agent_path, tmpfile);

    if (pass != "")
        SCR::Write(.etc.cpu_cfg."bind_pass", pass);

    // save the cfg file
    SCR::Write (.etc.cpu_cfg, "force");

    foreach (`gid, `group, ldap_groups, ``{

        string  groupname   = group["groupname"]:"";
        string  org_groupname = group["org_groupname"]:groupname;
        symbol  action      = group["modified"]:`nothing;

        if (action == `nothing)
            return;

        if (org_groupname == "")
            org_groupname = groupname;

        string command = "/usr/bin/cpu -v";

        if (action == `added)
        {
            command = sformat (
            "%1 groupadd -f %2 -g %3 %4",
            command, path_to_cfg, gid, groupname);

        }
        else if (action == `deleted)
        {
            command = sformat ("%1 groupdel -f %2 %3",
                command, path_to_cfg, groupname);
        }
        else if (action == `edited)
        {
            command = sformat (
            "%1 groupmod -f %2 -g %3 %4",
            command, path_to_cfg, gid, org_groupname);

            if (org_groupname != groupname)
                command = sformat ("%1 -n %2", command, groupname);
        }

//        y2debug ("command: %1", command);
        SCR::Execute(.target.bash, command);
    });

    // remove the cpu.cfg file
    SCR::Execute(.target.bash, "/bin/rm " + path_to_cfg);
    return true;
}

/**
  * Checks if ldap server is set to localhost
  */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
  * Reads the LDAP base from /etc/openldap/ldap.conf
  */
global define string GetLDAPBase () ``{

    return SCR::Read(.etc.openldap.ldap_conf.base);
}

/**
  * Reads the LDAP host adress from /etc/openldap/ldap.conf
  */
global define string GetLDAPHost () ``{

    return SCR::Read(.etc.openldap.ldap_conf.host);
}

/**
  */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
