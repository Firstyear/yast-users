/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "users";

/**
 * Returns a map of LDAP users
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of users
 */
global define map ReadLDAPUsers(string dir) ``{

    return (SCR::Read(.ldap.users));
}

/**
 * Returns a map of LDAP users
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of users
 */
global define map ReadLDAPUsersByName(string dir) ``{

    return (SCR::Read(.ldap.users.by_name));
}

/**
 * Returns a map of LDAP groups
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of groups
 */
global define map ReadLDAPGroups(string dir)``{

    return (SCR::Read(.ldap.groups));
}

/**
 * Returns a map of LDAP groups
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of groups
 */
global define map ReadLDAPGroupsByName(string dir)``{

    return (SCR::Read(.ldap.groups.by_name));
}

/**
 * Error messages for errors detected during LDAP operation
 * @param type error type: binding/reading/writing
 * @param error name of error (constant from perl-ldap)
 * @return error message
 */
global define string GetLDAPErrorMessage (string type, string error) ``{

    map ldap_error = $[
    "LDAP_INAPPROPRIATE_AUTH":
// original description:
//"The server requires the client which had attempted to bind anonymously or without supplying credentials to provide some form of credentials"

// error message:FIXME
_("Wrong password was entered or anonymous access is restricted."),

    "LDAP_INVALID_CREDENTIALS":
// error message:
_("Wrong password was entered."),

//LDAP_INVALID_SYNTAX
//LDAP_PARAM_ERROR

    "initialize":
// error message:
_("Possible reason: server is down or unreachable."),
    ];

    map error_type = $[
        // error message, more specific description follows
	"init": _("Connection to LDAP server can not be established."),
        // error message, more specific description follows
	"bind":_("There was a problem with connecting to the LDAP server:"),
        // error message, more specific description follows
	"read":_("There was a problem with reading data from the LDAP server:"),
        // error message, more specific description follows
	"users": _("There was a problem with writing LDAP users:"),
        // error message, more specific description follows
	"groups":  _("There was a problem with writing LDAP groups:")];

    return sformat ("%1
%2",
    // default error message (should not be used)
    error_type[type]:_("LDAP error:"), ldap_error[error]:error);

    // TODO: add some "More..." button to show specific error messages
}

/**
 * Gets the bind password to LDAP database
 * @return password
 */
global define string GetLDAPPassword() ``{

    UI::OpenDialog (`opt(`decorated),
        `VBox(
            `HSpacing(40),
            // password entering label
            `Password(`id(`pw), _("&Enter the bind password for LDAP server:")),
            `CheckBox (`id(`anon), `opt(`notify),
                // checkbox label
                _("Use &anonymous Access")),
            `HBox(
              `PushButton (`id(`ok),`opt(`key_F10), UI::OKButtonLabel()),
              `PushButton (`id(`cancel),`opt(`key_F9), UI::CancelButtonLabel())
              // button label
            //  `PushButton (`id(`anon), _("&Anonymous Access")),

            )
            )
    );
    any ret = UI::UserInput();
    string pw = "";
    if (ret == `ok)
        pw = UI::QueryWidget(`id(`pw), `Value);
    if (ret == `cancel)
        pw = nil; // FIXME: do not use nil here!
    UI::CloseDialog();
    return pw;
}


/**
 * read ldap users and groups...
 */
global define string ReadLDAP () ``{

    string ret = SCR::Execute (.ldap.search, $[
	"output_dir": tmpdir,
	"user_filter": "objectClass=person", // FIXME
	"group_filter": "objectClass=posixGroup" ]
    );
    return ret;
}

/**
 * Writing modified LDAP users with
 * @param ldap_users map of all ldap users
 * @param server true if this machine is file for LDAP //FIXME: not here!
 * @return empty string on success, error message otherwise
 */
global define string WriteLDAPUsers(map ldap_users, boolean server) ``{

    string ret = "";

    // TODO: modify shadow settings
    foreach (`uid, `user, ldap_users, ``{

        string  action      = user["modified"]:"no";
        if (action == "no") // TODO || ret != ""
            return;

        string home		= user["home"]:"";
        string org_home		= user["org_home"]:home;
        string username		= user["username"]:"";
        string groupname	= user["groupname"]:"";
	string command		= "";
	string ldap_ret = "";

        if (action == "added")
        {
	    ldap_ret = SCR::Write (.ldap.add, user);
            // on server, we can create the home
            if (server)
            {
		// FIXME: skeleton is missing!
                command = sformat("/bin/cp -r %1 %2", skel, home);
                command = sformat("%1; /bin/chown -R %2:%3 %4", command,
		    username, groupname, home);
            }
        }
        else if (action == "deleted")
        {
	    ldap_ret = SCR::Write (.ldap.delete, user);
            if (server && user["delete_home"]:false)
            {
                y2milestone ("The directory %1 is deleted", home);
                command = sformat("/bin/rm -rf %1", home);
            }
        }
        else if (action == "edited")
        {
	    ldap_ret = SCR::Write (.ldap.modify, user);

            if (server && home != org_home)
            {
                y2milestone ("The directory %1 is moved to %2", org_home, home);
                command = sformat("/bin/mv %1 %2", org_home, home);
            }
        }
	if (ldap_ret != "")
	{
	    ret = GetLDAPErrorMessage ("users", ldap_ret);
	}
	else if (command != "")
	{
	    // FIXME: directory operation in Write, together with local users
	    map out = SCR::Execute(.target.bash_output, command);
	    if (out["stderr"]:"" != "")
		y2error ("error calling %1: %2", command, out["stderr"]:"");
	}
    });
    return ret;
}

/**
 * Writing modified LDAP groups
 * @param ldap_groups map of all ldap groups
 * @return empty string on success, error message otherwise
 */
global define string WriteLDAPGroups(map ldap_groups)``{

    string ret = "";

    foreach (`gid, `group, ldap_groups, ``{

        string action = group["modified"]:"no";
        if (action == "no")
	{
            return;
	}
	string ldap_ret = "";

        if (action == "added")
        {
	    ldap_ret = SCR::Write (.ldap.group.add, group);
        }
        else if (action == "deleted")
        {
	    ldap_ret = SCR::Write (.ldap.group.delete, group);
        }
        else if (action == "edited")
        {
	    ldap_ret = SCR::Write (.ldap.group.modify, group);
        }
	if (ldap_ret != "")
	{
	    ret = GetLDAPErrorMessage ("groups", ldap_ret);
	    //FIXME: this is last error message!
	}
    });
    return ret;
}

/**
 * Checks if ldap server is set to localhost
 * @param host adress of LDAP server
 * @return result
 */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
 * Reads the LDAP base from /etc/openldap/ldap.conf
 * @return LDAP base
 */
global define string GetLDAPBase () ``{

    return SCR::Read(.etc.openldap.ldap_conf.base);
}

/**
 * Reads the LDAP host adress from /etc/openldap/ldap.conf
 * @return host adress
 */
global define string GetLDAPHost () ``{

    return SCR::Read(.etc.openldap.ldap_conf.host);
}

/**
 * Checks the user sources for presence of "ldap"
 * @param passwd_source the list of sources (e.g. ["compat", "ldap"])
 * @return result
 */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
