/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Important! It is supposed that this file is included from Users.ycp,
 * some variables are used from here...
 */

{

textdomain "users";

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsers() ``{

    return SCR::Read(.ldap.users);
}

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsersByName() ``{

    return (SCR::Read(.ldap.users.by_name));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroups()``{

    return (SCR::Read(.ldap.groups));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroupsByName()``{

    return (SCR::Read(.ldap.groups.by_name));
}

/**
 * Error popup for errors detected during LDAP operation
 * @param type error type: binding/reading/writing
 * @param error name of error (constant from perl-ldap)
 */
global define void LDAPErrorMessage (string type, string error) ``{

    map ldap_error = $[
// error message:
    "LDAP_INAPPROPRIATE_AUTH": _("
The server requires the client which had
attempted to bind anonymously or without
supplying credentials to provide some form
of credentials"),

    "LDAP_INVALID_CREDENTIALS":
// error message:
_("
Wrong password was entered."),

    "LDAP_INVALID_SYNTAX":
// error message:
_("
Some part of the request contained an invalid
syntax. It could be a search with an invalid
filter or a request to modify the schema
and the given schema has a bad syntax."),

    "LDAP_PARAM_ERROR":
// error message:
_("
An invalid parameter was specified.
Maybe search filter has invalid syntax?"),

    "LDAP_NO_SUCH_ATTRIBUTE":
// error message:
_("
The request referenced an attribute
that does not exist."),

    "LDAP_NO_SUCH_OBJECT":
// error message:
_("
The server cannot find an object
specified in the request."),

    "BAD_FILTER_USER":
// error message, %1 is string with "filter":
sformat (_("
Bad search filter (probably wrong syntax):
%1"), (ldap_user_filter != "") ? ldap_user_filter: ldap_default_user_filter),

    "BAD_FILTER_GROUP":
// error message, %1 is string with "filter":
sformat (_("
Bad search filter (probably wrong syntax):
%1"), (ldap_group_filter != "") ? ldap_group_filter: ldap_default_group_filter),

    // when anonymous is set, bind is OK, but writing not!!!
    "LDAP_STRONG_AUTH_REQUIRED":

// error message:
_("
The server requires authentication
be performed with a SASL mechanism."),

// FIXME: LDAP_ALREADY_EXISTS -> two users with the different case

    "initialize":
// error message:
_("
Server could be down or unreachable."),
    ];

    map error_type = $[
        // error message, more specific description follows
	"init": _("Connection to LDAP server can not be established."),
        // error message, more specific description follows
	"bind": _("Problem with connecting to the LDAP server."),
        // error message, more specific description follows
	"read": _("Problem with reading data from the LDAP server."),
        // error message, more specific description follows
	"users": _("There was a problem with writing LDAP users."),
        // error message, more specific description follows
	"groups": _("There was a problem with writing LDAP groups.")
    ];

    if (error == nil) error = "YaST error?";

    UI::OpenDialog (`HBox(`HSpacing (0.5),
	`VBox(
	    `VSpacing (0.5),
	    // label
	    `Left(`Heading (_("Error"))),
	    `Label (error_type[type]:_("Unknown LDAP error")),
	    `ReplacePoint (`id(`rp), `Empty()),
	    `VSpacing (0.5),
	    // checkbox label
	    `Left(`CheckBox (`id(`details), `opt (`notify),_("&Show Details"), false)),
	    `PushButton (`id(`ok), `opt(`key_F10,`default), UI::OKButtonLabel())
	),
	`HSpacing(0.5))
    );
    any ret = nil;
    do
    {
	ret = UI::UserInput();
	if (ret == `details)
	{
	    if (UI::QueryWidget (`id(`details), `Value))
		UI::ReplaceWidget (`id(`rp), `VBox (
		    `Label (ldap_error[error]:error)));
		    // TODO: richtext instead of Label?
	    else
		UI::ReplaceWidget (`id(`rp), `Empty());
	}
    }
    while (ret != `ok && ret != `cancel);

    UI::CloseDialog();
}

/**
 * Read user and group filter for LDAP search
 * (must be done before selecting LDAP users/groups to load)
 */
global define void ReadLDAPFilters() ``{

    import "Ldap";
    Ldap::Read();

    // not configurable, default until change in Ldap module
    ldap_default_user_filter	= Ldap::user_filter;
    ldap_default_group_filter	= Ldap::group_filter;

    ldap_filters_read = true;
}

/**
 * Read basic settings about LDAP
 */
global define void ReadLDAPSettings () ``{

    if (!ldap_filters_read)
	ReadLDAPFilters();

    ldap_user_base	= Ldap::user_base;
    ldap_group_base	= Ldap::group_base;
    ldap_host		= Ldap::server;
    is_ldap_server	= IsLDAPServer (ldap_host);
    ldap_file_server	= Ldap::file_server;
    ldap_version	= Ldap::ldap_v2 ? 2 : 3;
    ldap_encryption	= Ldap::pam_password;
    ldap_bind_dn	= Ldap::bind_dn;
    ldap_user_class	= splitstring (Ldap::user_class, ",");
    ldap_group_class	= splitstring (Ldap::group_class, ",");
    ldap_shadow		= $[];// FIXME Ldap::GetDefaultShadow();
    ldap_defaults	= $[ "skel": default_skel,
			     "home": "/local/home/",
			     "group": "100",
			     "shell":  default_shell ];//Ldap::GetUserDefaults
    ldap_default_groupname = "users";//FIXME ReadDefaultGroup?
//    ldap_port		= Ldap::port;// FIXME not present
}

/**
 * Initializes the LDAP settings
 * @return error message or empty string on success
 */
global define string LDAPInit () ``{

    map ldap = $[
	"host":		ldap_host,
	"port":		ldap_port
    ];
    string ret = SCR::Execute (.ldap.init, ldap);
    ldap = $[
        "user_base":	ldap_user_base,
        "group_base":	ldap_group_base,
	"user_class":	ldap_user_class,
	"group_class":	ldap_group_class,
	"version":	ldap_version,
	"bind_dn":	ldap_bind_dn,
	"pw_hash":	toupper (ldap_encryption) // TODO is toupper needed?
    ];
    SCR::Execute (.ldap.users.init, ldap);
    return ret;
}


/**
 * Tries to bind to LDAP server with current password
 * @param pass password
 * @return error message or empty string on success
 */
global define string LDAPBind (string pass) ``{

    string ret = "";
    if (pass != nil)
    {
	if (ldap_anonymous)
	    ret = SCR::Execute (.ldap.bind);
	else
	    ret = SCR::Execute (.ldap.bind, pass);
    }
    return ret;
}


/**
 * do the LDAP search command; check the search filters before
 */
global define string ReadLDAP () ``{

    string ret = "error";

    string user_filter = (ldap_user_filter != "") ?
	    ldap_user_filter: ldap_default_user_filter;
    string group_filter = (ldap_group_filter != "") ?
	    ldap_group_filter: ldap_default_group_filter;

    ret = SCR::Read(.ldap.filter.check, user_filter);
    if (ret != "") return ret+"_USER";

    ret = SCR::Read(.ldap.filter.check, group_filter);
    if (ret != "") return ret+"_GROUP";

    ret = SCR::Execute (.ldap.users.search, $[
	"output_dir":	tmpdir,
	"user_filter":	user_filter,
	"group_filter":	group_filter
    ]);
    return ret;
}


/**
 * Gets the bind password to LDAP database
 * @return password
 */
global define string GetLDAPPassword() ``{

    UI::OpenDialog (`opt(`decorated),
        `VBox(
            `HSpacing(40),
            // password entering label
            `Password(`id(`pw), _("&Enter the Password for LDAP Server:")),
            `CheckBox (`id(`anon), `opt(`notify),
                // checkbox label
                _("Use &Anonymous Access")),
            `HBox(
              `PushButton (`id(`ok),`opt(`key_F10), UI::OKButtonLabel()),
              `PushButton (`id(`cancel),`opt(`key_F9), UI::CancelButtonLabel())
              // button label
            //  `PushButton (`id(`anon), _("&Anonymous Access")),

            )
            )
    );
    any ret = UI::UserInput();
    string pw = "";
    if (ret == `ok)
    {
        pw = UI::QueryWidget(`id(`pw), `Value);
	ldap_anonymous = false;
    }
    else if (ret == `cancel)
        pw = nil;
    else ldap_anonymous = true;
    UI::CloseDialog();
    return pw;
}

/**
 * Asks for LDAP password and tries to bind with it
 * @return password entered, nil on cancel
 */
global define string LDAPAskAndBind () ``{

    string pw = GetLDAPPassword();
    if (pw != nil)
    {
	string ldap_msg = LDAPBind(pw);
	while (pw != nil && ldap_msg != "")
	{
	    LDAPErrorMessage ("bind", ldap_msg);
	    pw = GetLDAPPassword();
	    ldap_msg = LDAPBind(pw);
	}
    }
    return pw;
}

/**
 * Writing modified LDAP users with
 * @param ldap_users map of all ldap users
 * @param server true if this machine is file for LDAP
 * @return empty string on success, error message otherwise
 */
global define string WriteLDAPUsers(map ldap_users, boolean server) ``{

    string ret = "";

    foreach (`uid, `user, ldap_users, ``{

        string  action      = user["modified"]:"no";
        if (action == "no") // TODO || ret != ""
            return;

        string home		= user["home"]:"";
        string org_home		= user["org_home"]:home;
        integer gid		= user["gid"]:default_gid;
	string ldap_ret = "";

        if (action == "added")
        {
	    ldap_ret = SCR::Write (.ldap.user.add, user);
            // on server, we can modify homes
            if (server && ldap_ret == "")
            {
		if (user["create_home"]:false)
		    CreateHome (ldap_defaults["skel"]:default_skel, home);
		ChownHome (uid, gid, home);
            }
        }
        else if (action == "deleted")
        {
	    ldap_ret = SCR::Write (.ldap.user.delete, user);
            if (server && user["delete_home"]:false && ldap_ret == "")
            {
                DeleteHome (home);
            }
        }
        else if (action == "edited")
        {
	    ldap_ret = SCR::Write (.ldap.user.modify, user);
            if (server && home != org_home && ldap_ret == "")
            {
		if (user["create_home"]:false)
		    MoveHome (org_home, home);
		ChownHome (uid, gid, home);
            }
        }
	if (ldap_ret != "")
	{
	    ret = ldap_ret;
	}
    });
    return ret;
}

/**
 * Writing modified LDAP groups
 * @param ldap_groups map of all ldap groups
 * @return empty string on success, error message otherwise
 */
global define string WriteLDAPGroups(map ldap_groups)``{

    string ret = "";

    foreach (`gid, `group, ldap_groups, ``{

        string action = group["modified"]:"no";
        if (action == "no")
	{
            return;
	}
	string ldap_ret = "";

        if (action == "added")
        {
	    ldap_ret = SCR::Write (.ldap.group.add, group);
        }
        else if (action == "deleted")
        {
	    ldap_ret = SCR::Write (.ldap.group.delete, group);
        }
        else if (action == "edited")
        {
	    ldap_ret = SCR::Write (.ldap.group.modify, group);
        }
	if (ldap_ret != "")
	{
	    ret = ldap_ret;
	}
    });
    return ret;
}

/**
 * Checks if ldap server is set to localhost
 * @param host adress of LDAP server
 * @return result
 */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
 * Checks the user sources for presence of "ldap"
 * @param passwd_source the list of sources (e.g. ["compat", "ldap"])
 * @return result
 */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
