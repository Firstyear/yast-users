/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Important! It is supposed that this file is included from Users.ycp,
 * some variables are used from here... (every ldap_*)
 */

{

import "Label";
import "Users";
import "UsersCache";

textdomain "users";

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsers() ``{

    return SCR::Read(.ldap.users);
}

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsersByName() ``{

    return (SCR::Read(.ldap.users.by_name));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroups()``{

    return (SCR::Read(.ldap.groups));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroupsByName()``{

    return (SCR::Read(.ldap.groups.by_name));
}

/**
 * Initializes LDAP connection and reads users and groups configuration
 */
global define boolean InitializeLDAP () ``{

    import "Ldap";
    Ldap::Read();

    string ldap_mesg = Ldap::LDAPInit ();
    if ( ldap_mesg != "")
    {
	Ldap::LDAPErrorMessage("init", ldap_mesg);
	return false;
    }
    if (Ldap::bind_pass == nil && !Ldap::anonymous)
    {
	Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
    }
    if (Ldap::bind_pass == nil)
	return false; //canceled

    Ldap::InitSchema ();

    foreach (`dn, `config_module, Ldap::ReadConfigModules (), ``{
	if (contains (config_module["objectClass"]:[], "userConfiguration"))
	{
	    Users::ldap_user_config_dn = dn;
	    Users::ldap_user_config = config_module;
	}
	if (contains (config_module["objectClass"]:[], "groupConfiguration"))
	{
	    Users::ldap_group_config_dn = dn;
	    Users::ldap_group_config = config_module;
	}
    });
    list user_templates = Users::ldap_user_config["defaultTemplate"]:[];
    list group_templates = Users::ldap_group_config["defaultTemplate"]:[];
    string user_template = user_templates[0]:"";
    string group_template = group_templates[0]:"";

    // read only one default template
    if (size (user_templates) > 1 || size (group_templates) > 1)
    {
	term rbu_buttons = `VBox( `Left(`Label (_("User Templates"))));
	term rbg_buttons = `VBox( `Left(`Label (_("Group Templates"))));
	foreach (`templ, user_templates, ``{
	    rbu_buttons = add (rbu_buttons,
		`Left(`RadioButton (`id(templ), templ, true)));
	});
	foreach (`templ, group_templates, ``{
	    rbg_buttons = add (rbg_buttons,
		`Left(`RadioButton (`id(templ), templ, true)));
	});
	term rb_users = `RadioButtonGroup (`id(`rbu), rbu_buttons);
	term rb_groups = `RadioButtonGroup (`id(`rbg), rbg_buttons);

	UI::OpenDialog (`opt(`decorated), `HBox (`HSpacing (1),
        `VBox(
            `HSpacing(50),
	    `VSpacing (0.5),
	    // label
            `Label (_("There are more templates defined as default, please choose which one should be read.")),
	    `VSpacing (0.5),
	    user_templates == [] ? `Empty(): rb_users,
	    `VSpacing (0.5),
	    group_templates == [] ? `Empty() : rb_groups,
            `HBox(
              `PushButton (`id(`ok),`opt(`key_F10, `default),
		Label::OKButton()),
              // button label
              `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton())
            )),
	`HSpacing (1))
	);
	any ret = UI::UserInput();
	if (ret == `ok)
	{
	    if (user_templates != [])
		user_template = UI::QueryWidget (`id(`rbu), `CurrentButton);
	    if (group_templates != [])
		group_template = UI::QueryWidget (`id(`rbg), `CurrentButton);
	}
	UI::CloseDialog();
    }
    Users::ldap_user_template = Ldap::ConvertDefaultValues (
	Ldap::GetLDAPEntry (user_template));
    Users::ldap_group_template = Ldap::ConvertDefaultValues (
	Ldap::GetLDAPEntry (group_template));
    ldap_initialized = true;
    return true;
}


/**
 * Read user and group filter needed LDAP search
 * Fiters are read from config modules stored in LDAP directory
 */
global define boolean ReadLDAPFilters() ``{

    boolean init = true;

    if (!ldap_initialized)
	init = InitializeLDAP();

    if (!init)
	return false;
    // get the default filters from config modules (already read)
    ldap_default_user_filter	=
	ldap_user_config["searchFilter",0]:ldap_default_user_filter;
    ldap_default_group_filter	=
	ldap_group_config["searchFilter",0]:ldap_default_group_filter;

    ldap_filters_read = true;
    return true;
}

/**
 * Get first value from dn (e.g. "cn" or "uid")
 */
global define string get_first (string dn) ``{

    list dn_list = splitstring (dn, ",");
    return substring (dn_list[0]:"", find (dn_list[0]:"", "=")+1);
}

/**
 * Read settings from LDAP users and groups configuration
 * ("config modules", configurable by ldap-client)
 */
global define boolean ReadLDAPSettings () ``{

    boolean init = true;

    if (!ldap_filters_read)
	init = ReadLDAPFilters();
    if (!init)
	return false;

    // currently not used for anything
    is_ldap_server	= IsLDAPServer (Ldap::GetFirstServer (Ldap::server));

    ldap_file_server	= Ldap::file_server;

    map user_config	= Users::ldap_user_config;
    map user_template	= Users::ldap_user_template;
    map group_config	= Users::ldap_group_config;
    map group_template	= Users::ldap_group_template;

    // every time take the first value from the list...
    ldap_user_base	= user_config ["defaultBase",0]:Ldap::nss_base_passwd;
    if (ldap_user_base == "")
	ldap_user_base = Ldap::GetDomain();
    ldap_encryption	= user_config ["passwordHash",0]:Ldap::pam_password;
    ldap_user_class	= user_template ["defaultObjectClass"]:ldap_user_class;

    ldap_group_base	= group_config ["defaultBase",0]:Ldap::nss_base_group;
    if (ldap_group_base == "")
	ldap_group_base = ldap_user_base;
    ldap_group_class	= group_template["defaultObjectClass"]:ldap_group_class;

    map user_defaults = user_template["default_values"]:$[];
    map group_defaults = group_template["default_values"]:$[];

    Users::ldap_user_defaults = user_defaults;
    Users::ldap_group_defaults = group_defaults;
    // default shadow (for new users)
    ldap_shadow		= $[
	"shadowWarning"		: user_defaults ["shadowWarning"]:"",
	"shadowInactive"	: user_defaults ["shadowInactive"]:"",
	"shadowExpire"		: user_defaults ["shadowExpire"]:"0",
	"shadowMin"		: user_defaults ["shadowMin"]:"",
	"shadowMax"		: user_defaults ["shadowMax"]:"",
    ];
    // other defaults (for new users)
    ldap_defaults	= $[
	"skel": user_config ["skelDir",0]:Users::default_skel,
	"home": user_defaults ["homeDirectory"]:
	    Users::GetDefaultHome(false,"local"),
	"group": user_defaults["gidNumber"]:sformat ("%1",Users::default_gid),
	"shell": user_defaults["loginShell"]:Users::GetDefaultShell("local"),
    ];

    // password length (there is no check if it is correct for curr. encryption)
    if (user_config ["minPasswordLength"]:[] != [])
	Users::pass_length ["ldap", "min"] =
	    tointeger (user_config ["minPasswordLength",0]:"5");
    if (user_config ["maxPasswordLength"]:"" != "")
	Users::pass_length ["ldap", "max"] =
	    tointeger (user_config ["maxPasswordLength",0]:"8");

    // set default secondary groups
    // WARNING: there are DN's, but we expect only names...
    string grouplist = Users::ldap_default_grouplist;
    foreach (`dn, user_template ["secondaryGroup"]:[], ``{
	if (grouplist != "")
	    grouplist = grouplist + ",";
	grouplist = grouplist + get_first (dn);
    });
    Users::ldap_default_grouplist = grouplist;

    // last used Id
    if (user_config ["nextUniqueId"]:[] != [])
	Users::ldap_last_uid = tointeger (user_config ["nextUniqueId",0]:"500");
    else
	Users::ldap_last_uid = UsersCache::last_uid["local"]:500;
    UsersCache::last_uid ["ldap"] = Users::ldap_last_uid;

    if (group_config ["nextUniqueId"]:[] != [])
	Users::ldap_last_gid = tointeger (group_config["nextUniqueId",0]:"500");
    else
	Users::ldap_last_gid = UsersCache::last_gid["local"]:500;
    UsersCache::last_gid ["ldap"] = Users::ldap_last_gid;

    // naming attributes
    Users::ldap_user_naming_attr = user_template ["namingAttribute",0]:
	Users::ldap_user_naming_attr;
    Users::ldap_group_naming_attr = group_template ["namingAttribute",0]:
	Users::ldap_group_naming_attr;

    // max id
    if (user_config ["maxUniqueId"]:[] != [])
    {
	Users::max_uid ["ldap"] = tointeger (
	    user_config ["maxUniqueId",0]:"60000");
    }
    if (group_config ["maxUniqueId"]:[] != [])
    {
	Users::max_gid ["ldap"] = tointeger (
	    group_config ["maxUniqueId",0]:"60000");
    }
    UsersCache::max_uid = Users::max_uid;
    UsersCache::max_gid = Users::max_gid;

    // min id
    if (user_config ["minUniqueId"]:[] != [])
    {
	Users::min_uid ["ldap"] = tointeger (
	    user_config ["minUniqueId",0]:"60000");
    }
    if (group_config ["minUniqueId"]:[] != [])
    {
	Users::min_gid ["ldap"] = tointeger (
	    group_config ["minUniqueId",0]:"60000");
    }
    UsersCache::min_uid = Users::min_uid;
    UsersCache::min_gid = Users::min_gid;

    //FIXME only crypt works?
    ldap_encryption	= user_config ["passwordHash",0]:Ldap::pam_password;
    if (ldap_encryption == "")
	ldap_encryption = "crypt"; // same as "des"

    return true;
}


/**
 * do the LDAP search command; check the search filters before
 */
global define string ReadLDAP () ``{

    string ret = "";

    string user_filter = (ldap_user_filter != "") ?
	    ldap_user_filter: ldap_default_user_filter;
    string group_filter = (ldap_group_filter != "") ?
	    ldap_group_filter: ldap_default_group_filter;

    list ldap_user_attrs = []; // TODO use allowed/required attrs from config?
    // if yes, objectClass must be in required!
    list ldap_group_attrs = [];

    if (!SCR::Execute (.ldap.users.search, $[
	"user_base"	: ldap_user_base,
	"group_base"	: ldap_group_base,
	"user_filter"	: user_filter,
	"group_filter"	: group_filter,
	"user_scope"	: 2,//sub
	"group_scope"	: 2,
	"user_attrs"	: ldap_user_attrs,
	"group_attrs"	: ldap_group_attrs,
	"itemlists"	: true
	 ]))
	ret = Ldap::LDAPError();

    return ret;
}

/**
 * Convert internal map describing user to map that could be passed to
 * ldap-agent (remove internal keys, rename attributes etc.)
 * @param user map of user
 * @param attributes list of attributes allowed for this user (according to its
 *	objectClass values)
 * @return converted map
 */
global define map ConvertUserToLDAP (map user, list attributes) ``{

    map ret = $[];
    foreach (`key, `value, user, ``{
	any val = value;
	if (contains (user_internal_keys, key))
	    return;
	if (is (value, string) && value == "")
	    return;
	if (key == "password")
	{
	    if  (contains (["x","*","!"], value))
		return;
	    if (ldap_encryption != "clear")
		val = sformat ("{%1}%2", toupper (ldap_encryption), value);
	}

	if (is (value, integer))
	    val = sformat ("%1", value);
	if (is (value, map))
	{
	    foreach (`k, `v, ConvertUserToLDAP (value, attributes), ``{
		ret = add (ret, k, v);
	    });
	}
	else
	{
	    // check if the attributes are allowed by objectClass
	    string attr = Users::ldap_attrs_conversion [key]:key;
	    if (!contains (attributes, attr))
	    {
		y2warning ("attribute %1 is not allowed by schema", attr);
		return;
	    }
	    ret = add (ret, attr, val);
	}
    });
    return ret;
}

/**
 * Convert internal map describing group to map that could be passed to
 * ldap-agent (remove internal keys, rename attributes etc.)
 * @param group map of group
 * @param attributes list of attributes allowed for this group (according to its
 *	objectClass values)
 * @return converted map
 */
global define map ConvertGroupToLDAP (map group, list attributes) ``{

    map ret = $[];
    list to_list = [ "userlist" ];

    foreach (`key, `value, group, ``{
	any val = value;
	if (contains (group_internal_keys, key))
	    return;
	if (is (value, string) && value == "")
	    return;
	if (key == "password")
	{
	    if (contains (["x","*","!"], value))
		return;
	    if (ldap_encryption != "clear")
		val = sformat ("{%1}%2", ldap_encryption, value);
	}
	if (is (value, integer))
	    val = sformat ("%1", value);
	if (contains (to_list, key))
	    val = splitstring (value, ",");
	// check if the attributes are allowed by objectClass
	string attr = Users::ldap_attrs_conversion [key]:key;
	if (!contains (attributes, attr))
	{
	    y2warning ("attribute %1 is not allowed by schema", attr);
	    return;
	}
	ret = add (ret, attr, val);
    });
    return ret;
}

/**
 * Writing modified LDAP users with
 * @param ldap_users map of all ldap users
 * @param server true if this machine is file for LDAP
 * @return empty map on success, map with error message and code otherwise
 */
global define map WriteLDAPUsers(map ldap_users, boolean server) ``{

    map ret = $[];
    string dn_attr = Users::ldap_user_naming_attr;
    integer last_uid = Users::ldap_last_uid;

    foreach (`uid, `user, ldap_users, ``{

        string  action      = user["modified"]:"no";
        if (action == "no" || ret != $[])
            return; // return on first error
        string home		= user["home"]:"";
        string org_home		= user["org_home"]:home;
        integer gid		= user["gid"]:default_gid;
	boolean create_home	= user["create_home"]:false;
	boolean delete_home	= user["delete_home"]:false;

	// old DN stored from ldap-search (removed in Convert)
	string dn		= user["dn"]:"";
	string org_dn		= user["org_dn"]:dn;
	list object_classes	= user["objectClass"]:[];
	if (object_classes == [])
	    object_classes	= ldap_user_class;
	user			= ConvertUserToLDAP (user,
	    Ldap::GetObjectAttributes (object_classes));
	string rdn	= sformat ("%1=%2", dn_attr, user[dn_attr]:"");
	string new_dn	= sformat ("%1,%2", rdn, ldap_user_base);
	map arg_map	= $[ "dn": (org_dn != "")? org_dn: new_dn ];

        if (action == "added")
        {
	    if (! SCR::Write (.ldap.add, arg_map, user))
		ret = Ldap::LDAPErrorMap();
            // on server, we can modify homes
            else
	    {
		if (uid > last_uid)
		    last_uid = uid;
		if (server)
		{
		    if (create_home)
			CreateHome (ldap_defaults["skel"]:default_skel, home);
		    ChownHome (uid, gid, home);
		}
	    }
        }
        else if (action == "deleted")
        {
	    if (! SCR::Write (.ldap.delete, arg_map))
		ret = Ldap::LDAPErrorMap();
            else if (server && delete_home)
            {
                DeleteHome (home);
            }
        }
        else if (action == "edited")
        {
	    // DN doesn't differ in case
	    if (tolower (dn) != tolower (org_dn))
		arg_map = add (arg_map, "rdn", rdn);
		// TODO enable moving in tree (editing the whole dn)
	    if (! SCR::Write (.ldap.modify, arg_map, user))
		ret = Ldap::LDAPErrorMap();
	    else
	    {
		if (server && home != org_home)
		{
		    if (create_home)
			MoveHome (org_home, home);
		    ChownHome (uid, gid, home);
		}
            }
        }
    });
    if (last_uid != Users::ldap_last_uid && Users::ldap_user_config_dn != "")
    {
	// set nextUniqueId in user config module
	map user_config = Users::ldap_user_config;
	user_config ["nextUniqueId"]	= [ sformat ("%1", last_uid) ];
	user_config ["modified"]	= "edited";
	map modules = $[];
	modules [Users::ldap_user_config_dn] = user_config;
        ret = Ldap::WriteToLDAP (modules);
    }
    return ret;
}

/**
 * Writing modified LDAP groups
 * @param ldap_groups map of all ldap groups
 * @return empty map on success, map with error message and code otherwise
 */
global define map WriteLDAPGroups(map ldap_groups)``{

    map ret = $[];
    string dn_attr = Users::ldap_group_naming_attr;
    integer last_gid = Users::ldap_last_gid;

    foreach (`gid, `group, ldap_groups, ``{

        string action = group["modified"]:"no";
        if (action == "no" || ret != $[])
	{
            return;
	}
	map new_group		= $[];
	// old DN stored from ldap-search (removed in Convert)
	string dn		= group["dn"]:"";
	string org_dn		= group["org_dn"]:dn;
	list object_classes	= group["objectClass"]:[];
	if (object_classes == [])
	    object_classes	= ldap_group_class;

	// if there is no member of the group, group must be changed
	// to namedObject
	if (group["uniqueMember"]:[] == [])
	{
	    if (action == "added" || action == "edited")
	    {
		object_classes	= filter (`cl, object_classes,
		    ``(cl != "groupOfUniqueNames"));
		object_classes	= union (object_classes,["namedObject"]);
		group ["objectClass"] = object_classes;
	    }
	    if (action == "edited")
	    {
		// delete old group and create new with altered objectClass
		new_group	= eval (group);
		action		= "deleted";
	    }
	}
	// we are adding users to empty group (=namedObject):
	// group must be changed to groupOfUniqueNames
	else if (!contains (object_classes, "groupOfUniqueNames") &&
		 action == "edited")
	{
	    // delete old group...
	    action = "deleted";
	    // ... and create new one with altered objectClass
	    object_classes	= filter (`cl, object_classes,
		``(cl != "namedObject"));
	    object_classes	= union (object_classes,["groupOfUniqueNames"]);
	    new_group		= eval (group);
	    new_group ["objectClass"]	= object_classes;
	}
	group		= ConvertGroupToLDAP (group,
	    Ldap::GetObjectAttributes (object_classes));

	string rdn	= sformat ("%1=%2", dn_attr, group[dn_attr]:"");
	string new_dn	= sformat ("%1,%2", rdn, ldap_group_base);
	map arg_map	= $[ "dn": (org_dn != "")? org_dn: new_dn ];
        if (action == "added")
        {
	    if (! SCR::Write (.ldap.add, arg_map, group))
		ret = Ldap::LDAPErrorMap();
	    else if (gid > last_gid)
		last_gid = gid;
        }
        else if (action == "deleted")
        {
	    if (! SCR::Write (.ldap.delete, arg_map))
		ret = Ldap::LDAPErrorMap();
        }
        else if (action == "edited")
        {
	    if (tolower (dn) != tolower (org_dn))
		arg_map = add (arg_map, "rdn", rdn);
	    if (! SCR::Write (.ldap.modify, arg_map, group))
		ret = Ldap::LDAPErrorMap();
	    else if (gid > last_gid)
		last_gid = gid;
        }
	if (new_group != $[] && ret == $[])
	{
	    // now add new group with modified objectClass
	    if (tolower (dn) != tolower (org_dn))
		arg_map ["dn"] = dn;
	    object_classes	= new_group["objectClass"]:[];
	    new_group		= ConvertGroupToLDAP (new_group,
		Ldap::GetObjectAttributes (object_classes));
	    if (! SCR::Write (.ldap.add, arg_map, new_group))
		ret = Ldap::LDAPErrorMap();
	    else if (gid > last_gid)
		last_gid = gid;
	}
    });
    if (last_gid != Users::ldap_last_gid && Users::ldap_group_config_dn != "")
    {
	// set nextUniqueId in group config module
	map group_config = Users::ldap_group_config;
	group_config ["nextUniqueId"]	= [ sformat ("%1", last_gid) ];
	group_config ["modified"]	= "edited";
	map modules = $[];
	modules [Users::ldap_group_config_dn] = group_config;
        ret = Ldap::WriteToLDAP (modules);
    }
    return ret;
}

/**
 * Checks if ldap server is set to localhost
 * @param host adress of LDAP server
 * @return result
 */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
 * Checks the user sources for presence of "ldap"
 * @param passwd_source the list of sources (e.g. ["compat", "ldap"])
 * @return result
 */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
