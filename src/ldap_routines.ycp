/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Important! It is supposed that this file is included from Users.ycp,
 * some variables are used from here... (every ldap_*)
 */

{

import "Label";
import "Users";

textdomain "users";

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsers() ``{

    return SCR::Read(.ldap.users);
}

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsersByName() ``{

    return (SCR::Read(.ldap.users.by_name));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroups()``{

    return (SCR::Read(.ldap.groups));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroupsByName()``{

    return (SCR::Read(.ldap.groups.by_name));
}

/**
 * Initializes LDAP connection and reads users and groups configuration
 */
global define boolean InitializeLDAP () ``{

    import "Ldap";
    Ldap::Read();

    string ldap_mesg = Ldap::LDAPInit ();
    if ( ldap_mesg != "")
    {
	Ldap::LDAPErrorMessage("init", ldap_mesg);
	return false;
    }
    if (Ldap::bind_pass == nil && !Ldap::anonymous)
    {
	Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
    }
    if (Ldap::bind_pass == nil)
	return false; //canceled

    Ldap::InitSchema ();

    foreach (`dn, `config_module, Ldap::ReadConfigModules (), ``{
	if (contains (config_module["objectClass"]:[], "userConfiguration"))
	    Users::ldap_user_config = config_module;
	if (contains (config_module["objectClass"]:[], "groupConfiguration"))
	    Users::ldap_group_config = config_module;
    });

    foreach (`dn, `template, Ldap::ReadTemplates (), ``{
	if (contains (template["objectClass"]:[], "userTemplate"))
	    Users::ldap_user_template = template;
	if (contains (template["objectClass"]:[], "groupTemplate"))
	    Users::ldap_group_template = template;
    });
    ldap_initialized = true;
    return true;
}


/**
 * Read user and group filter needed LDAP search
 * Fiters are read from config modules stored in LDAP directory
 */
global define boolean ReadLDAPFilters() ``{

    boolean init = true;

    if (!ldap_initialized)
	init = InitializeLDAP();

    if (!init)
	return false;
    // get the default filters from config modules (already read)
    ldap_default_user_filter	=
	ldap_user_config["searchFilter",0]:ldap_default_user_filter;
    ldap_default_group_filter	=
	ldap_group_config["searchFilter",0]:ldap_default_group_filter;

    ldap_filters_read = true;
    return true;
}

/**
 * Get first value from dn (it is assumed to be "cn")
 */
global define string get_first (string dn) ``{

    list dn_list = splitstring (dn, ",");
    return substring (dn_list[0]:"", find (dn_list[0]:"", "=")+1);
}

/**
 * Read basic settings about LDAP
 */
global define void ReadLDAPSettings () ``{

    if (!ldap_filters_read)
	ReadLDAPFilters();

    // currently not used for anything
    is_ldap_server	= IsLDAPServer (Ldap::GetFirstServer (Ldap::server));

    ldap_file_server	= Ldap::file_server;

    map user_config	= Users::ldap_user_config;
    map user_template	= Users::ldap_user_template;
    map group_config	= Users::ldap_group_config;
    map group_template	= Users::ldap_group_template;

    // every time take the first value from the list...
    ldap_user_base	= user_config ["defaultBase",0]:Ldap::nss_base_passwd;
    if (ldap_user_base == "")
	ldap_user_base = Ldap::GetDomain();
    ldap_encryption	= user_config ["passwordHash",0]:Ldap::pam_password;
    ldap_user_class	= user_template ["defaultObjectClass"]:ldap_user_class;

    ldap_group_base	= group_config ["defaultBase",0]:Ldap::nss_base_group;
    if (ldap_group_base == "")
	ldap_group_base = ldap_user_base;
    ldap_group_class	= group_template["defaultObjectClass"]:ldap_group_class;

    map user_defaults = listmap (`value, user_template["defaultValue"]:[], ``{
	list line = splitstring (value, "=");
	return [line[0]:"", line[1]:""];
    });
    // default shadow (for new users)
    ldap_shadow		= $[
	"shadowWarning"		: user_defaults ["shadowWarning"]:"",
	"shadowInactive"	: user_defaults ["shadowInactive"]:"",
	"shadowExpire"		: user_defaults ["shadowExpire"]:"0",
	"shadowMin"		: user_defaults ["shadowMin"]:"",
	"shadowMax"		: user_defaults ["shadowMax"]:"",
    ];
    // other defaults (for new users)
    ldap_defaults	= $[
	"skel": user_config ["skelDir",0]:Users::default_skel,
	"home": user_defaults ["homeDirectory"]:Users::GetDefaultHome(false,"local"),
	"group": user_defaults["gidNumber"]:Users::GetDefaultGid(false,"local"),
	"shell": user_defaults["loginShell"]:Users::GetDefaultShell("local"),
    ];

    // TODO password length -> PE dialog has to be marked "local/system only"
    // *UniqueId

    // set default secondary groups
    // FIXME there are DN's, but we expect only names...
    string grouplist = Users::ldap_default_grouplist;
    foreach (`dn, user_template ["secondaryGroup"]:[], ``{
	if (grouplist != "")
	    grouplist = grouplist + ",";
	grouplist = grouplist + get_first (dn);
    });
    Users::ldap_default_grouplist = grouplist;

    ldap_default_groupname = "users";
    //FIXME ReadDefaultGroup - use ldap_defaults [gidNumber...

    //FIXME only crypt works?
    ldap_encryption	= user_config ["passwordHash",0]:Ldap::pam_password;
}


/**
 * do the LDAP search command; check the search filters before
 */
global define string ReadLDAP () ``{

    string ret = "";

    string user_filter = (ldap_user_filter != "") ?
	    ldap_user_filter: ldap_default_user_filter;
    string group_filter = (ldap_group_filter != "") ?
	    ldap_group_filter: ldap_default_group_filter;

    list ldap_user_attrs = []; // TODO use allowed/required attrs from config?
    // if yes, objectClass must be in required!
    list ldap_group_attrs = [];

    if (!SCR::Execute (.ldap.users.search, $[
	"user_base"	: ldap_user_base,
	"group_base"	: ldap_group_base,
	"user_filter"	: user_filter,
	"group_filter"	: group_filter,
	"user_scope"	: 2,//sub
	"group_scope"	: 2,
	"user_attrs"	: ldap_user_attrs,
	"group_attrs"	: ldap_group_attrs,
	"itemlists"	: true
	 ]))
	ret = Ldap::LDAPError();

    return ret;
}

global define map ConvertUserToLDAP (map user) ``{

    map ret = $[];
    foreach (`key, `value, user, ``{
	any val = value;
	if (contains (user_internal_keys, key))
	    return;
	if (is (value, string) && value == "")
	    return;
	if (key == "password")
	{
	    if  (contains (["x","*","!"], value))
		return;
	    val = sformat ("{%1}%2", ldap_encryption, value);
	}

	if (is (value, integer))
	    val = sformat ("%1", value);
	if (is (value, map))
	{
	    foreach (`k, `v, ConvertUserToLDAP (value), ``{
		ret = add (ret, k, v);
	    });
	}
	else
	    ret = add (ret, ldap_param_conv[key]:key, val);
    });
    return ret;
}

global define map ConvertGroupToLDAP (map group) ``{

    map ret = $[];
    list to_list = [ "userlist" ];

    foreach (`key, `value, group, ``{
	any val = value;
	if (contains (group_internal_keys, key))
	    return;
	if (is (value, string) && value == "")
	    return;
	if (key == "password")
	{
	    if (contains (["x","*","!"], value))
		return;
	    val = sformat ("{%1}%2", ldap_encryption, value);
	}
	if (is (value, integer))
	    val = sformat ("%1", value);
	if (contains (to_list, key))
	    val = splitstring (value, ",");
	ret = add (ret, ldap_param_conv[key]:key, val);
    });
    return ret;
}

/**
 * Writing modified LDAP users with
 * @param ldap_users map of all ldap users
 * @param server true if this machine is file for LDAP
 * @return empty map on success, map with error message and code otherwise
 */
global define map WriteLDAPUsers(map ldap_users, boolean server) ``{

    map ret = $[];
    string dn_attr = "uid"; // TODO naming_attribute

    foreach (`uid, `user, ldap_users, ``{

        string  action      = user["modified"]:"no";
        if (action == "no" || ret != $[])
            return;

        string home		= user["home"]:"";
        string org_home		= user["org_home"]:home;
        integer gid		= user["gid"]:default_gid;
	boolean create_home	= user["create_home"]:false;
	boolean delete_home	= user["delete_home"]:false;

	// old DN stored from ldap-search (removed in Convert)
	string dn	= user["dn"]:"";
	user		= ConvertUserToLDAP (user);
	string rdn	= sformat ("%1=%2", dn_attr, user[dn_attr]:"");
	// TODO is it OK to create dn?
	string new_dn	= sformat ("%1,%2", rdn, ldap_user_base);
	map arg_map	= $[ "dn": (dn != "")? dn: new_dn ];
	if (user["objectClass"]:[] == [])
	    user	= add (user, "objectClass", ldap_user_class);

        if (action == "added")
        {
	    if (! SCR::Write (.ldap.add, arg_map, user))
		ret = Ldap::LDAPErrorMap();
            // on server, we can modify homes
            else if (server)
            {
		if (create_home)
		    CreateHome (ldap_defaults["skel"]:default_skel, home);
		ChownHome (uid, gid, home);
            }
        }
        else if (action == "deleted")
        {
	    if (! SCR::Write (.ldap.delete, arg_map))
		ret = Ldap::LDAPErrorMap();
            else if (server && delete_home)
            {
                DeleteHome (home);
            }
        }
        else if (action == "edited")
        {
	    // DN doesn't differ in case
	    if (tolower (dn) != tolower (new_dn))
		arg_map = add (arg_map, "rdn", rdn);
		// TODO enable moving in tree (editing the whole dn)
	    if (! SCR::Write (.ldap.modify, arg_map, user))
		ret = Ldap::LDAPErrorMap();
            else if (server && home != org_home)
            {
		if (create_home)
		    MoveHome (org_home, home);
		ChownHome (uid, gid, home);
            }
        }
	// TODO: cummulate error messages?
    });
    return ret;
}

/**
 * Writing modified LDAP groups
 * @param ldap_groups map of all ldap groups
 * @return empty map on success, map with error message and code otherwise
 */
global define map WriteLDAPGroups(map ldap_groups)``{

    map ret = $[];
    string dn_attr = "cn"; //Ldap::group_naming_attribute

    foreach (`gid, `group, ldap_groups, ``{

        string action = group["modified"]:"no";
        if (action == "no" || ret != $[])
	{
            return;
	}
	string dn	= group["dn"]:"";
	// old DN stored from ldap-search (removed in Convert)
	group		= ConvertGroupToLDAP (group);
	string rdn	= sformat ("%1=%2", dn_attr, group[dn_attr]:"");
	string new_dn	= sformat ("%1,%2", rdn, ldap_group_base);
	map arg_map	= $[ "dn": (dn != "")? dn: new_dn ];
	if (group["objectClass"]:[] == [])
	    group	= add (group, "objectClass", ldap_group_class);

        if (action == "added")
        {
	    if (! SCR::Write (.ldap.add, arg_map, group))
		ret = Ldap::LDAPErrorMap();
        }
        else if (action == "deleted")
        {
	    if (! SCR::Write (.ldap.delete, arg_map))
		ret = Ldap::LDAPErrorMap();
        }
        else if (action == "edited")
        {
	    if (tolower (dn) != tolower (new_dn))
		arg_map = add (arg_map, "rdn", rdn);
	    if (! SCR::Write (.ldap.modify, arg_map, group))
		ret = Ldap::LDAPErrorMap();
        }
    });
    return ret;
}

/**
 * Checks if ldap server is set to localhost
 * @param host adress of LDAP server
 * @return result
 */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
 * Checks the user sources for presence of "ldap"
 * @param passwd_source the list of sources (e.g. ["compat", "ldap"])
 * @return result
 */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
