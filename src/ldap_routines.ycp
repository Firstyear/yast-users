/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Important! It is supposed that this file is included from Users.ycp,
 * some variables are used from here...
 */

{

import "Label";

textdomain "users";

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsers() ``{

    return SCR::Read(.ldap.users);
}

/**
 * Returns a map of LDAP users
 * @return map of users
 */
global define map ReadLDAPUsersByName() ``{

    return (SCR::Read(.ldap.users.by_name));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroups()``{

    return (SCR::Read(.ldap.groups));
}

/**
 * Returns a map of LDAP groups
 * @return map of groups
 */
global define map ReadLDAPGroupsByName()``{

    return (SCR::Read(.ldap.groups.by_name));
}

/**
 * Read user and group filter for LDAP search
 * (must be done before selecting LDAP users/groups to load)
 */
global define void ReadLDAPFilters() ``{

// TODO - read config maps with some ReadConfig,ReadTemplate...
// FIXME: read filters from server on demand...

    import "Ldap";
    Ldap::Read();
    /*
    map ldap_config_modules = Ldap::ReadConfigModules ();
    map ldap_templates = Ldap::ReadTemplates ();
    */

    // not configurable, default until change in Ldap module
    ldap_default_user_filter	= "objectClass=posixAccount";//TODO: check maps
    ldap_default_group_filter	= "objectClass=posixGroup";

    ldap_filters_read = true;
}

/**
 * Read basic settings about LDAP
 */
global define void ReadLDAPSettings () ``{

    if (!ldap_filters_read)
	ReadLDAPFilters();

// TODO - read config maps with some ReadConfig,ReadTemplate...
    ldap_user_base	= Ldap::user_base;
    ldap_group_base	= Ldap::group_base;
    ldap_host		= Ldap::GetFirstServer (Ldap::server);
    is_ldap_server	= IsLDAPServer (ldap_host);
    ldap_file_server	= Ldap::file_server;
    ldap_version	= Ldap::ldap_v2 ? 2 : 3;
    ldap_encryption	= Ldap::pam_password;//FIXME only crypt works?
    ldap_bind_dn	= Ldap::bind_dn;
    ldap_user_class	= ["top", "posixAccount", "inetOrgPerson" ];
    ldap_group_class	= [ "top", "posixGroup" ]; //TODO check maps from LDAP
    ldap_shadow		= $[];// FIXME Ldap::GetDefaultShadow();
    ldap_defaults	= $[ "skel": default_skel,
			     "home": "/local/home/",
			     "group": "100",
			     "shell":  default_shell ];//Ldap::GetUserDefaults
    ldap_default_groupname = "users";//FIXME ReadDefaultGroup?
    ldap_port		= Ldap::GetFirstPort (Ldap::server);
}

global define string LDAPError () ``{

    map err_map = LDAPErrorMap ();
    return err_map["msg"]:"";
}

global define map LDAPErrorMap () ``{

    return SCR::Read(.ldap.error);
}


/**
 * Initializes the LDAP settings
 * @return error message or empty string on success
 */
global define string LDAPInit () ``{

    string ret = "";
    map ldap = $[
	"hostname":	ldap_host,
	"port":		ldap_port,
	"version":	ldap_version
    ];
    if (!SCR::Execute (.ldap, ldap))
	ret = LDAPError();
    return ret;
}

// TODO: use Ldap:: functions?

/**
 * Tries to bind to LDAP server with current password
 * @param pass password
 * @return error message or empty string on success
 */
global define string LDAPBind (string pass) ``{

    string ret = "";
    if (pass != nil)
    {
	map args = $[];
	if (!ldap_anonymous)
	    args = $[ "bind_dn": ldap_bind_dn, "bind_pw": pass];
	if (!SCR::Execute (.ldap.bind, args))
	    ret = LDAPError();
    }
    return ret;
}


/**
 * do the LDAP search command; check the search filters before
 */
global define string ReadLDAP () ``{

    string ret = "";

    string user_filter = (ldap_user_filter != "") ?
	    ldap_user_filter: ldap_default_user_filter;
    string group_filter = (ldap_group_filter != "") ?
	    ldap_group_filter: ldap_default_group_filter;

    // TODO where to get attributes?
    list ldap_user_attrs = [
	// posixaccount
	"uid", "uidNumber", "gidNumber", "homeDirectory",
	"loginShell", "cn",
	// inetorgperson:
	 "mail", "sn", "givenName", "gecos",
	 "homePhone", "telephoneNumber", "roomNumber",
	 // shadowaccount
	"shadowLastChange", "shadowWarning", "shadowInactive",
	"shadowExpire", "shadowMin", "shadowMax"];
    list ldap_group_attrs = [ "cn", "gidNumber", "memberUid" ];

    if (!SCR::Execute (.ldap.users.search, $[
	"user_base"	: ldap_user_base,
	"group_base"	: ldap_group_base,
	"user_filter"	: user_filter,
	"group_filter"	: group_filter,
	"user_scope"	: 2,// TODO Ldap::user_scope,
	"group_scope"	: 2, //Ldap::group_scope,
	"user_attrs"	: ldap_user_attrs,
	"group_attrs"	: ldap_group_attrs,
	"itemlists"	: true
	 ]))
	ret = LDAPError();

    return ret;
}


/**
 * Gets the bind password to LDAP database
 * @return password
 */
global define string GetLDAPPassword() ``{

    UI::OpenDialog (`opt(`decorated),
        `VBox(
            `HSpacing(40),
            // password entering label
            `Password(`id(`pw), _("&Enter the Password for LDAP Server:")),
            `HBox(
              `PushButton (`id(`ok),`opt(`key_F10, `default),
		Label::OKButton()),
              // button label
	      `PushButton (`id(`anon), `opt(`key_F6), _("&Anonymous Access")),
              `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton())
            )
        )
    );
    UI::SetFocus (`id(`pw));
    any ret = UI::UserInput();
    string pw = "";
    if (ret == `ok)
    {
        pw = UI::QueryWidget(`id(`pw), `Value);
	ldap_anonymous = false;
    }
    else if (ret == `cancel)
        pw = nil;
    else ldap_anonymous = true;
    UI::CloseDialog();
    return pw;
}

/**
 * Asks for LDAP password and tries to bind with it
 * @return password entered, nil on cancel
 */
global define string LDAPAskAndBind () ``{

    string pw = GetLDAPPassword();
    if (pw != nil)
    {
	string ldap_msg = LDAPBind(pw);
	while (pw != nil && ldap_msg != "")
	{
	    Ldap::LDAPErrorMessage ("bind", ldap_msg);
	    pw = GetLDAPPassword();
	    ldap_msg = LDAPBind(pw);
	}
    }
    return pw;
}

global define map ConvertUserToLDAP (map user) ``{

    map ret = $[];
    foreach (`key, `value, user, ``{
	any val = value;
	if (contains (user_internal_keys, key))
	    return;
	if (is (value, string) && value == "")
	    return;
	if (key == "password")
	{
	    if  (contains (["x","*","!"], value))
		return;
	    val = sformat ("{%1}%2", ldap_encryption, value);
	}

	if (is (value, integer))
	    val = sformat ("%1", value);
	if (is (value, map))
	{
	    foreach (`k, `v, ConvertUserToLDAP (value), ``{
		ret = add (ret, k, v);
	    });
	}
	else
	    ret = add (ret, ldap_param_conv[key]:key, val);
    });
    return ret;
}

global define map ConvertGroupToLDAP (map group) ``{

    map ret = $[];
    list to_list = [ "userlist" ];

    foreach (`key, `value, group, ``{
	any val = value;
	if (contains (group_internal_keys, key))
	    return;
	if (is (value, string) && value == "")
	    return;
	if (key == "password")
	{
	    if (contains (["x","*","!"], value))
		return;
	    val = sformat ("{%1}%2", ldap_encryption, value);
	}
	if (is (value, integer))
	    val = sformat ("%1", value);
	if (contains (to_list, key))
	    val = splitstring (value, ",");
	ret = add (ret, ldap_param_conv[key]:key, val);
    });
    return ret;
}

/**
 * Writing modified LDAP users with
 * @param ldap_users map of all ldap users
 * @param server true if this machine is file for LDAP
 * @return empty map on success, map with error message and code otherwise
 */
global define map WriteLDAPUsers(map ldap_users, boolean server) ``{

    map ret = $[];
    string dn_attr = "uid"; // TODO naming_attribute

    foreach (`uid, `user, ldap_users, ``{

        string  action      = user["modified"]:"no";
        if (action == "no" || ret != $[])
            return;

        string home		= user["home"]:"";
        string org_home		= user["org_home"]:home;
        integer gid		= user["gid"]:default_gid;
	boolean create_home	= user["create_home"]:false;
	boolean delete_home	= user["delete_home"]:false;

	// old DN stored from ldap-search (removed in Convert)
	string dn	= user["dn"]:"";
	user		= ConvertUserToLDAP (user);
	string rdn	= sformat ("%1=%2", dn_attr, user[dn_attr]:"");
	// TODO is it OK to create dn?
	string new_dn	= sformat ("%1,%2", rdn, ldap_user_base);
	map arg_map	= $[ "dn": (dn != "")? dn: new_dn ];
	if (user["objectClass"]:[] == [])
	    user	= add (user, "objectClass", ldap_user_class);

        if (action == "added")
        {
	    if (! SCR::Write (.ldap.add, arg_map, user))
		ret = LDAPErrorMap();
            // on server, we can modify homes
            else if (server)
            {
		if (create_home)
		    CreateHome (ldap_defaults["skel"]:default_skel, home);
		ChownHome (uid, gid, home);
            }
        }
        else if (action == "deleted")
        {
	    if (! SCR::Write (.ldap.delete, arg_map))
		ret = LDAPErrorMap();
            else if (server && delete_home)
            {
                DeleteHome (home);
            }
        }
        else if (action == "edited")
        {
	    if (dn != new_dn)
{
y2internal ("dn: %1, new_dn: %2", dn, new_dn);
		arg_map = add (arg_map, "rdn", rdn);
		// TODO enable moving in tree (editing the rest of dn)
}
	    if (! SCR::Write (.ldap.modify, arg_map, user))
		ret = LDAPErrorMap();
            else if (server && home != org_home)
            {
		if (create_home)
		    MoveHome (org_home, home);
		ChownHome (uid, gid, home);
            }
        }
	// TODO: cummulate error messages?
    });
    return ret;
}

/**
 * Writing modified LDAP groups
 * @param ldap_groups map of all ldap groups
 * @return empty map on success, map with error message and code otherwise
 */
global define map WriteLDAPGroups(map ldap_groups)``{

    map ret = $[];
    string dn_attr = "cn"; //Ldap::group_naming_attribute

    foreach (`gid, `group, ldap_groups, ``{

        string action = group["modified"]:"no";
        if (action == "no" || ret != $[])
	{
            return;
	}
	string dn	= group["dn"]:"";
	// old DN stored from ldap-search (removed in Convert)
	group		= ConvertGroupToLDAP (group);
	string rdn	= sformat ("%1=%2", dn_attr, group[dn_attr]:"");
	string new_dn	= sformat ("%1,%2", rdn, ldap_group_base);
	map arg_map	= $[ "dn": (dn != "")? dn: new_dn ];
	if (group["objectClass"]:[] == [])
	    group	= add (group, "objectClass", ldap_group_class);

        if (action == "added")
        {
	    if (! SCR::Write (.ldap.add, arg_map, group))
		ret = LDAPError();
        }
        else if (action == "deleted")
        {
	    if (! SCR::Write (.ldap.delete, arg_map))
		ret = LDAPError();
        }
        else if (action == "edited")
        {
	    if (dn != new_dn)
		arg_map = add (arg_map, "rdn", rdn);
	    if (! SCR::Write (.ldap.modify, arg_map, group))
		ret = LDAPError();
        }
    });
    return ret;
}

/**
 * Checks if ldap server is set to localhost
 * @param host adress of LDAP server
 * @return result
 */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
 * Checks the user sources for presence of "ldap"
 * @param passwd_source the list of sources (e.g. ["compat", "ldap"])
 * @return result
 */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
