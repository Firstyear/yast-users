/**
 * File:	include/users/ldap_routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	LDAP users manipulation routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "users";

/**
 * Returns a map of LDAP users
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of users
 */
global define map ReadLDAPUsers(string dir) ``{

    return (SCR::Read(.target.ycp, dir + "/ldap.ycp"));
}

/**
 * Returns a map of LDAP users
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of users
 */
global define map ReadLDAPUsersByName(string dir) ``{

    return (SCR::Read(.target.ycp, dir + "/ldap_byname.ycp"));
}

/**
 * Returns a map of LDAP groups
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of groups
 */
global define map ReadLDAPGroups(string dir)``{

    return SCR::Read(.target.ycp, dir + "/group_ldap.ycp");
}

/**
 * Returns a map of LDAP groups
 * @param dir directory, where prebuilded map is stored as a file
 * @return map of groups
 */
global define map ReadLDAPGroupsByName(string dir)``{

    return SCR::Read(.target.ycp, dir + "/group_ldap_byname.ycp");
}

/**
 * Tries to check, if cpu.cfg is configured or just installed with default
 * values
 * @param host LDAP server
 * @param base LDAP base
 * @return answer
 */
global define boolean CpuConfigured (string host, string base) ``{

    string cpu_userbase = SCR::Read(.etc.cpu_cfg."user_base");
    string cpu_basedn = SCR::Read(.etc.cpu_cfg."base_dn");
    string cpu_host = SCR::Read(.etc.cpu_cfg."ldap_host");
    // check if cpu.cfg is configured -- maybe compare times?
    return (cpu_host == host || cpu_basedn == base || cpu_userbase == base);
}


/**
 * Prepare the configuration file for LDAP users/groups modifications
 * @param dir temporary directory to store config and secret data
 * @param pass LDAP bind password
 * @return true
 */
global define boolean WriteLDAPPrepare (string dir, string pass)``{

    // register agent for manipulating with temporary changed cpu.cfg
    path agent_path = .tmp.cpu_cfg;
    string path_to_cfg = dir + "/cpu.cfg";
    string tmpfile = dir + "/etc_cpu_cfg";
    SCR::Execute(.target.bash, sformat("/bin/cp /etc/cpu.cfg %1", path_to_cfg));

    string agent_data = sformat ("%1

`ag_ini(
  IniAgent(
    \"%2\",
    $[ \"options\" : [ \"ignore_case\", \"global_values\", \"flat\" ],
       \"comments\" : [ \"^#.*\", \"^[ \\t]*$\", ],
       \"params\" : [
		 $[ \"match\" : [ \"^[ \\t]*([^::]*[^ \\t::])[ \\t]*::[ \\t]*(.*[^ \\t]|)[ \\t]*$\" , \"%%s::%%s\"],],
       ]
	]
))", agent_path, path_to_cfg);
    SCR::Write (.target.string, tmpfile, agent_data);
    SCR::RegisterAgent (agent_path, tmpfile);

    // change the cfg file
    SCR::Write(.tmp.cpu_cfg."shadow_file", dir + "/shadowfile");
    if (pass != "" && pass != nil)
        SCR::Write(.tmp.cpu_cfg."bind_pass", pass);

    // save the cfg file now
    SCR::Write (.tmp.cpu_cfg, "force");
}

/**
 * Gets the bind password to LDAP database
 * @return password
 */
global define string GetLDAPPassword() ``{

    UI::OpenDialog (`opt(`decorated),
        `VBox(
            `HSpacing(36),
            // password entering label
            `Password(`id(`pw), _("&Enter the bind password for LDAP server:")),
            `CheckBox (`id(`anon), `opt(`notify),
                // checkbox label
                _("Use &anonymous Access")),
            `PushButton (`id(`ok),`opt(`key_F10), UI::OKButtonLabel())
            )
    );
    any ret = UI::UserInput();
    string pw = "";
    if (ret == `ok)
        pw = UI::QueryWidget(`id(`pw), `Value);
    UI::CloseDialog();
    return pw;
}


/**
 * Remove the configuration file used for LDAP users/groups modifications
 * @param dir temporary directory with config and secret data files
 * @return success
 */
global define boolean WriteLDAPFinish (string dir) ``{

    // remove the cfg and shadowfile files
    string path_to_cfg = dir + "/cpu.cfg";
    string shadow_file = dir + "/shadowfile";
    return SCR::Execute(.target.bash_output,
        "/bin/rm -f " + path_to_cfg + " " + shadow_file);
}

/**
 * Writing modified LDAP users with cpu
 * @param ldap_users map of all ldap users
 * @param server true if this machine is LDAP server
 * @param dir temporary directory to store config and secret data
 * @return true
 */
global define boolean WriteLDAPUsers(map ldap_users, boolean server, string dir)``{

    string shadow_file = dir + "/shadowfile";
    string path_to_cfg = dir + "/cpu.cfg";
    string skel = SCR::Read(.tmp.cpu_cfg."skel_dir");

    foreach (`uid, `user, ldap_users, ``{

        symbol  action      = user["modified"]:`nothing;
        if (action == `nothing)
            return;

        integer gid         = user["gid"]:nil; // default values??
        string  username    = user["username"]:"";
        string  org_username = user["org_username"]:username;
        string  forename    = user["forename"]:"";
        string  surname     = user["surname"]:"";
        string  fullname    = user["fullname"]:"";
        string  home        = user["home"]:"";
        string  org_home    = user["org_home"]:home;
        string  shell       = user["shell"]:"";
        string  password    = user["password"]:"";
        string  groupname   = user["groupname"]:"";
        string  email       = user["email"]:"";

        string command = "/usr/bin/cpu -v";

        // save password to shadowfile (check the encryption?)
        SCR::Write(.target.string, shadow_file,
            sformat("%1:%2", org_username, password));

        if (action == `added)
        {
            command = sformat (
            "%1 useradd -f %2 -u %3 -g %4 -d %5 -s %6 -S %7",
            command, path_to_cfg, uid, gid, home, shell, username);

            if (forename != "")
                command = command + " -F " + forename;
            if (surname != "")
                command = command + " -L " + surname;
            if (fullname != "")
                command = command + " -c " + fullname;
            if (email != "")
                command = command + " -M " + email;

            // on server, we can create the home
            if (server)
            {
                command = sformat("%1; /bin/cp -r %2 %3", command, skel, home);
                command = sformat("%1; /bin/chown -R %2:%3 %4",
                command, username, groupname, home);
            }
        }
        else if (action == `deleted)
        {
            command = sformat ("%1 userdel -f %2 %3",
                command, path_to_cfg, username);
            if (server && user["delete_home"]:false)
            {
                y2milestone ("The directory %1 is beeing deleted", home);
                command = sformat("%1 ; /bin/rm -rf %2", command, home);
            }
        }
        else if (action == `edited)
        {

            // password for command-line cannot be crypted ??
            // FIXME -S works as "do not change password" !!
            command = sformat (
            "%1 usermod -f %2 -u %3 -s %4 -g %5 %6 -S",
            command, path_to_cfg, uid, shell, gid, org_username);

            if (forename != "")
                command = command + " -F " + forename;
            if (surname != "")
                command = command + " -L " + surname;
            if (fullname != "")
                command = command + " -c " + fullname;
            if (email != "")
                command = command + " -M " + email;

            if (org_username != username)
                command = sformat ("%1 -l %2", command, username);

            if (server && home != org_home)
            {
                y2milestone ("The directory %1 is moved to %2", org_home, home);
                command = sformat("%1; /bin/mv %2 %3", command, org_home, home);
            }
        }
        y2debug ("cpu: %1",
            SCR::Execute(.target.bash_output, command));
    });
    return true; // TODO check for success
}

/**
 * Writing modified LDAP groups using cpu
 * @param ldap_groups map of all ldap groups
 * @param dir temporary directory to store config and secret data
 * @return true
 */
global define boolean WriteLDAPGroups(map ldap_groups, string dir)``{

    string path_to_cfg = dir + "/cpu.cfg";

    foreach (`gid, `group, ldap_groups, ``{

        string  groupname   = group["groupname"]:"";
        string  org_groupname = group["org_groupname"]:groupname;
        symbol  action      = group["modified"]:`nothing;

        if (action == `nothing)
            return;

        if (org_groupname == "")
            org_groupname = groupname;

        string command = "/usr/bin/cpu";

        if (action == `added)
        {
            command = sformat (
            "%1 groupadd -f %2 -g %3 %4",
            command, path_to_cfg, gid, groupname);

        }
        else if (action == `deleted)
        {
            command = sformat ("%1 groupdel -f %2 %3",
                command, path_to_cfg, groupname);
        }
        else if (action == `edited)
        {
            command = sformat (
            "%1 groupmod -f %2 -g %3 %4",
            command, path_to_cfg, gid, org_groupname);

            if (org_groupname != groupname)
                command = sformat ("%1 -n %2", command, groupname);
        }

        y2debug ("cpu: %1",
            SCR::Execute(.target.bash_output, command));
    });

    return true;
}

/**
 * Checks if ldap server is set to localhost
 * @param host adress of LDAP server
 * @return result
 */
global define boolean IsLDAPServer (string host) ``{

    if (host == "localhost" || host == "127.0.0.1")
        return true;
    return false;
}

/**
 * Reads the LDAP base from /etc/openldap/ldap.conf
 * @return LDAP base
 */
global define string GetLDAPBase () ``{

    return SCR::Read(.etc.openldap.ldap_conf.base);
}

/**
 * Reads the LDAP host adress from /etc/openldap/ldap.conf
 * @return host adress
 */
global define string GetLDAPHost () ``{

    return SCR::Read(.etc.openldap.ldap_conf.host);
}

/**
 * Checks the user sources for presence of "ldap"
 * @param passwd_source the list of sources (e.g. ["compat", "ldap"])
 * @return result
 */
global define boolean IsLDAPAvailable (list passwd_source) ``{

    if ( contains (passwd_source, "ldap"))
        return true;
    else
        return false;
}


}
