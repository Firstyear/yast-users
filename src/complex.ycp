/**
 * File:	include/users/complex.ycp
 * Package:	Configuration of users and groups
 * Summary:	Dialogs definitions
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *		Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "users";

import "Wizard";
import "Mode";
import "Report";
import "Security";
import "Autologin";

import "Users";
import "UsersCache";

import "Popup";
import "Label";

include "users/helps.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
define boolean Modified() ``{
    return Users::Modified () || Autologin::modified;
}


/**
 * Read settings dialog
 * @param useUI boolean use user interface (change progress bar)
 * @return symbol `next if success, else `abort
 */
define symbol ReadDialog (boolean useUI ) ``{

    // Set help text
    if ( useUI ) Wizard::RestoreHelp ( ReadDialogHelp () );

    // A callback function for abort
    block<boolean> abort = ``{
        return UI::PollInput () == `abort;
    };

    /*
    symbol ret = Users::Read (abort, useUI);
    return ret; FIXME
    */
    symbol ret = Users::Read () ? `next : `back;
y2internal ("term: %1", Users::GetTerm ());
    return ret;
}

/**
 * Write settings dialog
 * @param useUI boolean use user interface (change progress bar)
 * @return symbol `next if success, else `abort
 */
define symbol WriteDialog (boolean useUI ) ``{

    // Set help text
    if ( useUI ) Wizard::RestoreHelp ( WriteDialogHelp () );

    // A callback function for abort
    block<boolean> abort = ``{
        // popup text
        if (UI::PollInput () == `abort && Popup::YesNo (_("Really abort the writing process?")))
            return true;
        return false;
    };
//    return Users::Write(abort, useUI);
    return Users::Write () == "" ? `next : `abort;
}

/**
 * Set the module to normal setup mode
 * @return symbol for wizard sequencer
 */
define symbol userSetup () ``{
    Users::SetStartDialog ("users") ;
    return `next;
}

/**
 * Set the module into installation mode with
 * first dialog for single user addition
 * @return symbol for wizard sequencer
 */
define symbol usersInstStart () ``{
    Users::SetStartDialog ("user_add") ;
    Users::AddUser ($[]);
    return `next;
}


/**
 * The dialog that appears when the [Abort] button is pressed.
 * @return `abort if user really wants to abort
 */
define symbol ReallyAbort() ``{

    boolean ret = true;

    if ( ! Mode::cont )
    {
        ret = Popup::ReallyAbort (Modified());
    }
    else
    {
        ret = Popup::ConfirmAbort (`incomplete);
    }

    if( ret )
    {
        return `abort;
    }
    else return `back;
}

/**
 * Popup for configuration user/group filter for making the LDAP search
 * @return modified?
 */
define boolean LDAPSearchFilterPopup () ``{

    /* FIXME

    string default_user_f = Users::ldap_default_user_filter;
    string default_group_f = Users::ldap_default_group_filter;

    string user_f = Users::ldap_user_filter;
    string group_f = Users::ldap_group_filter;

    if (user_f == "")
	user_f = default_user_f;
    if (group_f == "")
	group_f = default_group_f;

    boolean ret = false;

    string help_text = LDAPSearchFilterPopupHelp();

    UI::OpenDialog(`opt(`decorated), `HBox(`HSpacing(1.5),
        `VBox(
            `HSpacing(50),
            `VSpacing(0.5),
	        `Frame(_("Filter for Searching the LDAP Directory"), `HBox(
		  `HSpacing (0.5),
		  `VBox(
		    `VSpacing(0.5),
		    // textentry label
		    `TextEntry (`id(`userf), _("&User Filter"), user_f),
		    `VSpacing(0.5),
		    // textentry label
		    `TextEntry (`id(`groupf), _("&Group Filter"), group_f),
		    `VSpacing(0.5)
		  ),
		  `HSpacing(0.5)
		)),
            `VSpacing(0.5),
	    `HBox(
		`PushButton(`id(`ok), `opt(`default,`key_F10), Label::OKButton()),
	        `PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton()),
	        `PushButton(`id(`help), `opt(`key_F2), Label::HelpButton()),
		// Pushbutton label (get data from LDAP server)
	        `PushButton(`id(`read), `opt(`key_F3), _("From &Server"))
	    ),
            `VSpacing(0.5)),
        `HSpacing(1.5)
    ));

    symbol button = nil;
    do
    {
	button = (symbol) UI::UserInput();

	if ( button == `help )
        {
	    Wizard::ShowHelp( help_text );
	}
	if ( button == `read )
	{
	    if (Users::ReadLDAPFilters())
	    {
		UI::ChangeWidget(`id (`userf), `Value,
		    Users::ldap_default_user_filter);
		UI::ChangeWidget(`id (`groupf),`Value,
		    Users::ldap_default_group_filter);
	    }
	}
	if ( button == `ok)
	{
	    string new_user_f = (string) UI::QueryWidget(`id (`userf), `Value);
	    string new_group_f = (string)UI::QueryWidget(`id (`groupf), `Value);
	    if (new_user_f != user_f)
	    {
		if (!issubstring (new_user_f, default_user_f))
		{
		    // error popup
		    Popup::Error (_("The new user filter does not contain the default user filter.
Try again.
"));
		    UI::SetFocus (`id(`userf));
		    button = `notnext;
		    continue;
		}
		user_f = new_user_f;
	    }
	    if (new_group_f != group_f)
	    {
		if (!issubstring (new_group_f, default_group_f))
		{
		    // error popup
		    Popup::Error (_("The new group filter does not contain the default group filter.
Try again.
"));
		    UI::SetFocus (`id(`groupf));
		    button = `notnext;
		    continue;
		}
		group_f = new_group_f;
	    }
	    // checks are OK, let's update the values now
	    if (user_f != Users::ldap_user_filter)
	    {
		Users::ldap_user_filter = user_f;
		ret = true;
	    }
	    if (group_f != Users::ldap_group_filter)
	    {
		Users::ldap_group_filter = group_f;
		ret = true;
	    }
	}
    } while ( button != `ok && button != `cancel );

    UI::CloseDialog();
    return ret;
    */
    return false;
}


/* EOF */
}
