#! /usr/bin/perl -w
#
# Example of plugin module
# This is the API part of UsersPluginQuota plugin
# - configuration of user quota (feature 120106)
#
# For documentation and examples of function arguments and return values, see
# UsersPluginLDAPAll.pm

package UsersPluginQuota;

use strict;

use YaST::YCP qw(:LOGGING);
use YaPI;
use Data::Dumper;

textdomain("users");

our %TYPEINFO;

##--------------------------------------
##--------------------- global imports

YaST::YCP::Import ("SCR");

##--------------------------------------
##--------------------- global variables

# error message, returned when some plugin function fails
my $error	= "";

# internal name
my $name	= "UsersPluginQuota";

# is quota available and set up
my $quota_available	= undef;

# list of keys use in user/group map
my @quota_keys	= ("quota_blocks_soft", "quota_blocks_hard",
    "quota_inodes_soft", "quota_inodes_hard", "quota_grace");

##----------------------------------------
##--------------------- internal functions

# internal function:
# check if given key (second parameter) is contained in a list (1st parameter)
# if 3rd parameter is true (>0), ignore case
sub contains {
    my ($list, $key, $ignorecase) = @_;
    if (!defined $list || ref ($list) ne "ARRAY" || @{$list} == 0) {
	return 0;
    }
    if ($ignorecase) {
        if ( grep /^\Q$key\E$/i, @{$list} ) {
            return 1;
        }
    } else {
        if ( grep /^\Q$key\E$/, @{$list} ) {
            return 1;
        }
    }
    return 0;
}

# update the object data when removing plugin
sub remove_plugin_data {

    my ($config, $data) = @_;
    foreach my $key (@quota_keys) {
	my $i	= 0;
	foreach my $qmap (@{$data->{"quota"}}) {
	    $data->{"quota"}[$i]{$key} = 0 if defined $data->{"quota"}[$i]{$key};
	    $i	= $i + 1;
	}
    }
    return $data;
}

# read the quota information for given object
sub read_quota_info {

    my ($config, $data) = @_;
    # check for any entry (all must be filled during read)
    if (!defined $data->{"quota"}) {
	my $username	= $data->{"uid"};
	my $cmd	= "LANG=C quota -u $username -p 2>/dev/null | tail +3";
y2internal ("cmd is '$cmd'");
	my $out	= SCR->Execute (".target.bash_output", $cmd);
# FIXME check retval of quota, not tail, see PIPESTATUS (echo ${PIPESTATUS[0]})
	if ($out->{"stdout"}) {
	    # each line in stdout reports quota for one filesystem
	    my @quotalist	= ();
	    foreach my $line (split (/\n/, $out->{"stdout"})) {
		chomp $line;
		$line	=~ s/^\s+//; # remove the leading space
		my @l	= split (/\s+/, $line);
		if (@l == 9) {
		    my %item    = ();
		    $item{"quota_fs"}		= $l[0];
		    $item{"quota_blocks_soft"}	= $l[2];
		    $item{"quota_blocks_hard"}	= $l[3];
		    $item{"quota_inodes_soft"}	= $l[6];
		    $item{"quota_inodes_hard"}	= $l[7];
		    $item{"quota_grace"}	= $l[4];
		    push @quotalist, \%item if %item;
		}
	    }

    # fake, to simulate in the UI
    my %item    = ();
    $item{"quota_fs"}		= "/dev/hahahaha";
    $item{"quota_blocks_soft"}	= 100;
    $item{"quota_blocks_hard"}	= 200;
    $item{"quota_inodes_soft"}	= 300;
    $item{"quota_inodes_hard"}	= 400;
    $item{"quota_grace"}	= 3601;
    push @quotalist, \%item if %item;

	    $data->{"quota"}	= \@quotalist if @quotalist;
	}
    }
    return $data;
}

# check if quota is available and configured
sub is_quota_available {

    return $quota_available if defined $quota_available;
    if (not Package->Installed ("quota")) {
	$quota_available	= 0;
    }
    else {
	$quota_available	= (Service->Status ("boot.quota") == 0);
    }

    return $quota_available;
}

# check if user has quota enabled
sub user_has_quota {

    my $u	= shift;
    # quota returns 1 for success
    return SCR->Execute (".target.bash", "LANG=C quota -u $u 2>/dev/null");
}

##------------------------------------------
##--------------------- global API functions

# return names of provided functions
BEGIN { $TYPEINFO{Interface} = ["function", ["list", "string"], "any", "any"];}
sub Interface {

    my $self		= shift;
    my @interface 	= (
	    "GUIClient",
	    "Check",
	    "Name",
	    "Summary",
	    "Restriction",
	    "Write",
	    "Add",
	    "Edit",
	    "Interface",
	    "PluginPresent",
	    "PluginRemovable",
	    "Error",
    );
    return \@interface;
}

# return error message, generated by plugin
BEGIN { $TYPEINFO{Error} = ["function", "string", "any", "any"];}
sub Error {

    return $error;
}


# return plugin name, used for GUI (translated)
BEGIN { $TYPEINFO{Name} = ["function", "string", "any", "any"];}
sub Name {

    # plugin name
    return __("Quota Configuration");
}

##------------------------------------
# return plugin summary (to be shown in table with all plugins)
BEGIN { $TYPEINFO{Summary} = ["function", "string", "any", "any"];}
sub Summary {

    # user plugin summary (table item)
    return __("Manage User Quota");
}

##------------------------------------
# checks the current data map of user (2nd parameter) and returns
# true if given user has this plugin
BEGIN { $TYPEINFO{PluginPresent} = ["function", "boolean", "any", "any"];}
sub PluginPresent {

    my ($self, $config, $data)  = @_;

    if (not is_quota_available ()) {
	return 0;
    }
    my $username	= $data->{"uid"} || "";
    if (contains ($data->{'plugins'}, $name, 1) || user_has_quota ($username)) {
	y2milestone ("Quota plugin present");
	return 1;
    } else {
	y2debug ("Quota plugin not present");
	return 0;
    }
}

##------------------------------------
# Is it possible to remove this plugin from user?
BEGIN { $TYPEINFO{PluginRemovable} = ["function", "boolean", "any", "any"];}
sub PluginRemovable {

# does it make sense? how to disable quota check for certain user?
    return YaST::YCP::Boolean (1);
}


##------------------------------------
# return name of YCP client defining YCP GUI
BEGIN { $TYPEINFO{GUIClient} = ["function", "string", "any", "any"];}
sub GUIClient {

    return "users_plugin_quota";
}

##------------------------------------
# Type of objects this plugin is restricted to.
# Plugin is restricted to local users
BEGIN { $TYPEINFO{Restriction} = ["function",
    ["map", "string", "any"], "any", "any"];}
sub Restriction {

    return {
	    "local"	=> 1,
#	    "group"	=> 1,
	    "user"	=> 1
    };
}


##------------------------------------
# check if required atributes of are present and have correct form
# parameter is (whole) map of entry (user)
# return error message
BEGIN { $TYPEINFO{Check} = ["function",
    "string",
    "any",
    "any"];
}
sub Check {

    my ($self, $config, $data)  = @_;
    return "";
}

# This will be called just after Users::Add - the data map probably contains
# the values which we could use to create new ones
# Could be called multiple times for one user!
BEGIN { $TYPEINFO{Add} = ["function", ["map", "string", "any"], "any", "any"];}
sub Add {

    my ($self, $config, $data)  = @_;
    y2debug ("Add Quota called");
    if (contains ($data->{'plugins_to_remove'}, $name, 1)) {
	y2milestone ("removing plugin $name...");
	$data   = remove_plugin_data ($config, $data);
    }
    else {
	$data	= read_quota_info ($config, $data);
    }
    return $data;
}

# this will be called just after Users::Edit
BEGIN { $TYPEINFO{Edit} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub Edit {

    y2debug ("Edit Quota called");
    my ($self, $config, $data)  = @_;
    # in $data hash, there could be "plugins_to_remove": list of plugins which
    # has to be removed from the user
    if (contains ($data->{'plugins_to_remove'}, $name, 1)) {
	y2internal ("removing plugin $name...");
	$data   = remove_plugin_data ($config, $data);
    }
    else {
	$data	= read_quota_info ($config, $data);
    }
    return $data;
}

# what should be done after user is finally written
BEGIN { $TYPEINFO{Write} = ["function", "boolean", "any", "any"];}
sub Write {

y2internal ("Write Quota called");
    my ($self, $config, $data)  = @_;

    return YaST::YCP::Boolean (1) if not defined $data->{"quota"};

    my $username	= $data->{"uid"};
    return YaST::YCP::Boolean (1) if not $username;
    
    foreach my $qmap (@{$data->{"quota"}}) {
	my $quota_blocks_soft	= $qmap->{"quota_blocks_soft"} || 0;    
	my $quota_blocks_hard	= $qmap->{"quota_blocks_hard"} || 0;    
	my $quota_inodes_soft	= $qmap->{"quota_inodes_soft"} || 0;    
	my $quota_inodes_hard	= $qmap->{"quota_inodes_hard"} || 0;    
	my $quota_grace		= $qmap->{"quota_grace"} || 0;    
	my $quota_fs		= $qmap->{"quota_fs"};
	next if not $quota_fs;
	my $cmd	= "setquota -u $username $quota_blocks_soft $quota_blocks_hard $quota_inodes_soft $quota_inodes_hard $quota_fs";
y2warning ("cmd to call is '$cmd'");
    }
    return YaST::YCP::Boolean (1);
}
1
# EOF
