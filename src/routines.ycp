/**
 * File:	include/users/routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	various routines
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 */
{
textdomain "users";

import "Wizard";
import "Label";
import "Users";

/**
 * FIXME: move to ui_routines.ycp/dialogs.ycp?
 * Let user choose the encryption method.
 **/
global define string EncryptionDialog() ``{

      string method = Users::EncryptionMethod ();

      // Help text for password expert dialog 1/5
      string help_text = _("<p>
<b>This is for experts only.</b>
</p>");

      // Help text for password expert dialog 2/5
      help_text = help_text + _("<p>
Choose a password encryption method for local and system users.
<b>DES</b>, the Linux default method, works in all network environments, but it
restricts passwords to eight characters or less.
</p>
");

      // Help text for password expert dialog 3/5
      help_text = help_text + _("<p>
<b>MD5</b> allows longer passwords, thus provides more security, but some
network protocols don't support this, and you may have problems with NIS.
</p>");

      // Help text for password expert dialog 4/5
      help_text = help_text + _("<p>
<b>Blowfish</b> is similar to MD5, but uses a different algorithm
to encrypt passwords.
</P>");
      // Help text for password expert dialog 5/5
      help_text = help_text + _("<p>
As a general rule of thumb, use DES if you are unsure.
</p>");

      UI::OpenDialog(
	`VBox(
	  // Label
	  `Heading( _("Set Password Encryption") ),
	  `VSpacing( 0.7 ),
	  `HBox(
		`HSpacing( 2 ),
		`RadioButtonGroup(
		// frame label
		`Frame( _("Encryption Type"),
		  `VBox(
		  `VSpacing( 0.5 ),
		  // Radio buttons for password encryption: DES-crypt
		  `Left(`RadioButton(`id(`des), _("&DES (Linux default)"),
			method == "des" ) ),
		  // Radio buttons for password encryption: MD5-crypt
		  `Left(`RadioButton(`id(`md5), _("&MD5"),
			method == "md5" ) ),
		  // Radio buttons for password encryption: blowfish-crypt
		  `Left(`RadioButton(`id(`blowfish), _("&Blowfish"),
			method == "blowfish" ) )
		  )
		)),
		`HSpacing( 2 )
	  ),
	  `VSpacing( 0.5 ),
	  `HBox(
		`HStretch(),
		`HWeight(1, `PushButton(`id(`ok), `opt(`default, `key_F10),
		    Label::OKButton() )),
		`HStretch(),
		`HWeight(1, `PushButton(`id(`cancel), `opt (`key_F9),
		    Label::CancelButton())),
		`HStretch(),
		`HWeight(1, `PushButton(`id(`help), `opt (`key_F2),
		    Label::HelpButton() ) ),
		`HStretch()
	  )
	));

      any button = nil;

      do
      {
	  button = UI::UserInput();

	  if ( button == `help )
	  {
	      Wizard::ShowHelp( help_text );
	  }
	  else if ( button == `ok )
	  {
	      if      ( (boolean) UI::QueryWidget( `id(`des), `Value ) )
		  method = "des";
	      else if ( (boolean) UI::QueryWidget( `id(`md5), `Value ) )
		  method = "md5";
	      else if ( (boolean) UI::QueryWidget( `id(`blowfish), `Value ) )
		  method = "blowfish";
	      y2milestone( "Changing encryption method to %1", method );
	  }
      } while ( button != `ok && button != `cancel );

      UI::CloseDialog();
      return method;
};


/**
 * Error messages for errors detected during reading
 * @param returned map returned as the output of target.bash_output
 * @return error message
 */
global define string GetErrorMessage (map returned) ``{

    string stdout = returned["stdout"]:"";
    string last =
// error message 2/2 (= next sentence)
_("Correct them manually before running the YaST2 users module again.");

    map read_error = $[

    1: sformat(
// error message 1/2: %1 is file name, %2 is uid, %3 is next sentence (2/2)
_("There are more users with the same UID (\"%2\") in the file %1.
%3"), "/etc/passwd", stdout, last),

    2: sformat(
// error message 1/2: %1 is file name, %2 is username, %3 is next sentence (2/2)
_("There are more users with the same name (\"%2\") in the file %1.
%3"), "/etc/passwd", stdout, last),

    3: sformat(
// error message 1/2: %1 is file name, %2 is username, %3 is next sentence (2/2)
_("There are more users with the same name (\"%2\") in the file %1.
%3"), "/etc/shadow", stdout, last),

    5: sformat(
// error message 1/2: %1 is file name, %2 is gid, %3 is next sentence (2/2)
_("There are more groups with the same GID (\"%2\") in the file %1.
%3"), "/etc/group", stdout, last),

    6: sformat(
// error message 1/2: %1 is file name, %2 is groupname, %3 next sentence (2/2)
_("There are more groups with the same name (\"%2\") in the file %1.
%3"), "/etc/group", stdout, last)
];

    // default error message
    return read_error[returned["exit"]:0]: _("Error while reading users or groups.");
}

/**
 * Split cn (fullname) in forename and surname.
 * @param what `surname or `forename
 * @param cn fullname
 * @param type user type
 * @return string selected part of user name
 */
global define string SplitFullName(symbol what,string cn) ``{

// TODO: used only for LDAP users (->agent?) and autoyast (-> not necessary?)

    if( cn == nil )
        cn = "";

    // if cn is to be substituted, do not try to resolve givenName/sn
    if (issubstring (cn, "%"))
	return "";

    list    strs    = splitstring(cn , " ");
    integer i       = 1;
    string sn  = "";
    string givenName = "";

    foreach(string str, strs, ``{
        if ( i < size( strs) )
        {
        if( givenName == "" ) givenName = str;
        else givenName = givenName + " " + str;
        }
        else  sn = str;
        i = i + 1;
    });
    if ( what == `sn  ) return sn;
    if ( what == `givenName ) return givenName;
}


/** FIXME following functions should be part of Perl backend...
 * Create home directory
 * @param skeleton skeleton directory for new home
 * @param home name of new home directory
 * @return success
 *
global define boolean CreateHome (string skeleton, string home) ``{

    // create a path to new home directory, if not exists
    string home_path = substring (home, 0, findlastof (home,"/"));
    if (SCR::Read(.target.stat, home_path) == $[])
	SCR::Execute(.target.mkdir, home_path);

    // skeleton not exist or should not be copied
    if (SCR::Read(.target.stat, skeleton) == $[])// || !copy TODO
    {
	if (!(boolean) SCR::Execute(.target.mkdir, home))
	{
	    y2error ("error creating %1", home);
	    return false;
	}
    }
    // copy homedir from skeleton
    else
    {
	string command = sformat("/bin/cp -r %1 %2", skeleton, home);
	map out = (map) SCR::Execute(.target.bash_output, command);
	if (out["stderr"]:"" != "")
	{
	    y2error ("error calling %1: %2", command, out["stderr"]:"");
	    return false;
	}
    }
    y2milestone ("The directory %1 was created", home);
    return true;
}

/**
 * Change ownership of directory
 * @param uid UID of new owner
 * @param gid GID of new owner's default group
 * @param home name of new home directory
 * @return success
 *
global define boolean ChownHome (integer uid, integer gid, string home)``{

    // directory already exists and chown is needed
    if (uid == lookup ((map)SCR::Read(.target.stat, home), "uid", -1) &&
	gid == lookup ((map)SCR::Read(.target.stat, home), "gid", -1))
	return true;

    string command = sformat("/bin/chown -R %1:%2 %3", uid, gid, home);
    map out = (map) SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("Changed owner of files in %2 to user %1", uid, home);

    return true;
}

/**
 * Move the directory
 * @param org_home original name of directory
 * @param home name of new home directory
 * @return success
 *
global define boolean MoveHome (string org_home, string home) ``{

    // create a path to new home directory, if not exists
    string home_path = substring (home, 0, findlastof (home,"/"));
    if (SCR::Read(.target.stat, home_path) == $[])
        SCR::Execute(.target.mkdir, home_path);

    string command = sformat("/bin/mv %1 %2", org_home, home);
    map out = (map)SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("The directory %1 was moved to %2", org_home, home);

    return true;
}

/**
 * Delete the directory
 * @param home name of directory
 * @return success
 *
global define boolean DeleteHome (string home) ``{

    string command = sformat("/bin/rm -rf %1", home);
    map out = (map)SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("The directory %1 was deleted", home);

    return true;
}
*/

/** FIXME rewrite to Perl and move to check_routines!
 * Checks if password is not too long
 * @param pw password
 * @param type user type ("local", "ldap"...)
 * @return true when it is OK (or user accepts truncation)
 *
global define boolean CheckPasswordMaxLength (string pw, string type) ``{

    if (type != "ldap")
	type = "local";

    if (size(pw) > Users::pass_length [type, "max"]:8)
    {
	// error popup. %1 is number (typical 8)
        return (Popup::YesNo (sformat(_("The password is too long for the current encryption method.
Truncate it to %1 characters?\n"), Users::pass_length [type, "max"]:8)));

    }
    return true;
}

/**
 * Just some simple checks for password contens
 * @param username user name
 * @param pw password
 * @return error message (password too sumple) or empty string (OK)
 *
global define string CheckObscurity (string username, string pw) ``{

    // temporary checked here, TODO use some agent
    if (issubstring (pw, username))
    {
        // yes/no popup
        return _("You have used the user name as a part of the password.
This is not good security practice. Are you sure?
");
    }
    // check for lowercase
    if (deletechars (pw, "abcdefghijklmnopqrstuvwxyz") == "")
    {
        // yes/no popup
        return _("You have used only lowercase letters for the password.
This is not good security practice. Are you sure?
");
    }
    // check for numbers
    if (deletechars (pw, "0123456789") == "")
    {
        // yes/no popup
        return _("You have used only digits for the password.
This is not good security practice. Are you sure?");
    }

    return "OK";

}

/**
 * Try to crack password using cracklib
 * @param username user name
 * @param pw password
 * @return utility output: either "OK" or error message
 *
global define string CrackPassword (string username, string pw) ``{

    string ret = "OK";
    if (SCR::Read (.target.size, Users::cracklib_dictpath + ".pwd") == -1)
	ret = (string) SCR::Execute(.crack, pw);
    else
	ret = (string) SCR::Execute(.crack, pw, Users::cracklib_dictpath);
    return (string) UI::Recode(Encoding::console,"UTF-8", ret);
}
*/



} // EOF
