/**
 * File:	include/users/routines.ycp
 * Package:	Configuration of users and groups
 * Summary:	users/groups read and write routines
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Important! It is supposed that this file is included from Users.ycp,
 * some variables are used from here...
 */
{
include "users/passwd.ycp";

/**
 * Reads prebuilded gshadow data
 * @param dir the input directory
 * @return gshadow map
 */
global define map ReadGshadow(string dir)``{

    map ret = $[
        "local": SCR::Read(.target.ycp, dir + "/gshadow_local.ycp"),
        "system": SCR::Read(.target.ycp, dir + "/gshadow_system.ycp")
    ];
    SCR::Execute (.target.remove, dir + "/gshadow_local.ycp");
    SCR::Execute (.target.remove, dir + "/gshadow_system.ycp");
    return ret;
}

/**
 * Reads prebuilded shadow data
 * @param dir the input directory
 * @return shadow map
 */
global define map ReadShadow(string dir)``{

    map ret = $[
        "local": SCR::Read(.target.ycp, dir + "/shadow_local.ycp"),
        "system": SCR::Read(.target.ycp, dir + "/shadow_system.ycp")
    ];
    SCR::Execute (.target.remove, dir + "/shadow_local.ycp");
    SCR::Execute (.target.remove, dir + "/shadow_system.ycp");
    return ret;
}

/**
 * Reads prebuilded groups data
 * @param dir the input directory
 * @return groups map
 */
global define map ReadGroups(string dir)``{

    map ret = $[
        "local": SCR::Read(.target.ycp, dir + "/group_local.ycp"),
        "system": SCR::Read(.target.ycp, dir + "/group_system.ycp")
    ];
    SCR::Execute (.target.remove, dir + "/group_local.ycp");
    SCR::Execute (.target.remove, dir + "/group_system.ycp");
    return ret;
}

/**
 * Reads prebuilded groups data
 * @param dir the input directory
 * @return groups map
 */
global define map ReadGroupsByName(string dir)``{

    map ret = $[
        "local": SCR::Read(.target.ycp, dir + "/group_local_byname.ycp"),
        "system": SCR::Read(.target.ycp, dir + "/group_system_byname.ycp")
    ];
    SCR::Execute (.target.remove, dir + "/group_local_byname.ycp");
    SCR::Execute (.target.remove, dir + "/group_system_byname.ycp");
    return ret;
}

/**
 * Reads prebuilded passwd data
 * @param dir the input directory
 * @return users map
 */
global define map ReadPasswd(string dir)``{

    map ret = $[
        "local": SCR::Read(.target.ycp, dir + "/passwd_local.ycp"),
        // this is due to translations of fullnames in users/passwd.ycp
        "system": eval (SCR::Read(.target.ycp, dir + "/passwd_system.ycp"))
    ];
    SCR::Execute (.target.remove, dir + "/passwd_local.ycp");
    SCR::Execute (.target.remove, dir + "/passwd_system.ycp");
    return ret;
}

/**
 * Reads prebuilded passwd data
 * @param dir the input directory
 * @return users map
 */
global define map ReadPasswdByName(string dir)``{

    map ret = $[
        "local": SCR::Read(.target.ycp, dir + "/passwd_local_byname.ycp"),
        "system": SCR::Read(.target.ycp, dir + "/passwd_system_byname.ycp")
    ];
    SCR::Execute (.target.remove, dir + "/passwd_local_byname.ycp");
    SCR::Execute (.target.remove, dir + "/passwd_system_byname.ycp");
    return ret;
}

/**
 * Reads the line begining with + or - from the data files, if exists
 * @param file the input file
 * @return the line
 */
global define string PlusFile (string file) ``{

    if (SCR::Execute (.target.bash, sformat("/usr/bin/test -e %1", file)) == 0)
        return SCR::Read(.target.ycp, file);
    else
        return "";
}

/**
 * Reads the line begining with + or - from gshadow file
 * @param dir the input directory
 * @return the line
 */
global define string ReadPlusGshadow(string dir)``{

    return PlusFile (dir + "/plus_gshadow.ycp");
}

/**
 * Reads the line begining with + or - from shadow file
 * @param dir the input directory
 * @return the line
 */
global define string ReadPlusShadow(string dir)``{

    return PlusFile (dir + "/plus_shadow.ycp");
}

/**
 * Reads the line begining with + or - from group file
 * @param dir the input directory
 * @return the line
 */
global define string ReadPlusGroup(string dir)``{

    return PlusFile (dir + "/plus_group.ycp");
}

/**
 * Reads the line begining with + or - from passwd file
 * @param dir the input directory
 * @return the line
 */
global define string ReadPlusPasswd(string dir)``{

    return PlusFile (dir + "/plus_passwd.ycp");
}

/**
 * Error messages for errors detected during reading
 * @param returned map returned as the output of target.bash_output
 * @return error message
 */
global define string GetErrorMessage (map returned) ``{

    string stdout = returned["stdout"]:"";
    string last =
// error message 2/2 (= next sentence)
_("Correct them manualy before running YaST2 users module again.");

    map read_error = $[

    1: sformat(
// error message 1/2: %1 is file name, %2 is uid, %3 is next sentence (2/2)
_("There are more users with the same UID (\"%2\") in the file %1.
%3"), "/etc/passwd", stdout, last),

    2: sformat(
// error message 1/2: %1 is file name, %2 is username, %3 is next sentence (2/2)
_("There are more users with the same name (\"%2\") in the file %1.
%3"), "/etc/passwd", stdout, last),

    3: sformat(
// error message 1/2: %1 is file name, %2 is username, %3 is next sentence (2/2)
_("There are more users with the same name (\"%2\") in the file %1.
%3"), "/etc/shadow", stdout, last),

    4: sformat(
// error message 1/2: %1 is file name, %2 is groupname, %3 next sentence (2/2)
_("There are more groups with the same name (\"%2\") in the file %1.
%3"), "/etc/gshadow", stdout, last),

    5: sformat(
// error message 1/2: %1 is file name, %2 is gid, %3 is next sentence (2/2)
_("There are more groups with the same GID (\"%2\") in the file %1.
%3"), "/etc/group", stdout, last),

    6: sformat(
// error message 1/2: %1 is file name, %2 is groupname, %3 next sentence (2/2)
_("There are more groups with the same name (\"%2\") in the file %1.
%3"), "/etc/group", stdout, last)
];

    // default error message
    return read_error[returned["exit"]:0]: _("Cannot run preparation script.");
}

/**
 * Check if authentication with pam_krb5 is used
 * @return type of authentication: required/optional/sufficient/[empty string]
 */
global define string KerberosAuth () ``{

    list pam_auth_list = SCR::Read (.pam.login);
    string ret = "";
    foreach (`line, pam_auth_list, ``{
        if (issubstring (line["module"]:"", "pam_krb5") &&
            line["type"]:"" == "auth" && ret == "")
                ret = line["control"]:"";
    });
    return ret;
}

/**
 * Writes data to group file (probably /etc/group)
 * @param basedir the directory for output
 * @param system_groups map of groups
 * @param local_groups map of groups
 * @param plus the line begining with +/-
 * @return succes
 */
global define boolean WriteGroup(string basedir, map system_groups, map local_groups, string plus) ``{

    string conf_path = basedir + "/group";
    list modified_list = [];
    list list_to_save = maplist (`gid, `group, system_groups, ``{
        string to_save = sformat("%1:%2:%3:%4",
            group["groupname"]:"",
            "x",//group["password"]:"",// TODO what if there should be * or !
            group["gid"]:max_gid,
            group["userlist"]:"");
        return to_save;
    });
    list_to_save = merge(list_to_save, maplist (`gid, `group, local_groups, ``{
        string to_save = sformat("%1:%2:%3:%4",
            group["groupname"]:"",
            "x",//group["password"]:"",
            group["gid"]:max_gid,
            group["userlist"]:"");
        return to_save;
    }));
    string string_to_save = mergestring (list_to_save, "\n");
    if (plus != "" && plus != nil)
        string_to_save = string_to_save + "\n" + plus;
    string_to_save = string_to_save + "\n";
    boolean ret = SCR::Write(.target.string, conf_path, string_to_save);
    y2milestone("Succesfuly written %1: %2", conf_path, ret);
    return ret;
}


/**
 * Writes data to passwd file (probably /etc/passwd)
 * @param basedir the directory for output
 * @param system_users map of users
 * @param local_users map of users
 * @param plus the line begining with +/-
 * @return succes
 */
global define map WritePasswd(string basedir, map system_users, map local_users, string plus) ``{

    string conf_path = basedir + "/passwd";
    map modified_map = $[];
    list list_to_save = maplist (`uid, `user, system_users, ``{
        string gecos = user["fullname"]:"";
        if (user["addit_data"]:"" != "")
            gecos = gecos + "," + user["addit_data"]:"";
        gecos = UI::Recode ("UTF-8", encoding, gecos);
        string to_save = sformat("%1:%2:%3:%4:%5:%6:%7",
            user["username"]:"",
            "x",//user["password"]:"",// write x !!
            uid,
            user["gid"]:max_gid,
            gecos,
            user["home"]:"",
            user["shell"]:"");
        if (user["modified"]:`nothing != `nothing)
            modified_map = add (modified_map, uid, user);
        return to_save;
    });
    list_to_save = merge(list_to_save, maplist (`uid, `user, local_users, ``{
        string gecos = user["fullname"]:"";
        if (user["addit_data"]:"" != "")
            gecos = gecos + "," + user["addit_data"]:"";
        gecos = UI::Recode ("UTF-8", encoding, gecos);
        string to_save = sformat("%1:%2:%3:%4:%5:%6:%7",
            user["username"]:"",
            "x",//user["password"]:"",// write x !!
            uid,
            user["gid"]:max_gid,
            gecos,
            user["home"]:"",
            user["shell"]:"");
        if (user["modified"]:`nothing != `nothing)
            modified_map = add (modified_map, uid, user);
        return to_save;
    }));
    string string_to_save = mergestring (list_to_save, "\n");
    if (plus != "" && plus != nil)
        string_to_save = string_to_save + "\n" + plus;
    string_to_save = string_to_save + "\n";
    boolean ret = SCR::Write(.target.string, conf_path, string_to_save);
    y2milestone("Succesfuly written %1: %2", conf_path, ret);

    if (ret)
        return modified_map;
    else
        return nil;
}

/**
 * Writes data to shadow file (probably /etc/shadow)
 * @param basedir the directory for output
 * @param system_shadow map of shadow
 * @param local_shadow map of shadow
 * @param plus the line begining with +/-
 * @return succes
 */
global define boolean WriteShadow(string basedir, map system_shadow, map local_shadow, string plus) ``{

    string conf_path = basedir + "/shadow";

    list list_to_save = maplist (`username, `entry, system_shadow, ``{
        string to_save = sformat("%1:%2:%3:%4:%5:%6:%7:%8:%9",
            username,
            entry["password"]:"",
            entry["last_change"]:"",
            entry["min"]:"",
            entry["max"]:"",
            entry["warn"]:"",
            entry["inact"]:"",
            entry["expire"]:"",
            entry["flag"]:"");
        return to_save;
    });
    list_to_save = merge(list_to_save, maplist (`username, `entry, local_shadow, ``{
        string to_save = sformat("%1:%2:%3:%4:%5:%6:%7:%8:%9",
            username,
            entry["password"]:"",
            entry["last_change"]:"",
            entry["min"]:"",
            entry["max"]:"",
            entry["warn"]:"",
            entry["inact"]:"",
            entry["expire"]:"",
            entry["flag"]:"");
        return to_save;
    }));
    string string_to_save = mergestring (list_to_save, "\n");
    if (plus != "" && plus != nil)
        string_to_save = string_to_save + "\n" + plus;
    string_to_save = string_to_save + "\n";
    boolean ret = SCR::Write(.target.string, conf_path, string_to_save);
    y2milestone("Succesfuly written %1: %2", conf_path, ret);
    return ret;
}


/**
 * Writes data to gshadow file (probably /etc/gshadow)
 * @param basedir the directory for output
 * @param system_gshadow map of gshadow
 * @param local_gshadow map of gshadow
 * @param plus the line begining with +/-
 * @return succes
 */
global define boolean WriteGshadow(string basedir, map system_gshadow, map local_gshadow, string plus) ``{

    string conf_path = basedir + "/gshadow";
    list list_to_save = maplist (`groupname, `entry, system_gshadow, ``{
        string to_save = sformat("%1:%2:%3:%4",
            groupname,
            entry["password"]:"",
            entry["disposer"]:"",
            entry["userlist"]:"");
        return to_save;
    });
    list_to_save = merge(list_to_save, maplist (`groupname, `entry, local_gshadow, ``{
        string to_save = sformat("%1:%2:%3:%4",
            groupname,
            entry["password"]:"",
            entry["disposer"]:"",
            entry["userlist"]:"");
        return to_save;
    }));
    string string_to_save = mergestring (list_to_save, "\n");
    if (plus != "" && plus != nil)
        string_to_save = string_to_save + "\n" + plus;
    string_to_save = string_to_save + "\n";
    boolean ret = SCR::Write(.target.string, conf_path, string_to_save);
    y2milestone("Succesfuly written %1: %2", conf_path, ret);
    return ret;
}

/**
 * Backup /etc/passwd, shadow, group and gshadow files
 * @param dir the source directory
 */
global define void BackupConfFiles(string dir)``{

    SCR::Execute(.target.bash,
        sformat ("/bin/cp %1/shadow %1/shadow.YaST2save", dir));
    SCR::Execute(.target.bash,
        sformat ("/bin/cp %1/passwd %1/passwd.YaST2save", dir));
    SCR::Execute(.target.bash,
        sformat ("/bin/cp %1/gshadow %1/gshadow.YaST2save", dir));
    SCR::Execute(.target.bash,
        sformat ("/bin/cp %1/group %1/group.YaST2save", dir));
}

/**
 * Create home directory
 * @param skeleton skeleton directory for new home
 * @param home name of new home directory
 * @return success
 */
global define boolean CreateHome (string skeleton, string home) ``{

    // create a path to new home directory, if not exists
    string home_path = substring (home, 0, findlastof (home,"/"));
    if (SCR::Read(.target.stat, home_path) == $[])
	SCR::Execute(.target.mkdir, home_path);

    // copy homedir from skel
    string command = sformat("/bin/cp -r %1 %2", skeleton, home);

    map out = SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("The directory %1 was created", home);

    return true;
}

/**
 * Change ownership of directory
 * @param uid UID of new owner
 * @param gid GID of new owner's default group
 * @param home name of new home directory
 * @return success
 */
global define boolean ChownHome (integer uid, integer gid, string home)``{

    // directory already exists and chown is needed
    if (uid == lookup (SCR::Read(.target.stat, home), "uid", -1) &&
	gid == lookup (SCR::Read(.target.stat, home), "gid", -1))
	return true;

    string command = sformat("/bin/chown -R %1:%2 %3", uid, gid, home);
    map out = SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("Changed owner of files in %2 to user %1", uid, home);

    return true;
}

/**
 * Move the directory
 * @param org_home original name of directory
 * @param home name of new home directory
 * @return success
 */
global define boolean MoveHome (string org_home, string home) ``{

    // create a path to new home directory, if not exists
    string home_path = substring (home, 0, findlastof (home,"/"));
    if (SCR::Read(.target.stat, home_path) == $[])
        SCR::Execute(.target.mkdir, home_path);

    string command = sformat("/bin/mv %1 %2", org_home, home);
    map out = SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("The directory %1 was moved to %2", org_home, home);

    return true;
}

/**
 * Delete the directory
 * @param home name of directory
 * @return success
 */
global define boolean DeleteHome (string home) ``{

    string command = sformat("/bin/rm -rf %1", home);
    map out = SCR::Execute(.target.bash_output, command);
    if (out["stderr"]:"" != "")
    {
	y2error ("error calling %1: %2", command, out["stderr"]:"");
	return false;
    }
    y2milestone ("The directory %1 was deleted", home);

    return true;
}

/** TODO: used only for LDAP users (->agent?) and autoyast (-> not necessary?)
 * Split fullname in forename and surname.
 * @param what `surname or `forename
 * @param fullname fullname
 * @param type user type
 * @return string selected part of user name
 */
global define string SplitFullName(symbol what,string fullname) ``{

    if( fullname == nil )
        fullname = "";

    list    strs    = splitstring(fullname , " ");
    integer i       = 1;
    string sn  = "";
    string givenName = "";

    foreach( `str, strs, ``{
        if ( i < size( strs) )
        {
        if( givenName == "" ) givenName = str;
        else givenName = givenName + " " + str;
        }
        else  sn = str;
        i = i + 1;
    });
    if ( what == `sn  ) return sn;
    if ( what == `givenName ) return givenName;
}


/** TODO: move to ui_routines.ycp?
 * Let user choose the encryption method.
 **/
global define string EncryptionDialog() ``{

      string method = Users::encryptionMethod;

      // Help text for password expert dialog 1/5
      string help_text = _("<p>
<b>This is for experts only.</b>
</p>");

      // Help text for password expert dialog 2/5
      help_text = help_text + _("<p>
Choose a password encryption method.
<b>DES</b>, the Linux default method, works in all network environments, but it
restricts you to passwords no longer than eight characters.
</p>");

      // Help text for password expert dialog 3/5
      help_text = help_text + _("<p>
<b>MD5</b> allows longer passwords, thus provides more security, but some
network protocols don't support this, and you may have problems with NIS.
</p>");

      // Help text for password expert dialog 4/5
      help_text = help_text + _("<p>
<b>Blowfish</b> is similar to MD5, but uses a different algorithm
to encrypt passwords.
</P>");
      // Help text for password expert dialog 5/5
      help_text = help_text + _("<p>
As a general rule of thumb, use DES if you are unsure.
</p>");

      UI::OpenDialog(
	`VBox(
	  // Label
	  `Heading( _("Set Password Encryption") ),
	  `VSpacing( 0.7 ),
	  `HBox(
		`HSpacing( 2 ),
		`RadioButtonGroup(
		// frame label
		`Frame( _("Encryption Type"),
		  `VBox(
		  `VSpacing( 0.5 ),
		  // Radio buttons for password encryption: DES-crypt
		  `Left(`RadioButton(`id(`des), _("&DES (Linux default)"),
			method == "des" ) ),
		  // Radio buttons for password encryption: MD5-crypt
		  `Left(`RadioButton(`id(`md5), _("&MD5"),
			method == "md5" ) ),
		  // Radio buttons for password encryption: blowfish-crypt
		  `Left(`RadioButton(`id(`blowfish), _("&Blowfish"),
			method == "blowfish" ) )
		  )
		)),
		`HSpacing( 2 )
	  ),
	  `VSpacing( 0.5 ),
	  `HBox(
		`HStretch(),
		`HWeight(1, `PushButton(`id(`ok), `opt(`default, `key_F10),
		    UI::OKButtonLabel() )),
		`HStretch(),
		`HWeight(1, `PushButton(`id(`cancel), `opt (`key_F9),
		    UI::CancelButtonLabel())),
		`HStretch(),
		`HWeight(1, `PushButton(`id(`help), `opt (`key_F2),
		    UI::HelpButtonLabel() ) ),
		`HStretch()
	  )
	));

      any button = nil;

      do
      {
	  button = UI::UserInput();

	  if ( button == `help )
	  {
	      Wizard::ShowHelp( help_text );
	  }
	  else if ( button == `ok )
	  {
	      if      ( UI::QueryWidget( `id(`des), `Value ) )	method = "des";
	      else if ( UI::QueryWidget( `id(`md5), `Value ) )	method = "md5";
	      else if ( UI::QueryWidget( `id(`blowfish), `Value ) ) method = "blowfish";
	      y2milestone( "Changing encryption method to %1", method );
	  }
      } while ( button != `ok && button != `cancel );

      UI::CloseDialog();
      return method;
  };

/** TODO: move to some ui_routines?
 * Checks if password is not too long
 * @param pw
 * @return true when it is OK (or user accepts truncation)
 **/
global define boolean CheckPasswordMaxLength (string pw) ``{

    if (size(pw) > Users::max_length_pas)
    {
	// error popup. %1 is number (typical 8)
        return (UI::YesNoPopup (sformat(_("The password is too long for current encryption method.
It will be truncated to %1 characters."), Users::max_length_pas)));

    }
    return true;
}

/**
 * Just some simple checks for password contens
 * @param username user name
 * @param pw password
 * @return error message (password too sumple) or empty string (OK)
 */
global define string CheckObscurity (string username, string pw) ``{

    // temporary checked here, TODO use some agent
    if (issubstring (pw, username))
    {
        // yes/no popup
        return _("You have used the user name as a part of the password.
This is not good security practice. Are you sure?
");
    }
    // check for lowercase
    if (deletechars (pw, "abcdefghijklmnopqrstuvwxyz") == "")
    {
        // yes/no popup
        return _("You have used only lowercase letters for the password.
This is not good security practice. Are you sure?
");
    }
    // check for numbers
    if (deletechars (pw, "0123456789") == "")
    {
        // yes/no popup
        return _("You have used only digits for the password.
This is not good security practice. Are you sure?");
    }

    return "OK";

}

/**
 * Try to crack password using cracklib
 * @param username user name
 * @param pw password
 * @return utility output: ether "OK" or error message
 */
global define string CrackPassword (string username, string pw) ``{


    return "OK"; //FIXME use crack agent
//    return (SCR::Execute(.crack, pw));

}



} // EOF
