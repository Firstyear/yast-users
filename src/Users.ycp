/**
 * File:	modules/Users.ycp
 * Package: Configuration of users and groups
 * Summary:	Main module, providing IO functions
 *
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Anas Nashif (nashif@suse.de),
 *          Jiri Suchomel (jsuchome@suse.cz)
 *
 *
 * $Id$
 */
{

module "Users";

textdomain "users";

import "Mode";
import "Progress";
import "Report";
import "UsersCache";
import "MailAliases";
import "Directory";
import "Console";
import "Security";

include "users/routines.ycp";
include "users/nis_routines.ycp";
include "users/ldap_routines.ycp";

/**
 * What module to call after auth. dialog during installation:
 * could be `users/`nis/`nisplus/`ldap, see inst_auth.ycp
 */
global symbol after_auth = `users;

/**
 * Encryption method: "des", "md5" - for future use: "blowfish"
 */
global string encryptionMethod = "des";

// The root's password
global string rootPassword = "";


// Export all settings, not only modified
global boolean ExportAll = false;

/**
 *  keys from /etc/defaults/useradd:
 **/
map useradd_defaults  = $[
    "group": "",
    "home": "",
    "inactive": "",
    "expire": "",
    "shell": "",
    "skel": ""
];

// default values for new users (just shotcuts from useradd_defaults):
global string default_shell = "/bin/bash";
global string default_skel = "/etc/skel";
global string default_home = "/home/";
global integer default_gid = 100; // TODO change to 500 with new version
global string default_groupname = "users";
global string default_inactive = "-1";
global string default_expire = "";

// console encoding - needed for preparation script
string encoding = "";

/**
 * The number of days after a password expires until the account is
 * permanently disabled. A value of 0 disables the
 * account as soon as the password has expired, and a value of -1
 * disables the feature.  The default value is -1.
 */
global integer pass_inact_days = -1;


/**
 * The date on which the user account will be disabled.
 * The date is specified in the format YYYY-MM-DD.
 */
global string pass_expire_date = "";

global string valid_logname_chars  = "0123456789abcdefghijklmnopqrstuvwxyz-_";
global string valid_password_chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#* ,.;:._-+!$%&/|\?{[()]}=";
global string valid_home_chars     = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/_-";
global string valid_group_chars    = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
global string valid_grouplist_chars= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,-_";
global string valid_id_chars       = "0123456789";
global string invalid_gecos_chars = ",:";

global integer max_uid	  = 60000;
global integer max_gid	  = 60000;
global integer max_system_uid = 500 - 1;
global integer max_system_gid = 100 - 1; // TODO change to 500 with new version
global integer max_length_uid = 5;// size(sformat("%1", max_uid));
global integer max_length_gid = 5;
global integer max_length_pas = 8;
global integer min_length_pas = 5;

// Maximum number of days a password may be used:
global integer pass_max_days = 99999;
// Minimum number of days allowed between password changes:
global integer pass_min_days = 0;
// Number of days warning given before a password expires:
global integer pass_warn_age = 7;

global string default_pw     = "******";

/**
 * if password should be checked against crack
 */
global boolean use_cracklib = false;

/**
 * if password should be checked
 */
global boolean obscure_checks = false;

global string root_mail = "";

// password to LDAP server
string ldap_bind_pass = "";

// list of user sources - passwd entry from /etc/nsswitch.conf
list user_sources = [];

/**
 * The main map of users
 */
global map users = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

/**
 * The main map of groups
 */
global map groups  = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

// main maps of all local shadow and gshadow entries:
global map shadow = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

map gshadow = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

/**
 * structures *_by_name are used for searching
 */
global map users_by_name = $[];

/**
 * structures *_by_name are used for searching
 */
global map groups_by_name = $[];

/**
 * map of current user
 */
global map user_in_work = $[];

/**
 * map of current group
 */
global map group_in_work = $[];

/**
 * the first user, added during install
 */
global map saved_user = $[];

/**
 * users, which has been deleted/modified:
 */
map modified_users = $[];
map modified_groups = $[];

/**
 * users sets in "Custom" selection:
 */
global list user_custom_sets = [ `local ];
global list group_custom_sets = [ `local ];

/**
 * which sets of users are we working with:
 */
global list current_users = [];
global list current_groups = [];

// variables desctibing available users sets:
global boolean is_nis_available = false;
global boolean is_nis_master = false;
global boolean is_ldap_available = false;
global boolean is_ldap_server = false;

// type of pam kerberos authentication: required/optional/sufficient/""
global string kerberos_auth = "";

/**
 * users like ldap/nis are not read by default, but could be read on demand:
 */
boolean nis_not_read = true;

/**
 * users like ldap/nis are not read by default, but could be read on demand:
 */
boolean ldap_not_read = true;

/**
 * which sets of users are available to work with:
 */
global list available_usersets = [ `system, `local];
global list available_usersets_items = [];
global list available_groupsets = [ `system, `local];
global list available_groupsets_items = [];

/**
 * where the user/group/password data are stored
 *  (can be different on NIS server)
 */
global string base_dir = "/etc";

/**
 * list of available shells (read in GetAllShells)
 */
global list all_shells = [];
global list all_shells_items = [];

// the +/- entries in config files:
string plus_passwd = "";
string plus_group = "";
string plus_shadow = "";
string plus_gshadow = "";

// ldap configuration from /etc/openldap/ldap.conf
string ldap_host = "";
string ldap_base = "";

string tmpdir = "/tmp"; // do not write to /tmp only!

global string start_dialog = "users";
global boolean use_next_time = false;

// if anything was done
global boolean modified = false;
global boolean customs_modified = false;
global boolean defaults_modified = false;
global boolean ldap_modified = false;

// values to MenuItem in Summary dialog
global map userset_to_string = $[
    // the type of user set
    `system:    _("&System Users"),
    // the type of user set
    `local:     _("&Local Users"),
    // the type of user set
    `nis:       _("&NIS Users"),
    // the type of user set
    `ldap:      _("L&DAP Users"),
    // the type of user set
    `samba:     _("Sam&ba Users"),
    // the type of user set
    `custom:    _("&Custom")
];

// values to MenuItem in Summary dialog
global map groupset_to_string = $[
    // the type of group set
    `system:    _("&System Groups"),
    // the type of group set
    `local:     _("&Local Groups"),
    // the type of group set
    `nis:       _("&NIS Groups"),
    // the type of group set
    `ldap:      _("L&DAP Groups"),
    // the type of group set
    `samba:     _("Sam&ba Groups"),
    // the type of group set
    `custom:    _("&Custom")
];


/**
 * Read all the settings
 * @param abort the abort block
 * @param useUI boolean use user interface (change progress bar)
 * @return symbol `next if success, else `abort
 */
global define symbol Read (block abort, boolean useUI) ``{

	// progress caption
	string caption = _("Initializing user and group configuration");
	integer no_of_steps = 9;

	// We do not set help text here, because it was set outside
	if( useUI )
	    Progress::New (caption, " ", no_of_steps,
			// progress stage label
		       [ _("Read the default login settings"),
			// progress stage label
			 _("Read the default system settings"),
			// progress stage label
			 _("Read the configuration type"),
			// progress stage label
			 _("Build the data structures"),
			// progress stage label
			 _("Read the password settings"),
			// progress stage label
			 _("Read the group settings"),
			// progress stage label
			 _("Read the user settings"),
			// progress stage label
			 _("Read the custom settings"),
			// progress stage label
			 _("Build the cache structures")
           ],
			// progress step label
		       [ _("Reading the default login settings..."),
			// progress step label
			 _("Reading the default system setttings..."),
			// progress step label
			 _("Reading the configuration type..."),
			// progress step label
			 _("Building the data structures..."),
			// progress step label
			 _("Reading the password settings..."),
			// progress step label
			 _("Reading the group settings..."),
			// progress step label
			 _("Reading the user settings..."),
			// progress step label
			 _("Reading the custom settings..."),
			// progress step label
			 _("Building the cache structures..."),
			// final progress step label
			 _("Finished") ],
			    "" );

	// read default login settings
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    UsersCache::PrintDate ("begin");

	if ( ! ReadLoginDefaults(useUI) )
	{
		// warning popup
	    Report::Warning (_("Cannot read the default login settings."));
	}

    if ( !CheckHomeMounted())
    {
        if (Mode::cont)
            return `nextmodule; // what to return during install ??
        else
            return `back;
    }

	// read default system settings
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

	if ( ! ReadSystemDefaults() )
	{
		// error popup
	    Report::Error (_("Cannot read the default systems settings."));
	}

	// read configuration type
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    UsersCache::PrintDate ("before sources");

    ReadSourcesSettings();

    if ( is_nis_master && useUI)
    {
        string dir = ReadNISConfigurationType (base_dir);
        if (dir == nil)
            return `abort; // aborted in NIS server dialog
        else
            base_dir = dir;
    }

	// run script for pre-building structures
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    tmpdir = SCR::Read(.target.tmpdir);
    UsersCache::PrintDate ("bef run prepare");

    if ( !RunPrepare("passwd") )
    {
	    Report::Error (_("Cannot run preparation script."));
    }
    UsersCache::PrintDate ("after run prepare");

	// read password settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    UsersCache::PrintDate ("before read");

    gshadow = ReadGshadow(tmpdir);

    UsersCache::PrintDate ("gshadow");

    shadow = ReadShadow (tmpdir);
    UsersCache::PrintDate ("shadow");

    plus_shadow = ReadPlusShadow(tmpdir);
    plus_gshadow = ReadPlusGshadow(tmpdir);

	if ( (gshadow == nil) || (shadow == nil) )
    {
		// error popup
	    Report::Error (_("Cannot read the password settings."));
	    //return `abort;
    }

	// read group settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    groups = ReadGroups(tmpdir);
    UsersCache::PrintDate ("groups");
    groups_by_name = ReadGroupsByName(tmpdir);
    UsersCache::PrintDate ("groups_by_name");
    plus_group = ReadPlusGroup(tmpdir);

	if ( groups [`local]:nil == nil )
    {
		// error popup (settings of local groups)
	    Report::Error (_("Cannot read the local group settings."));
        groups [`local] = $[];
    }
    if ( groups [`system]:nil == nil)
    {
		// error popup (settings of system groups)
	    Report::Error (_("Cannot read the system group settings."));
        groups [`system] = $[];
    }

	// read user settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    users = ReadPasswd (tmpdir);
    UsersCache::PrintDate ("users");

    plus_passwd = ReadPlusPasswd (tmpdir);
    users_by_name = ReadPasswdByName (tmpdir);
    UsersCache::PrintDate ("users_by_name");

	if (users [`local]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the local user settings."));
        users [`local] = $[];
    }
    if ( users [`system]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the system user settings."));
        users [`system] = $[];
    }

	// read customs
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    ReadCustomSets();

    // There is no progress for this !!!
    ReadAllShells();
    ReadDefaultGroup(useUI);

	// build the cache
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    ReadUsersCache(true);
    UsersCache::PrintDate ("cache");

	// increase the progress to "finish"
	if( useUI ) Progress::NextStage ();

	return `next;
}

/**
 * Saves users into the system
 * @param abort abort block
 * @param useUI if user interface (progress bar and popups) should be used
 * @return symbol `next for success, `abort otherwise
 */
global define symbol Write (block abort, boolean useUI)``{

    string write_dir = base_dir;//"/tmp"; // -- just for testing

	// progress caption
	string caption = _("Writing user and group configuration...");
	integer no_of_steps = 8;

	// We do not set help text here, because it was set outside
	if( useUI )
	    Progress::New (caption, " ", no_of_steps, [
			// progress stage label
			_("Back up the configuration files"),
			// progress stage label
			_("Write groups"),
			// progress stage label
			_("Check for deleted users"),
			// progress stage label
			_("Write users"),
			// progress stage label
			_("Write passwords"),
			// progress stage label
			_("Write LDAP users and groups"),
			// progress stage label
			_("Write the custom settings"),
			// progress stage label
		    _("Write the default login settings")
           ],
			// progress step label
		  [ _("Creating backup of configuration files..."),
			// progress step label
			_("Writing groups..."),
			// progress step label
			_("Checking deleted users..."),
			// progress step label
			_("Writing users..."),
			// progress step label
			_("Writing passwords..."),
			// progress step label
			_("Writing LDAP users and groups..."),
			// progress step label
			_("Writing the custom settings..."),
			// progress step label
		    _("Writing the default login settings..."),
			// final progress step label
			_("Finished") ],
			    "" );

	// backup
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (modified) // TODO better structure of modfied
        BackupConfFiles(base_dir); // should be removed at the end?


    // write group before passwd! (bug #24130)
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (modified)
    {
        if (! WriteGroup (write_dir, groups [`system]:$[], groups[`local]:$[],
             plus_group))
        {
            if (useUI)
                // error popup
                Report::Error (_("Cannot write group file."));
            else
                y2error("Cannot write group file.");
        }
    }

    // check for deleted users (-> remove homes)
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    // currently there are deleted users in MOdified_users
    foreach (`uid, `user, modified_users [`local]:$[], ``{
        if (user["delete_home"]:false)
        {
            // TODO (check): what if the home was changed??
            string home = user["home"]:"";
            y2milestone ("The directory %1 is deleted", home);
            string command = sformat("/bin/rm -rf %1", home);
            y2debug("rm (%1) return value: %2", command,
                SCR::Execute(.target.bash, command));
        }
    });
    foreach (`uid, `user, modified_users [`system]:$[], ``{
        if (user["delete_home"]:false)
        {
            // -- what if the home was changed??
            string home = user["home"]:"";
            y2milestone ("The directory %1 is deleted", home);
            string command = sformat("/bin/rm -rf %1", home);
            y2debug("rm (%1) return value: %2", command,
                SCR::Execute(.target.bash, command));
        }
    });

    // write passwd
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    if (modified)
    {
        // add the edited or new users to modified_users
        modified_users [`passwd] = WritePasswd (write_dir, users [`system]:$[],
            users[`local]:$[], plus_passwd);
    }

    if (modified_users [`passwd]:$[] == nil)
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write passwd file."));
        else
            y2error ("Cannot write passwd file.");
        modified_users [`passwd] = $[];
    }

    // check for homedir changes
    foreach (`uid, `user, modified_users [`passwd]:$[], ``{
        string home = user["home"]:"";
        string username = user["username"]:"";
        string command = "";
        if (user["modified"]:`nothing == `added)
        {
            if (user["create_home"]:true)
            {
                // create a path to new home directory, if not exists
                string home_path = substring (home,0, findlastof(home,"/"));
                if (SCR::Read(.target.stat, home_path) == $[])
                    SCR::Execute(.target.mkdir, home_path);
                y2milestone ("The directory %1 is created", home);
                // copy homedir from skel
                command = sformat("/bin/cp -r %1 %2",default_skel,home);
                y2debug("cp (%1) return value: %2", command,
                    SCR::Execute(.target.bash, command));
            }
            // change the rights
            string groupname = user["groupname"]:default_groupname;
            command = sformat("/bin/chown -R %1:%2 %3",username,groupname,home);
            y2debug("chown (%1) return value: %2", command,
                SCR::Execute(.target.bash, command));
            // call the useradd.local (-- check the existence ??)
            command = sformat("/usr/sbin/useradd.local %1", username);
            y2debug("useradd.local return value: %1",
                SCR::Execute(.target.bash, command));
        }
        else // only `edited can be here
        {
            string org_home = user["org_home"]:home;
            if (home != org_home)
            {
                if (user["create_home"]:true) // move the home directory
                {
                    string home_path = substring (home,0, findlastof(home,"/"));
                    if (SCR::Read(.target.stat, home_path) == $[])
                        SCR::Execute(.target.mkdir, home_path);
                    y2milestone ("The directory %1 is moved to %2",
                        org_home, home);
                    command = sformat("/bin/mv %1 %2", org_home, home);
                    y2debug("mv (%1) return value: %2", command,
                        SCR::Execute(.target.bash, command));
                }
                else // directory already exists
                {
                    // change the rights
                    string groupname = user["groupname"]:default_groupname;
                    command = sformat("/bin/chown -R %1:%2 %3", username,
                        groupname, home);
                    y2debug("chown (%1) return value: %2", command,
                        SCR::Execute(.target.bash, command));
                }
            }
            integer org_uid = user["org_uid"]:uid;
            string groupname = user["groupname"]:default_groupname;
            if (uid != org_uid)
            {
                // change the rights of user's files
                y2milestone ("UID of user %1 was changed, changing rights of files in %2", username, home);
                command = sformat("/bin/chown -R %1:%2 %3", username,
                    groupname, home);
                y2debug("chown (%1) return value: %2", command,
                    SCR::Execute(.target.bash, command));
            }
        }
    });
    // shadow, gshadow
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    if (modified)
    {
        // TODO send whole structure and decide in the write function
        if (! WriteShadow(write_dir, shadow[`system]:$[], shadow[`local]:$[],
                plus_shadow))
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write shadow file."));
            else
                y2error ("Cannot write shadow file.");
        }

        if (! WriteGshadow(write_dir, gshadow[`system]:$[], gshadow[`local]:[],
                plus_gshadow))
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write gshadow file."));
            else
                y2error ("Cannot write gshadow file.");
        }
    }

    // call make on NIS server
    if (modified && is_nis_master)
    {
        map ret = SCR::Execute(.target.bash_output, "/usr/bin/make -C /var/yp");
        if (ret["exit"]:1 != 0)
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot make NIS database."));
            else
                y2error("Cannot make NIS database: %1", ret);
        }
    }

    // ldap users and groups
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (ldap_modified)
    {
        boolean succ = true;

        if (ldap_bind_pass == "" && useUI)
            ldap_bind_pass = GetLDAPPassword();

        if (useUI)
        {
            while (ldap_bind_pass != nil && !LDAPBindCheck())
            {
                // error popup (probably bad password)
                UI::ErrorPopup(_("There was a problem with connecting the LDAP server."));
                ldap_bind_pass = GetLDAPPassword();
            }
        }

        // cancel returns nil!
        if (ldap_bind_pass != nil)
        {
            WriteLDAPPrepare (tmpdir, ldap_bind_pass);
            // there are deleted users in modified_users [`ldap]
            if (size (modified_users [`ldap]:$[]) > 0)
            {
                succ = WriteLDAPUsers (
                    modified_users [`ldap]:$[], is_ldap_server, tmpdir);
            }

            // now write all other modifications
            succ = succ && WriteLDAPUsers (
                users [`ldap]:$[], is_ldap_server, tmpdir);

            if (!succ)
            {
                if (useUI)
                    // error popup
	                Report::Error (_("Cannot write LDAP users."));
                else
                    y2error ("Cannot write ldap users.");
            }

            succ = true;
            // there are deleted groups in modified_groups [`ldap]
            if (size (modified_groups [`ldap]:$[]) > 0)
            {
                succ = WriteLDAPGroups (modified_groups [`ldap]:$[], tmpdir);
            }

            // now write all other groups modifications
            succ = succ && WriteLDAPGroups (groups [`ldap]:$[], tmpdir);

            if (!succ)
            {
                if (useUI)
                    // error popup
	                Report::Error (_("Cannot write LDAP groups."));
                else
                    y2error ("Cannot write ldap groups.");
            }

            WriteLDAPFinish(tmpdir); // temporary files _must_ be removed!
        }
    }


    // customs
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (customs_modified)
        WriteCustomSets();

    // useradd defaults
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (defaults_modified)
        WriteLoginDefaults();

    // mail forward from root
    if (Mode::cont && root_mail != "")
    {
        if (! MailAliases::SetRootAlias (root_mail))
            // error popup
            Report::Error(_("There was an error while setting forwarding for root's mail."));
    }

	// increase the progress to "finish"
	if( useUI ) Progress::NextStage ();

    // do not show user in first dialog when all has been writen
    if (Mode::cont)
    {
        use_next_time = false;
        saved_user = $[];
        user_in_work = $[]; // TODO: move to Commit?
    }

	return `next;
}


/**
 * Summary for autoinstalation
 * @return summary of the current configuration
 */
global define string Summary() ``{

    string ret = "";
    //"Summary of users and groups:<br>";

    // show only modified system and all local ones
    ret = ret + "<h3>Users</h3>";
    foreach (`type, [`local, `system], ``{
        foreach (`uid, `user, users [type]:$[], ``{
            if (user ["modified"]:`nothing != `nothing)
                ret = ret + sformat(" %1 %2 %3<br>", uid, user["username"]:"",
                    user["fullname"]:"" );
        });
    });
    ret = ret + "<h3>Groups</h3>";
    foreach (`type, [`local, `system], ``{
        foreach (`gid, `group, groups [type]:$[], ``{
            if (group ["modified"]:`nothing != `nothing)
                ret = ret + sformat(" %1 %2<br>", gid, group["groupname"]:"");
        });
    });

    return ret;
}


/**
 * Converts autoyast's user's map for users module usage
 */
define map ImportUser (map user) ``{

    string forename = user["forename"]:"";
    string surname = user["surname"]:"";
    string fullname = "";
    string username = user["username"]:"";
    integer uid = user["uid"]:-1;

    if( forename != "" )
    {
        if( surname != "") fullname = forename + " " + surname;
        else fullname = forename;
    }
    else fullname = surname;

    symbol type = `local;
    if ((uid <= max_system_uid || username == "nobody") && uid != -1)
        type = `system;

    map user_shadow = user ["password_settings"]:$[];
    string pass = user ["user_password"]:"x";

	if (!user["encrypted"]:true && pass != "x" && !Mode::config)
	{
		// encrypt password for shadow
		if (encryptionMethod == "md5")
			pass = cryptmd5 (pass);
		else if (encryptionMethod == "blowfish")
			pass = cryptblowfish (pass);
		else
			pass = crypt (pass);
	}

    user_shadow = add (user_shadow, "password", pass);

    if (uid == -1)
    {
        // check for existence of user -> change it
        map existing = GetUserByName (username);
        if (existing != $[])
        {
            type = existing ["type"]:`system; // these should be system
            // change only imported values...
            if (!haskey (user,"password_settings")) {
                user_shadow = shadow [type, username]:$[];
                // real password is in shadow
				user_shadow["password"] =
                    ( pass != "x") ? pass : shadow[type,username,"password"]:"x";
		    }
			string finalpw = "";
			if (pass != "x")
				finalpw = pass;
			else
				finalpw = existing["password"]:"x";

            if (!haskey (user,"forename") && !haskey (user, "surname"))
                fullname = existing["fullname"]:"";
            map ret = $[
                "encrypted":    user ["encrypted"]:existing["encrypted"]:true,
                "password":     finalpw,
                "username":     username,
                "forename":     user["forename"]:existing["forename"]:"",
                "surname":      user["surname"]:existing["surname"]:"",
                "fullname":     fullname,
                "shell":        user ["shell"]:existing["shell"]:default_shell,
                "uid":          existing["uid"]:-1,
                "gid":          user ["gid"]:existing["gid"]:default_gid,
                "grouplist":    user ["grouplist"]:"",
                "home":         user ["home"]:existing["home"]:"",
                "type":         type,
                "modified":     `imported,
                "shadow":       user_shadow
            ];

            return ret;
        }
    }

    return $[
        "encrypted":        user ["encrypted"]:true,
        //can be distinct (uncrypted) from pass (which is always crypted)
        "password":         user ["user_password"]:"x",
        "username":         user ["username"]:"",
        "forename":         forename,
        "surname":          surname,
        "fullname":         fullname,
        "shell":            user ["shell"]:default_shell,
        "uid":              uid,
        "gid":              user ["gid"]:default_gid,
        "grouplist":        user ["grouplist"]:"",
        "home":             user ["home"]:"",
        "type":             type,
        "modified":         `imported,
        "shadow":           user_shadow
    ];
};

/**
 * Converts autoyast's group's map for groups module usage
 */
define map ImportGroup (map group) ``{

    string groupname = group["groupname"]:"";
    symbol type = `local;
    if ((group["gid"]:-1 <= max_system_gid ||
        groupname == "nobody" ||
        groupname == "nogroup") &&
        groupname != "users")

        type = `system;
    return $[
        "password":         group ["group_password"]:"x",
        "groupname":        groupname,
        "gid":              group ["gid"]:-1,
        "userlist":         group ["userlist"]:"",
        "modified":         `imported,
        "type":             type
    ];
};

/**
 * Get all the user configuration from the list of maps.
 * Is called users_auto (preparing autoinstallation data).
 * @param settings	A list of maps of type:
 * [ users, groups, useradds_defaults ]
 * to be added to the system.
 * @return true
 */
global define boolean Import (map settings) ``{

    y2debug("importing: %1", settings);

    if (settings["user_defaults"]:$[] == $[])
        ReadLoginDefaults(false);
    else
    {
        useradd_defaults = settings["user_defaults"]:$[];
        defaults_modified = true;
    }

    ReadSystemDefaults();
    tmpdir = SCR::Read(.target.tmpdir);
    RunPrepare("passwd");

    // --- get shadow
    map all_shadow = ReadShadow (tmpdir);
    shadow [`system] = all_shadow[`system]:$[];
    shadow [`local] = $[];

    plus_shadow = ReadPlusShadow(tmpdir);

    // --- get users
    map passwd_users = ReadPasswd (tmpdir);

    // system users must be read every time and compared with imported ones
    users [`system] = passwd_users [`system]:$[];
    users [`local] = $[];

    users_by_name [`system] = UsersByName (users[`system]:$[]);
    users_by_name [`local] = $[];

    if (settings["users"]:[] != [] || settings["groups"]:[] != [])
        modified = true;

    // Problem: what if UID is not provided?
    list without_uid = [];

    foreach (`imp_user, settings["users"]:[], ``{
        map user = ImportUser (imp_user);
        symbol type = user ["type"]:`local;
        integer uid = user ["uid"]:-1;
        string username = user["username"]:"";
        if (uid == -1)
            without_uid = add (without_uid, user);
        else
        {
            users [type] = add (users[type]:$[], uid, user);
            users_by_name [type] = add (users_by_name[type]:$[], username,uid);
            // TODO: what if uid was changed??

            // update shadow
            shadow[type] = add (shadow[type]:$[], username, user["shadow"]:$[]);
        }
    });

    // these are _ugly hacks_ to import users without UIDs...
    // TODO: use User::Add & Commit for them
    if (size (without_uid) > 0)
    {
        list uids = UsersCache::BuildUIDList (users[`local]:$[]);
        integer last = uids [ size(uids)-1 ]:max_system_uid;
        foreach (`user, without_uid, ``{
            // new local user -> generate new uid (use Commit?)
            integer uid = last + 1;
            while (contains (uids, uid))
                uid = uid + 1;
            uids = add (uids, uid); last = uid;
            user ["type"] = `local;
            user ["uid"] = uid;
            users [`local] = add (users[`local]:$[], uid, user);
            users_by_name [`local] = add (users_by_name[`local]:$[],
                user["username"]:"", uid);
        });
    }

    plus_passwd = ReadPlusPasswd (tmpdir);// TODO use this for autoinstall??

    // --- get gshadow
    map all_gshadow = ReadGshadow (tmpdir);
    gshadow [`system] = all_gshadow[`system]:$[];
    gshadow [`local] = $[];

    plus_gshadow = ReadPlusGshadow(tmpdir);

    // --- get groups
    map all_groups = ReadGroups (tmpdir);
    map system_groups = all_groups [`system]:$[];
    // but we're not interested in local userlists...
    system_groups = RemoveDiskUsersFromGroups(system_groups);
    // group users should be `local
    if (system_groups [100, "groupname"]:"" == "users")
        system_groups = remove (system_groups, 100);
    if (system_groups [500, "groupname"]:"" == "users")
        system_groups = remove (system_groups, 500);

    groups [`system] = system_groups;
    groups [`local] = $[];

    foreach (`imp_group, settings["groups"]:[], ``{
        map group = ImportGroup (imp_group);
        symbol type = group ["type"]:`local;
        string groupname = group ["groupname"]:"";
        groups [type] = add (groups[type]:$[], group["gid"]:-1, group);
        // TODO: what if gid was changed??

        // update gshadow
        map gshadow_entry = gshadow [type, groupname]:$[];
        if (gshadow_entry == $[])
        {
            gshadow_entry = $["password":"*", "disposer":"root", "userlist":""];
        }
        gshadow_entry ["userlist"] = group["userlist"]:"";
        string pass = group["password"]:"x";
        if ( pass != "x" && pass != "*" && pass != "!" )
            gshadow_entry ["password"] = pass;

        gshadow [type] = add (gshadow[type]:$[], group ["groupname"]:"",
            gshadow_entry);
    });

    if (groups[`local, 100, "groupname"]:"" != "users" &&
        groups[`local, 500, "groupname"]:"" != "users")
    {
        // group users must be created
        map group = $[
             "gid": default_gid, "groupname": "users",
             "password": "x", "userlist": ""];
        groups [`local] = add (groups [`local]:$[], default_gid, group);
        gshadow [`local] = add (gshadow [`local]:$[], "users",
            $[ "password": "*", "disposer": "root", "userlist": ""]);
    }

    groups_by_name [`system] = GroupsByName (groups [`system]:$[]);
    groups_by_name [`local] = GroupsByName (groups [`local]:$[]);

    plus_group = ReadPlusGroup(tmpdir);

    available_usersets = [`local, `system];
    available_groupsets = [`local, `system];

    ReadAllShells();
    ReadDefaultGroup(false);

    // define more_users (for groups), grouplist and groupname (for users)
    // TODO move this block to ReadCache?
    foreach (`type, [`system, `local], ``{

        foreach (`uid, `user, users [type]:$[], ``{
            string username = user["username"]:":";
            user ["grouplist"] = FindGroupsBelongUser (username);
            integer gid = user["gid"]:default_gid;
            // hack: change of default group's gid - is it correct?
            if (gid == 100 && default_gid != 100)
            {
                gid = default_gid;
                user ["gid"] = gid;
            }
            map group = GetGroupFromAll (gid);
            user ["groupname"] = group ["groupname"]:default_groupname;
            users [type, uid] = user;

            // update the group's more_users (use Commit?)
            string more_users = group ["more_users"]:"";
            list more_list = splitstring (more_users, ",");
            if (! contains (more_list, username))
            {
                if (more_users != "") more_users = more_users + ",";
                group ["more_users"] = more_users + username;
                groups [ group["type"]:`local, gid] = group;
            }
        });
    });

    ReadUsersCache(false);
    return true;
}


/**
 * Reseting the values (probably to empty set) - to use for autoinstallation
 * @param settings same as in Import
 */
global define void Set (list settings) ``{

    // what about system users/groups ??

    users [`local] = settings[0, `local]:$[];
    users_by_name [`local] = UsersByName (users [`local]:$[]);

    groups [`local] = settings[1, `local]:$[];
    groups_by_name [`local] = GroupsByName (groups [`local]:$[]);

    shadow [`local] = settings[2, `local]:$[];
    gshadow [`local] = settings[3, `local]:$[];

    if (settings[4]:$[] != $[])
        useradd_defaults = settings[4]:$[];

    UsersCache::EmptyStructures();
    ReadUsersCache(false);
}

/**
 * Converts user's map for autoyast usage
 */
define map ExportUser (map user) ``{

    symbol type = user["type"]:`local;
    string full = user["fullname"]:"";
    string username = user["username"]:"";
    map user_shadow = user ["shadow"]:shadow[type, username]:$[];
    string pass = user_shadow["password"]:user ["password"]:"x";
    if (user_shadow != $[])
        user_shadow = remove (user_shadow, "password");

    return $[
        "encrypted":        user ["encrypted"]:true,
        "user_password":    pass,
        "username":         username,
        "forename":         SplitFullName (`forename, full, type),
        "surname":          SplitFullName (`surname, full, type),
        "shell":            user ["shell"]:default_shell,
        "uid":              user ["uid"]:-1,
        "gid":              user ["gid"]:default_gid,
        "grouplist":        user ["grouplist"]:"",
        "home":             user ["home"]:"",
        "password_settings":user_shadow
    ];

};

/**
 * Converts group's map for autoyast usage
 */
define map ExportGroup (map group) ``{

    return $[
        "group_password":   group ["password"]:"x",
        "groupname":        group ["groupname"]:"",
        "gid":              group ["gid"]:-1,
        "userlist":         group ["userlist"]:""
    ];
};


/**
 * Dump the users settings to list of maps
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export() ``{

    // all local users:
    list exported_users = [];
    // local users when modified
    foreach (`uid, `user, users[`local]:$[], ``{

        if (user ["modified"]:`nothing != `nothing || ExportAll)
        {
            exported_users = add (exported_users, ExportUser(user));
        }
    });
    /* deleted system users (??):
    foreach (`uid, `user, modified_users[`system]:$[], ``{
        exported_users = add (exported_users, ExportUser(user));
    });*/

    // modified system users:
    foreach (`uid, `user, users[`system]:$[], ``{

        if (user["modified"]:`nothing != `nothing || ExportAll)
        {
            exported_users = add (exported_users, ExportUser(user));
        }
    });

    list exported_groups = [];
    // modified local system groups:
    foreach (`uid, `group, groups[`local]:$[], ``{

        if (group ["modified"]:`nothing != `nothing || ExportAll)
        {
            exported_groups = add (exported_groups, ExportGroup(group));
        }
    });
    /* deleted system groups (??):
    foreach (`uid, `group, modified_groups[`system]:$[], ``{
        exported_groups = add (exported_groups, ExportGroup(group));
    });*/

    // modified system groups:
    foreach (`uid, `group, groups[`system]:$[], ``{

        if (group ["modified"]:`nothing != `nothing || ExportAll)
        {
            exported_groups = add (exported_groups, ExportGroup(group));
        }
    });

    return $[
        "users": exported_users,
        "groups": exported_groups,
        "user_defaults": useradd_defaults
    ];

}

/**
 * Helper function, which corects the userlist entry of each group.
 * During autoinstallation, system groups are loaded from the disk,
 * and the userlists of these groups can contain the local users,
 * which we don not want to Import. So they are removed here.
 * @param disk_groups the groups loaded from local disk
 * @return corrected map of groups
 */
global define map RemoveDiskUsersFromGroups (map disk_groups) ``{

	map ret = mapmap (`gid, `group, disk_groups, ``{

        map new_group = group;

        foreach (`list_of_users, ["userlist", "more_users"], ``{

            list userlist = splitstring (group[list_of_users]:"", ",");
            string userlist_s = "";
            foreach (`username, userlist, ``{
                if (haskey (users_by_name [`system]:$[], username) ||
                    haskey (users_by_name [`local]:$[], username))
                {
                    if (userlist_s == "")
                        userlist_s = username;
                    else
                        userlist_s = userlist_s + "," + username;
                }
            });
            new_group[list_of_users] = userlist_s;
        });

	    return [ gid, new_group ];
	});

    return ret;
}

// prepare user/group_in_work for Commit
global define boolean Add (string what, map data)``{

    if (what == "user")
        user_in_work = $[];
    else
        group_in_work = $[];
    //create some default values
    return true;
}

global define boolean Edit (string what, map data)``{

    // find user/group and prepare (user|group)_in_work
    return true;
}

global define boolean Delete (string what, map data)``{

    // find user/group and prepare (user|group)_in_work
    return true;
}


/**
 * Update the global user and/or group map with current
 * user_in work or group_in_work
 * @param object "user" or "group"
 * @param cache if cache structures (from UsersCache) should be updated
 * @return true on success
 */
global define boolean Commit (string object, boolean cache)``{

    modified = true;

    if (object == "user")
    {
//y2warning("user : %1", user_in_work );
        integer uid = user_in_work ["uid"]:max_uid;
        integer org_uid = user_in_work ["org_uid"]:uid;
        symbol what_user = user_in_work ["what"]:`nothing;
        symbol type = user_in_work ["type"]:`local;
        string username = user_in_work ["username"]:"";
        string org_username = user_in_work ["org_username"]:username;
        string grouplist = user_in_work ["grouplist"]:"";
        string defgroup = user_in_work ["groupname"]:default_groupname;
        list group_list = splitstring (grouplist, ",");//remove ""
        group_list = filter (`g, group_list, ``(g != ""));

        if (type == `ldap && what_user != `group_change)
            ldap_modified = true;

        // the action
        if ( what_user == `add_user )
        {
            // when writing the new user, the new home has to be created
            user_in_work ["modified"] = `added;
            // update the affected groups
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[])
                {
                    y2error("Group %1 doesn't exist!", group);
                }
                else
                {
                    group_in_work ["what"] = `user_change;
                    string userlist = group_in_work ["userlist"]:"";
                    list userlist_l = splitstring (userlist, ",");
                    if (!contains(userlist_l, username))
                    {
                        if (userlist != "") userlist = userlist + ",";
                        group_in_work ["userlist"] = userlist + username;
                        Commit ("group", cache);
                    }
                }
            });
            // add user to his default group -- updating only cache variables
            group_in_work = GetGroupByName (defgroup, type);
            if (group_in_work == $[])
            {
                y2error("Group %1 doesn't exist!", defgroup);
            }
            else
            {
                group_in_work ["what"] = `user_change_default;
                string more_users = group_in_work ["more_users"]:"";
                if (more_users != "") more_users = more_users + ",";
                group_in_work ["more_users"] = more_users + username;
                Commit ("group", cache);
            }
            // modify global shadow map:
            shadow [type] = add(shadow [type]:$[],
                 username, user_in_work["shadow"]:$[]);
        }
        else if ( what_user == `edit_user )
        {
            if (user_in_work ["modified"]:`nothing != `added)
                user_in_work ["modified"] = `edited;
            // check the change of additional group membership
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[]) return;
                string userlist = group_in_work ["userlist"]:"";
                list l_userlist = splitstring (userlist, ",");
                // username changed
                if ((org_username != username) &&
                    (contains (l_userlist, org_username)))
                {
                    group_in_work ["what"] = `user_change;
                    l_userlist = filter (`u, l_userlist, ``(u != org_username));
                    userlist = mergestring (l_userlist, ",");
                    if (userlist != "") userlist = userlist + ",";
                    group_in_work ["userlist"] = userlist + username;
                    Commit ("group", cache);
                }
                // user was added to the new group
                else if (!contains (l_userlist, org_username))
                {
                    group_in_work ["what"] = `user_change;
                    if (userlist != "") userlist = userlist + ",";
                    // username can be changed here
                    group_in_work ["userlist"] = userlist + username;
                    Commit ("group", cache);
                }
            });
            // check the removing user from some additional group
            list removed_group_list = user_in_work ["removed_grouplist"]:[];
            foreach (`group, removed_group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[]) return;
                string userlist = group_in_work ["userlist"]:"";
                list l_userlist = splitstring (userlist, ",");
                if (contains (l_userlist, org_username)) // always true?
                {
                    group_in_work ["what"] = `user_change;
                    l_userlist = filter (`u, l_userlist, ``(u != org_username));
                    userlist = mergestring (l_userlist, ",");
                    group_in_work ["userlist"] = userlist;
                    Commit ("group", cache);
                }
            });
            // check the change in default group
            string org_defgroup = user_in_work ["org_groupname"]:defgroup;
            if ((username != org_username) && (defgroup == org_defgroup))
            {
                // change the user's name in current default group
                group_in_work = GetGroupByName (defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change_default;
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            else if (defgroup != org_defgroup)
            {
                // note: username could be also changed!
                // remove the name from original group ...
                group_in_work = GetGroupByName (org_defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change_default;
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    group_in_work ["more_users"] = more_users;
                    Commit ("group", cache);
                }
                // and add it to the new one;
                group_in_work = GetGroupByName (defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change_default;
                    string more_users = group_in_work ["more_users"]:"";
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            // modify the shadow entry
            if (type == `local || type == `system) // - also for groups !
            {
                if (username != org_username)
                    if (haskey (shadow[type]:$[], org_username))
                        shadow [type] = remove (shadow[type]:$[], org_username);
                shadow [type, username] = user_in_work["shadow"]:$[];
            }
        }
        else if ( what_user == `delete_user )
        {
            // check the change of group membership
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work != $[])
                {
                    string userlist = group_in_work ["userlist"]:"";
                    list l_userlist = splitstring (userlist, ",");
                    if (contains (l_userlist, username)) // always true?
                    {
                        group_in_work ["what"] = `user_change;
                        l_userlist = filter (`u, l_userlist, ``(u != username));
                        userlist = mergestring (l_userlist, ",");
                        group_in_work ["userlist"] = userlist;
                        Commit ("group", cache);
                    }
                }
            });
            // remove user from his default group -- only cache structures
            group_in_work = GetGroupByName (defgroup, type);
            group_in_work ["what"] = `user_change_default;
            string more_users = group_in_work ["more_users"]:"";
            list l_more_users = splitstring (more_users, ",");
            l_more_users = filter (`u, l_more_users, ``(u != username));
            more_users = mergestring (l_more_users, ",");
            group_in_work ["more_users"] = more_users;
            Commit ("group", cache);

            // prevent the add & delete of the same user
            if (user_in_work["modified"]:`nothing != `added)
            {
                user_in_work ["modified"] = `deleted;
                modified_users [type] = add (modified_users [type]:$[],
                    uid, user_in_work);
            }
            if (type != `ldap)
                shadow [type] = remove (shadow [type]:$[], org_username);
        }
        else if ( what_user == `group_change)
        {
                if (type == `ldap)
                    user_in_work ["modified"] = `edited;
                // prevent loading this argument with some unwanted value later
//                else
//                    user_in_work ["modified"] = `nothing;
        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeUser(what_user, user_in_work);

        // the main action: update users -- what if uid is changed?
        if (what_user == `delete_user)
        {
            users [type] = remove (users[type]:$[], uid);
            users_by_name [type] = remove (users_by_name[type]:[], username);
        }
        else // also `group_change !
        {
            if (uid != org_uid && haskey (users[type]:$[], org_uid))
            {
                users_by_name [type, username ] = uid;
                users [type] = remove (users [type]:$[], org_uid);
            }
            users [ type, uid ] = eval (user_in_work);

            // this has to be done due to multiple changes of username -- ??
            // and what about the home and others??
            if (type != `ldap) // for changing ldap username old one is needed
                users [type, uid, "org_username"] = username;
        }
    }
    else if ( object == "group" )
    {
        integer gid = group_in_work ["gid"]:max_gid;
        integer org_gid = group_in_work ["org_gid"]:gid;
        symbol what_group = group_in_work ["what"]:`nothing;
        symbol type = group_in_work ["type"]:`local;
        string groupname = group_in_work ["groupname"]:"";
        string password = group_in_work ["password"]:"*";
        string org_groupname = group_in_work ["org_groupname"]:groupname;
        string userlist = group_in_work ["userlist"]:"";
        list l_userlist = splitstring (userlist, ",");
//y2warning("group: %1", group_in_work);

        if (org_groupname == "")
            org_groupname = groupname;

        if (type == `ldap)
            ldap_modified = true;
        if ( what_group == `add_group )
        {
            group_in_work ["modified"] = `added;
            // update users's grouplists (only local structures)
            foreach (`user, l_userlist, ``{
                // -- what if user doesn't exist??
                user_in_work = GetUserByName (user);
                string grouplist = user_in_work ["grouplist"]:"";
                if (grouplist != "")
                   grouplist = grouplist + ",";
                user_in_work["grouplist"] = grouplist + groupname;
                user_in_work["what"] = `group_change;
                Commit("user", cache);
            });
            // create an entry for global gshadow map:
            gshadow [type] = add (gshadow[type]:$[], groupname, $[
                "password": password,
                "disposer": "root", // default??
                "userlist": ""]); // will be updated at the end
        }
        else if (what_group == `edit_group )
        {
            if (group_in_work ["modified"]:`nothing != `added)
                group_in_work ["modified"] = `edited;
            // update users's grouplists (mainly local structures)
            foreach (`user, l_userlist, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    boolean commit_user = false;
                    // new user added to group
                    if (! contains (l_grouplist, org_groupname))
                    {
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    else if (org_groupname != groupname)
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        // what about ",,"?
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    if (commit_user)
                    {
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                }
            });
            // check the additional users removed from this group
            list removed_user_list = group_in_work ["removed_userlist"]:[];
            foreach (`user, removed_user_list, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    if ( contains (l_grouplist, org_groupname))
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        user_in_work["grouplist"] = grouplist;
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                }
            });
            // correct the changed groupname/gid for users with this group
            // as default
            if ((groupname != org_groupname) || (gid != org_gid))
            {
                string more_users = group_in_work ["more_users"]:"";
                list l_more_users = splitstring (more_users, ",");
                foreach (`user, l_more_users, ``{
                    user_in_work = GetUserByName (user);
                    if (user_in_work != $[])
                    {
                        user_in_work["groupname"] = groupname;
                        user_in_work["gid"] = gid;
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                });
            }
            // modify the gshadow -- userlist ??
            if (groupname != org_groupname)
            {
                gshadow [type, groupname] = gshadow [type, org_groupname]:$[];
                if (haskey (gshadow [type]:$[], org_groupname))
                    gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            }
            if (password != "x" && password != "*" && password != "!")
                gshadow [type, groupname, "password"] = password;
        }
        else if (what_group == `delete_group )
        {
            if (group_in_work ["modified"]:`nothing != `added)
            {
                group_in_work ["modified"] = `deleted;
                modified_groups [type] = add (modified_groups [type]:$[],
                    gid, group_in_work);
            }
            groups [type] = remove (groups [type]:$[], org_gid);
            groups_by_name [type] = remove (groups_by_name [type]:$[],
                org_groupname);
            if (haskey (gshadow [type]:$[], org_groupname))
                gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            // deleted group had no members -> no user change
        }
        else if ( what_group == `user_change ) // do not call Commit again
        {
            if (group_in_work ["modified"]:`nothing != `added)
            {
                group_in_work ["modified"] = `edited;
            }
        }
        else if ( what_group == `user_change_default )
        {
            // current group is some user's default - changin only cache
            // structures and don't set modified flag
        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeGroup(what_group, group_in_work);

        if (what_group != `delete_group) // also for `change_user!
        {
            // the main action: update groups
            if (gid != org_gid && haskey (groups [type]:$[], org_gid))
                groups [ type ] = remove (groups [type]:$[], org_gid);
            groups [ type, gid ] = group_in_work;

            // name could have been changed !!
            if (groupname != org_groupname &&
                haskey (groups_by_name [type]:$[], org_groupname))
                groups_by_name [type] = remove (groups_by_name [type]:$[],
                    org_groupname);
            groups_by_name [type, groupname] = group_in_work;

            // update userlist in gshadow
            if (haskey (gshadow [type]:$[], groupname))
                gshadow [type, groupname, "userlist"] = userlist;

            // this has to be done due to multiple changes of groupname ??
            if (type != `ldap)
                groups [type, gid, "org_groupname"] = groupname;
        }
    }
    return true;
}
/**
 * Checks the possible user sources
 */
global define void ReadSourcesSettings () ``{

    available_usersets = [ `local, `system ];
    available_groupsets = [ `local, `system ];

    user_sources = GetUsersSources ();
    is_nis_available = IsNISAvailable (user_sources);
    is_nis_master = IsNISMaster ();
    is_ldap_available = IsLDAPAvailable (user_sources);
    kerberos_auth = KerberosAuth();

    if ( !is_nis_master && is_nis_available )
    {
            available_usersets = add ( available_usersets, `nis);
            available_groupsets = add ( available_groupsets, `nis);
    }

    if ( is_ldap_available )
    {
        ldap_base = GetLDAPBase();
        ldap_host = GetLDAPHost();
        is_ldap_server = IsLDAPServer (ldap_host);

        available_usersets = add ( available_usersets, `ldap);
        available_groupsets = add ( available_groupsets, `ldap);
    }

    available_usersets = add ( available_usersets, `custom);
    available_groupsets = add ( available_groupsets, `custom);
}

/**
 * Return map for mapping user names to UIDs
 * @param usermap map of users of type $[ uid:user's map ]
 * @return new mapping of type $[ username: uid ]
 */
global define map UsersByName (map usermap) ``{
	map res = mapmap (`k, `v, usermap, ``{
	    return [ lookup (v, "username", ""), k ]; // only uid !!
	});
	return res;
}

/**
 * Maps groupname to group's map
 * @param groupsmap map of groups of type $[ gid:group's map ]
 * @return new mapping of type $[ groupname: group's map ]
 */
global define map GroupsByName (map groupsmap) ``{
	map res = mapmap (`k, `v, groupsmap, ``{
	    return [ lookup (v, "groupname", ""), v ]; // whole map??
	});
	return res;
}

/**
 * Fills the variables with the default values
 * (used only for better access)
 * @param useUI if UI is used
 */
define void SetDefaultValues(boolean useUI) ``{

    pass_inact_days  = tointeger( useradd_defaults["inactive"]:"-1" );
    pass_expire_date = useradd_defaults["expire"]:"";

    default_shell = useradd_defaults["shell"]:default_shell;
    default_skel = useradd_defaults["skel"]:default_skel;
    default_expire = useradd_defaults["expire"]:default_expire;
    default_inactive = useradd_defaults["inactive"]:default_inactive;
    default_home = GetDefaultHome(useUI);
}

/**
 * Reads settings from /etc/defaults/useradd
 * @param useUI if UI is used
 * @return true on success
 */
global define boolean ReadLoginDefaults(boolean useUI)``{

    path useradd_path = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{
        path entry_path = add (useradd_path, key);
        useradd_defaults[key] = deletechars (SCR::Read(entry_path), "\"");
    });

    if( useradd_defaults == $[] || useradd_defaults == nil )
	    return false;

    SetDefaultValues(useUI);
    return true;
}

/**
 * Writes settings to /etc/defaults/useradd
 * @return true on success
 */
global define boolean WriteLoginDefaults()``{

    boolean ret = true;
    path useradd = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{

        ret = ret && SCR::Write( add(useradd, key), value);
    });

    y2milestone ("Succesfully written useradd defaults: %1", ret);
    return ret;
}

/**
 * Reads all possible shels and builds the itemlist for add user dialog
 * @return true
 */
define boolean ReadAllShells()``{

    all_shells = GetAllShells (`stringlist);
    all_shells_items = GetAllShells (`items);

    return true;
}

/**
 * Sets the default gid and groupname
 * @param useUI if UI is used
 * @return true
 */
define boolean ReadDefaultGroup(boolean useUI)``{

    default_gid = GetDefaultGid(useUI);
    default_groupname = lookup (GetGroupFromAll(default_gid), "groupname","");

    return true;
}

/**
 * Read the security settings from the system, sets the encoding and various
 * variables
 * @return boolean true on success
 */
global define boolean ReadSystemDefaults()``{

	// pam stuff
	map pam_unix_map = $[];
	list pam_list = SCR::Read(.pam.all.password.pam_unix2);
	if(pam_list != [] && pam_list != nil)
	    pam_unix_map = select(pam_list,0,$[]);

	map pam_check_map = $[];
	pam_list = SCR::Read(.pam.all.password.pam_pwcheck);
	if(pam_list != [] && pam_list != nil)
	    pam_check_map = select(pam_list,0,$[]);

	// set defaults
	max_uid = tointeger (SCR::Read (.etc.login_defs.UID_MAX));
	if (nil == max_uid)
	    max_uid = 60000;
    max_gid = tointeger (SCR::Read (.etc.login_defs.GID_MAX));
    if (nil == max_gid)
        max_gid = 60000;
	max_system_uid = tointeger (SCR::Read (.etc.login_defs.UID_MIN)) - 1;
    if (nil == max_system_uid)
        max_uid = 499;
    max_system_gid = tointeger (SCR::Read (.etc.login_defs.GID_MIN)) - 1;
    if (nil == max_system_gid)
        max_system_gid = 99;
	max_length_uid = size(sformat("%1", max_uid));
	max_length_gid = size(sformat("%1", max_gid));
    max_length_pas = tointeger (SCR::Read (.etc.login_defs.PASS_MAX_LEN));
    if (nil ==  max_length_pas)
        max_length_pas = 8;
    min_length_pas = tointeger (SCR::Read (.etc.login_defs.PASS_MIN_LEN));
    if (nil ==  min_length_pas)
        min_length_pas = 5;
    pass_max_days = tointeger (SCR::Read (.etc.login_defs.PASS_MAX_DAYS));
    if (nil ==  pass_max_days)
        pass_max_days = 99999;
    pass_min_days = tointeger (SCR::Read (.etc.login_defs.PASS_MIN_DAYS));
    if (nil == pass_min_days)
        pass_min_days = 0;
    pass_warn_age = tointeger (SCR::Read (.etc.login_defs.PASS_WARN_AGE));
    if (nil == pass_warn_age)
        pass_warn_age = 7;

    // add a progress for this?
    Progress::off();
    Security::Read();
    Progress::on();

    encryptionMethod = Security::Settings["PASSWD_ENCRYPTION"]:"des";

    string sec = Security::Settings["PASSWD_USE_CRACKLIB"]:"no";
    use_cracklib = (sec == "yes") ? true: false;
    sec = Security::Settings["OBSCURE_CHECKS_ENAB"]:"no";
    obscure_checks = (sec == "yes") ? true: false;

    y2debug ("encryption: %1", Users::encryptionMethod);

	// set maximal password length
	if ("des" != encryptionMethod)
	    max_length_pas = 128;

    encoding = Console::encoding;

	return true;
}


/**
 * Return a map with the defaults for the shadow entry
 * @return map of shadow settings
 */
global define map GetDefaultShadow()``{

	return	$[
           "expire"	: default_expire,
		   "inact"	: default_inactive,
           "last_change": "", // LastChangeIsNow() is called from dialogs
		   "max"	: sformat("%1", pass_max_days),
		   "min"	: sformat("%1", pass_min_days),
		   "warn"	: sformat("%1", pass_warn_age)
    ];
}

/**
 * Return the default home value for a new user.
 * @param useUI if UI is used
 * @return string home directory
 */
global define string GetDefaultHome(boolean useUI)``{

    string def_home = useradd_defaults["home"]:"/home";

    // check for existence of prefix directory
    if (SCR::Read(.target.size, def_home ) == -1 && useUI)
    {
        // Popup tex
        if (UI::YesNoPopup(sformat (_("The default home directory \"%1\" does not exist.
Create it now?
"), def_home)))
            SCR::Execute (.target.mkdir, def_home);
    }
    if ( (findlastof( def_home, "/") +1) != size(def_home ) )
    {
        def_home = def_home + "/";
    }
    return def_home;
}


/**
 * Return the default group id for a new user.
 * @param useUI if UI is used
 * @return integer gid
 */
global define integer GetDefaultGid(boolean useUI)``{

    string def_gid  = useradd_defaults["group"]:default_gid;
    integer def_int = tointeger(def_gid);
    map group = $[];

    group = GetGroupFromAll (def_int);
    if( group == $[])
    {
        if (useUI)
	        // error popup
	        Report::Error(sformat(_("The default group with the id %1 does not exist.
Please change the default group in /etc/default/useradd."), def_int ));

	    // TODO If group 100/500 does not exists ?
	    return default_gid;
    }
    return def_int;
}

/**
 * Read the /etc/shells file and return a item list or a string shell list.
 * @param todo `items or `stringlist
 * @return list of shells
 */
global define list GetAllShells(symbol todo ) ``{

	list available_shells =  [];
	list shells_read = SCR::Read(.etc.shells);

	foreach( `shell_entry, shells_read, ``{

	    if( is( shell_entry, string ))
	    {
		    if( (! issubstring( shell_entry, "passwd")) &&
		        (! issubstring( shell_entry, "bash1")) )
		    {
		        if(  SCR::Read(.target.size, shell_entry  )  != -1  )
		        {
			        if (todo == `items) available_shells = add(available_shells,
                            `item( `id(shell_entry), shell_entry ));
			        if ( todo == `stringlist ) available_shells =
                            add( available_shells, shell_entry);
		        }
		    }

	    }
	});
	return available_shells;
}



global define void ReadCustomSets() ``{

    string file = Directory::vardir + "/users_customs.ycp";
    SCR::Execute (.target.bash, sformat ("/bin/touch %1", file));
    map customs = SCR::Read (.target.ycp, file);

    user_custom_sets = customs ["users"]:[];
    if (user_custom_sets == [])
        user_custom_sets = [`local];

    group_custom_sets = customs ["groups"]:[];
    if (group_custom_sets == [])
        group_custom_sets = [`local];
}

global define boolean WriteCustomSets() ``{

    map customs = $[
        "users": user_custom_sets,
        "groups": group_custom_sets
    ];
    return
    SCR::Write (.target.ycp, Directory::vardir + "/users_customs.ycp", customs);
}


/**
 * Helper for building items of MenuButton in users/groups summary dialog
 */
global define void BuildMenuButtonItems() ``{

    available_usersets_items = [];
    foreach (`set, available_usersets, ``{
        available_usersets_items = add ( available_usersets_items,
            `item(`id(set), userset_to_string [ set ]:""));
    });

    // build the groups MenuButton items
    available_groupsets_items = [];
    foreach (`set, available_groupsets, ``{
        available_groupsets_items = add ( available_groupsets_items,
            `item(`id(set), groupset_to_string [ set ]:""));
    });

}

/**
 * Reads the settings, used for cache structures
 * @param read_prebuilded if there were some structures prebuilded by extern
 * script and should be readed from files
 */
global define void ReadUsersCache(boolean read_prebuilded) ``{

    // this is ugly -- move it to some Consts module ?
    UsersCache::max_uid         =    max_uid;
    UsersCache::max_gid         =    max_gid;
    UsersCache::max_system_uid  =    max_system_uid;
    UsersCache::max_system_gid  =    max_system_gid;
    UsersCache::max_length_uid  =    max_length_uid;
    UsersCache::max_length_gid  =    max_length_gid;

    UsersCache::encoding        =   encoding;

    // build the users MenuButton items
    BuildMenuButtonItems ();

    current_users = eval (user_custom_sets);
    current_groups = eval (group_custom_sets);

    UsersCache::user_custom_sets = user_custom_sets;
    UsersCache::group_custom_sets = group_custom_sets;

    // use the pre-builded structures also for cache
    if (read_prebuilded)
    {
        ChangeCurrentUsers (`custom); // TODO: move to UsersCache??
        ChangeCurrentGroups (`custom);
        UsersCache::ReadFromFiles (tmpdir);
    }
    else
        UsersCache::Read (users, groups, current_users, current_groups);

}

/**
 * Returns the map of users specified by its name
 * @param name user's name
 * @return the desired user's map
 */
global define map GetUserByName ( string name )``{
    map ret = $[];
    integer uid = -1;
    foreach (`type, `usernames, users_by_name, ``{
        if (ret == $[])
        {
            uid = usernames [name]:-1;
            if (uid != -1)
                ret = users [type, uid]:$[];
        }
    });
    return ret;
}

/**
 * Gets the first group with given name
 * @param name group's name
 * @param usertype type of user - group will be searched in this set for first
 * @return the desired group's map
 */
global define map GetGroupByName (string name, symbol usertype)``{
    map ret = $[];

    ret = groups_by_name [usertype, name]:$[];
    if (ret != $[])
        return ret;

    foreach (`type, `groupmap, groups_by_name, ``{
        if (ret == $[])
        {
            ret = groupmap [name]:$[];
        }
    });
    return ret;

    // FIXME: what if there are groups with same name and id ?? (local & ldap)
}

/**
 * Finds the user specified by uid and set is as current
 * @param uid the user id
 */
global define void SelectUser( integer uid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_users) )
    {
        ret = users[ current_users [i]:nil, uid ]:$[];
        if (ret != $[])
        {
            y2debug("selected user: %1", ret);
            break;
        }
        i = i + 1;
    }
    user_in_work = ret;
}

/**
 * Finds the group specified by gid and set is as current
 * @param gid the group id
 */
global define void SelectGroup( integer gid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_groups) )
    {
        ret = groups [ current_groups [i]:nil, gid ]:$[];
        if (ret != $[])
        {
            y2debug("selected group: %1", ret);
            break;
        }
        i = i + 1;
    }
	group_in_work = ret;
}

/**
 * Return the settings for a group.
 * @param gid the group id
 * @return map of group
 */
global define map GetGroupFromAll( integer gid )``{

    map group = $[];
    foreach (`grouptype, `groupset, groups, ``{
        if (group == $[])
        {
            group = groupset [gid]:$[];
        }
    });
	return group;
}

/**
 * This define returns the groups of a user.
 * @param username the name of the user
 * @return string group comma separated list
 */
global define string FindGroupsBelongUser( string username ) ``{

    string grouplist = "";
    foreach (`type, `groupset, groups, ``{
        foreach (`gid, `group, groupset, ``{
            list userlist = splitstring (group["userlist"]:"", ",");
            if (contains (userlist, username))
            {
                if (grouplist == "")
                    grouplist = group["groupname"]:"";
                else
                    grouplist = grouplist + "," + group["groupname"]:"";
            }
        });
    });
    return grouplist;
}

/**
 * Check if homedir doesn't exist for another user
 * @param home the name
 * @return true if exists
 */
global define boolean HomeExists(string home) ``{

    return UsersCache::HomeExists(home);
}

/**
 * Check if UID doesn't already exist
 * @param uid UID
 * @return true if exists
 */
global define boolean UIDExists(integer uid) ``{

    return UsersCache::UIDExists(uid);
}

/**
 * Check if username already exists
 * @param username username
 * @return true if exists
 */
global define boolean UsernameExists(string username) ``{

    return UsersCache::UsernameExists(username);
}

/**
 * Scan uidlist for the next free uid.
 * @return integer free uid
 */
global define integer NextFreeUid() ``{
    return UsersCache::NextFreeUid();
}

/**
 * Read new set of users - "on demand" (called from running module)
 * @param type the type of users, currently `ldap or `nis
 * @return success
 */
global define boolean ReadNewSet (symbol type) ``{

    if (type == `nis)
    {
        nis_not_read = false;

        UI::OpenDialog (`opt(`decorated ),
            // wait popup
            `Label(_("Reading sets of users and groups. Please wait...")));

        // first: run preparation script:
        RunPrepare ("nis");
        // read NIS users now
        users [`nis] = ReadNISUsers (tmpdir);
        users_by_name [`nis] = ReadNISUsersByName (tmpdir);
        groups [`nis] = ReadNISGroups (tmpdir);
        groups_by_name [`nis] = ReadNISGroupsByName (tmpdir);
    }
    else if (type == `ldap)
    {
        // first: check for required packages:
        if (SCR::Execute(.target.bash, "rpm -q perl-ldap cpu yast2-ldap-client") !=0)
        {
            include "require.ycp"; // is it possible to have it here??
            if (RequireAndConflict (["perl-ldap","cpu","yast2-ldap-client"], [],
                // Popup text (required application):
                _("For managing LDAP users, the packages
\"perl-ldap\", \"cpu\", and \"yast2-ldap-client\"
are necessary, but some of them are not present.
Install them now?
")) == false)
                return false;
        }
        // check for cpu.cfg
        if (!CpuConfigured (ldap_host, ldap_base))
        {
            // popup text
            if (UI::YesNoPopup(_("Your \"cpu\" program does not appear to be configured. 
It is used for updating LDAP users and groups.
Configure it now?
")))
            {
                import "Ldap"; // could it be here ??
                Ldap::Read();
                if (CallFunction(`cpu_configure(true)) == `next)
                    Ldap::WriteCpuSettings();
            }
        }
        ldap_bind_pass = GetLDAPPassword();
        if (ldap_bind_pass == nil) // cancel button
        {
            return false;
        }

        // prepare config file
        WriteLDAPPrepare (tmpdir, ldap_bind_pass);

        UI::OpenDialog (`opt(`decorated ),
            // wait popup
            `Label(_("Reading sets of users and groups. Please wait...")));

        // run preparation script for geting users and groups from server:
        if (!RunPrepare ("ldap"))
        {
            // error Popup text (bad password?):
            UI::ErrorPopup(_("There was a problem with connecting the LDAP server."));
            UI::CloseDialog(); // close the wait popup
            return false;
        }
        ldap_not_read = false;
        WriteLDAPFinish (tmpdir); // not neccessary here...
        // read the LDAP users and groups now
        users [`ldap ] = ReadLDAPUsers (tmpdir);
        users_by_name [`ldap ] = ReadLDAPUsersByName (tmpdir);
        groups [`ldap] = ReadLDAPGroups (tmpdir);
        groups_by_name [`ldap] = ReadLDAPGroupsByName (tmpdir);
    }
    UsersCache::ReadUsers (type, tmpdir);
    UsersCache::ReadGroups (type, tmpdir);

    UI::CloseDialog(); // the wait popup
    return true;
}

/**
 * Check local groups for presence of non-local users, which was read now
 * and correct that users's grouplists
 * @param type type of users
 */
global define void CorrectUsers(symbol type) ``{

    list new_users = UsersCache::usernamelists [type]:[];

    /* 2 possible solutions:
    1. walk through set of new users and call FindGroupsBelongUser -> too slow
    2. walk through all groups (maybe except "users") and check the correctness
        of its userlist entry -> bit strange
    */
}

/**
 * Change the current users set, additional reading could be necessary
 * @param new the new current set
 * @return success
 */
global define boolean ChangeCurrentUsers(symbol new) ``{

    list current = current_users;

    if ( new == `custom )
        current_users = eval (user_custom_sets);
    else
        current_users = [ new ];

    if (contains (current_users, `ldap) && ldap_not_read)
        if (!ReadNewSet (`ldap))
        {
            current_users = current;
            return false;
        }

    if (contains (current_users, `nis) && nis_not_read)
        if (!ReadNewSet (`nis))
        {
            current_users = current;
            return false;
        }

    // correct also possible change in custom itemlist
    if (new == `custom)
        UsersCache::ChangeUserCustoms (current_users);

    UsersCache::current_users = current_users;

    return true;
}

/**
 * Change the set of current groups viewed
 * @param new the new current set
 * @return success
 */
global define boolean ChangeCurrentGroups(symbol new) ``{

    list current = current_groups;

    if ( new == `custom )
        current_groups = eval (group_custom_sets);
    else
        current_groups = [ new ];
    if (contains (current_groups, `nis) && nis_not_read)
        if (!ReadNewSet(`nis))
        {
            current_groups = current;
            return false;
        }
    if (contains (current_groups, `ldap) && ldap_not_read)
        if (!ReadNewSet(`ldap))
        {
            current_groups = current;
            return false;
        }

    // correct also possible change in custom itemlist
    if (new == `custom)
        UsersCache::ChangeGroupCustoms (current_groups);

    UsersCache::current_groups = current_groups;
    return true;
}

/**
 * Change the value of custom user/group view
 * @param what "user" or "group"
 * @param new the new customs
 * @return success
 */
global define boolean ChangeCustoms(string what, list new) ``{

    if (what == "user")
    {
        list old = user_custom_sets;
        user_custom_sets = new;
        customs_modified = ChangeCurrentUsers (`custom);
        if (!customs_modified)
            user_custom_sets = old;
    }
    else
    {
        list old = group_custom_sets;
        group_custom_sets = new;
        customs_modified = ChangeCurrentGroups (`custom);
        if (!customs_modified)
            group_custom_sets = old;
    }

    return customs_modified;
}

/**
 * Change the structure with default values (/etc/defaults/useradd)
 * @param new_defaults new values
 * @param groupname the name of dew default group
 */
global define void SetDefaults (map new_defaults, string groupname)``{

    modified = true;

    foreach (`key, `value, new_defaults, ``{
        if (value != "")
            useradd_defaults[key] = new_defaults[key]:"";
    });
    // remove last '/' from home entry (??)
    string home = useradd_defaults["home"]:"";
    if ( (findlastof( home, "/") +1) == size(home) )
        useradd_defaults["home"] = substring (home, 0, size(home)-1);

    default_gid = tointeger(useradd_defaults["group"]:sformat("%1",default_gid));
    default_groupname = groupname;
    SetDefaultValues(false);
    defaults_modified = true;
}

/**
 * Sets the time of last password change
 * @return current date string
 */
global define string LastChangeIsNow () ``{
    map out = SCR::Execute(.target.bash_output, "date +%s");
    string days_s = out["stdout"]:"0\n";
    days_s = substring(days_s, 0, size(days_s)-1);
    integer days = (tointeger(days_s) + 3600)/ (60*60*24);
    return sformat("%1", days);
}

/**
 * Runs a script, preparing the data structures
 * @param type type of user/group set to load, can be "passwd", "nis", "ldap"
 * @return true on success
 */
global define boolean RunPrepare(string type) ``{

    integer ret = 1;

    if (type == "passwd")
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_passwd_structures.pl %2 %3 %4 %5 %6", Directory::bindir,
        base_dir, tmpdir, max_system_uid, max_system_gid, encoding));
    }
    else if (type == "nis")
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_nis_structures.pl %2 %3", Directory::bindir, tmpdir,
        encoding));
    }
    else if ( issubstring (type, "ldap") )// ldap has some additional parameters
    {
        string binding = "password";
        if (ldap_bind_pass == "")
            binding = "anonymous";
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_ldap_structures.pl %2 %3 %4", Directory::bindir,
        tmpdir, encoding, binding));
    }
    return (ret == 0);
}

/**
 * Tries to bind to LDAP server with current password
 * @return success
 */
global define boolean LDAPBindCheck () ``{

    WriteLDAPPrepare (tmpdir, ldap_bind_pass);
    integer ret = SCR::Execute(.target.bash, sformat(
        "%1/build_ldap_structures.pl %2 %3 %4", Directory::bindir,
        tmpdir, encoding, "check"));
    WriteLDAPFinish(tmpdir); // temporary files _must_ be removed!
    return (ret == 0);
}

/**
 * The default grouplist for new user
 * @param type type of new user (`local, `system, `nis, `ldap)
 * @return the grouplist
 */
global define string GetDefaultGrouplist (symbol type) ``{

    // check for existence of groups !!
    if (type == `local)
        return "dialout,uucp,video,audio";
    else
        return "";
    // TODO defaults for another types? (ldap)
}

/**
 * Gets the source of user lists from /etc/nsswitch.conf
 * @return list of sources (e.g. [ "ldap", "files" ]
 */
global define list GetUsersSources() ``{

    string passwd_source = SCR::Read(.etc.nsswitch_conf.passwd);
    y2debug("read nsswitch.passwd: %1", passwd_source);

    return splitstring(passwd_source, " ");
}

/**
 * Calls the script which builds the widget contens for EditGroup dialog
 * @param userlist the list of users, having this group as additional
 * @param more_users the list of users, having this group as default group
 * @return the map with widget contents
 */
global define map BuildAdditional (string userlist, string more_users) ``{

    SCR::Write(.target.string, tmpdir + "/additional_userlist", userlist);
    SCR::Write(.target.string, tmpdir + "/additional_moreusers", more_users);
    // do not write all usernames for non-local groups
    if (UsersCache::group_type == `ldap)
        SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
            UsersCache::usernamelists[`ldap]:[]);
    else
        SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
            UsersCache::usernamelists);

    if (0 != SCR::Execute(.target.bash, sformat(
        "%1/build_additional_users.pl %2", Directory::bindir, tmpdir)))
        return $[];
    else
        return $[
            `ulist: SCR::Read(.target.ycp, tmpdir + "/additional_ulist.ycp"),
            `more:  SCR::Read(.target.ycp, tmpdir + "/additional_more.ycp")
        ];
}

/**
 * Re-read the settings, when back was pushed during installation
 * @return true
 */
global define boolean StartAgain() ``{

    y2debug ("reloading unmodified values from disk...");
    Read ( ``{return false;}, false);
    return true;
}

/**
 * Remove old config options - is used from inst_root.ycp
 */
global define void removeOldConf() ``{

	SCR::Write(.pam.all.password.pam_unix2, "-md5");
	SCR::Write(.pam.all.password.pam_pwcheck, "-md5");

	SCR::Write(.pam.login.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.login.password.pam_unix, "-md5");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.passwd.password.pam_unix, "-md5");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.sshd.password.pam_unix, "-md5");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.rlogin.password.pam_unix, "-md5");

	SCR::Write(.pam.all.password.pam_unix2, "-blowfish");
	SCR::Write(.pam.all.password.pam_pwcheck, "-blowfish");

	SCR::Write(.pam.login.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.login.password.pam_unix, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_unix, "-blowfish");

}

/**
 * Crypt the root password according to method defined in encryptionMethod
 * This is called during install
 * @param pw1 unencrypted password
 * @return void
 */
global define void cryptRootPassword(string pw1) ``{

	if (Mode::test) {
	    return;
	}
	if (encryptionMethod == "md5" )
	{
	    SCR::Write( .pam.all.password.pam_unix2,   "+md5" );// this is done in
	    SCR::Write( .pam.all.password.pam_pwcheck, "+md5" );// Security module!
	    rootPassword = cryptmd5 (pw1);
	}
	else if (encryptionMethod == "blowfish" )
	{
	    SCR::Write( .pam.all.password.pam_unix2,   "+blowfish" );
	    SCR::Write( .pam.all.password.pam_pwcheck, "+blowfish" );
	    rootPassword = cryptblowfish (pw1);
	}
	else
	{
	    rootPassword = crypt (pw1);
	}
	return;
}

/**
 * Crypt the given password according to method defined in encryptionMethod
 * @param pw unencrypted password
 * @return encrypted password
 */
global define string CryptPassword (string pw) ``{

	if (encryptionMethod == "md5" )
	    return cryptmd5 (pw);
	else if (encryptionMethod == "blowfish" )
	    return cryptblowfish (pw);
	else
	    return crypt (pw);
}

/**
 * Writes password of superuser
 * @return true on success
 */
global define boolean SetRootPassword() ``{

	return (SCR::Write(.target.passwd.root, rootPassword));
}

/**
 * Check if it is possible to write (=create homes) to given directory
 * @param dir the directory
 * @return empty string on success or name of directory which is not writable
 */
global define string IsDirWritable (string dir) ``{

    // maybe more directories in path don't exist
    while (SCR::Read(.target.stat, dir) == $[] && dir != "")
    {
        dir = substring (dir,0, findlastof(dir,"/"));
    }

    string tmpfile = dir + "/tmpfile";
    while (SCR::Execute (.target.bash, "/usr/bin/test -e " + tmpfile) == 0)
        tmpfile = tmpfile + "0";

    map out =  SCR::Execute (.target.bash_output, "/bin/touch " + tmpfile);
    if (out["exit"]:1 == 0)
    {
        SCR::Execute (.target.bash_output, "/bin/rm " + tmpfile);
        return "";
    }
    else
        return dir;
}

/**
 * Checks if the home directory is properly mounted (bug #20365)
 * @return if user wants to continue
 */
global define boolean CheckHomeMounted() ``{

    string mountpoint_in = "";

    // remove last "/"
    string home = substring (default_home, 0, size(default_home) - 1);

    list fstab = SCR::Read(.etc.fstab);
    foreach (`line, fstab, ``{
        if (line["file"]:"" == home)
            mountpoint_in = "/etc/fstab";
    });

    if (SCR::Execute (.target.bash, "/usr/bin/test -e /etc/cryptotab") ==0)
    {
        list cryptotab = SCR::Read(.etc.cryptotab);
        foreach (`line, cryptotab, ``{
            if (line["mount"]:"" == home)
                mountpoint_in = "/etc/cryptotab";
        });
    }
    if (mountpoint_in != "")
    {
        boolean mounted = false;
        list mtab = SCR::Read(.etc.mtab);
        foreach (`line, mtab, ``{
            if (line["file"]:"" == home)
                mounted = true;
        });

        if (!mounted)
            return UI::YesNoPopup(
// Popup text: %1 is the directory (e.g. /home), %2 file name (e.g. /etc/fstab)
// For more info, look at the bug #20365
sformat(_("In %2, there is a mount point for the directory
%1, which is used as a default home directory for new
users, but this directory is not currently mounted.
If you add new users using the default values,
their home directories will be created in the current %1.
This can imply that these directories will not be accessible
after you mount correctly. Continue user configuration?
"), home, mountpoint_in));

    }
    return true;

}

/**
 * Just some simple checks for password contens
 * @param username
 * @param pw
 * @return error message (password too sumple) or empty string (OK)
 */
global define string CheckObscurity (string username, string pw) ``{

    // FIXME: temporary checked here, LATER with some agent
    if (issubstring (pw, username))
    {
        // yes/no popup
        return _("You have used the user name as a part of the password.
This is not good security practice. Are you sure?
");
    }
    // check for lowercase
    if (deletechars (pw, "abcdefghijklmnopqrstuvwxyz") == "")
    {
        // yes/no popup
        return _("You have used only lowercase letters for the password.
This is not good security practice. Are you sure?
");
    }
    // check for numbers
    if (deletechars (pw, "0123456789") == "")
    {
        // yes/no popup
        return _("You have used only digits for the password.
This is not good security practice. Are you sure?");
    }

    return "OK";

}

/**
 * Try to crack password using cracklib
 * TODO: postponed until tranltation of error messages
 * @param username
 * @param pw
 * @return utility output: ether "OK" or error message
 */
global define string CrackPassword (string username, string pw) ``{

    // write password to some shadow file
    string shadowfile = tmpdir + "/shadowfile";
    SCR::Write(.target.string, shadowfile, sformat ("%1 %2", username, pw));

    string out = lookup (SCR::Execute (.target.bash_output,
        sformat ("/bin/cat %1 | /usr/bin/vpass", shadowfile)), "stdout", "");

    // remove \n at the end
    out = substring(out, 0, size(out)-1);

    SCR::Execute(.target.bash, sformat ("/bin/rm -f %1", shadowfile));

    return out;
}
}// EOF
