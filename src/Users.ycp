/**
 * File:	modules/Users.ycp
 * Package: Configuration of users and groups
 * Summary:	Main module, providing IO functions
 *
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Anas Nashif (nashif@suse.de),
 *          Jiri Suchomel (jsuchome@suse.cz)
 *
 *
 * $Id$
 */
{

module "Users";

textdomain "users";

import "Mode";
import "Progress";
import "Report";
import "UsersCache";
import "MailAliases";
import "Directory";
import "Console";

include "users/routines.ycp";
include "users/nis_routines.ycp";
include "users/ldap_routines.ycp";



// Encryption method: "des", "md5" - for future use: "blowfish"
global string encryptionMethod = "des"; // -- should be loaded from Security

// The root's password
global string rootPassword = "";

/**
 *  keys from /etc/defaults/useradd:
 **/
map useradd_defaults  = $[
    "group": "",
    "home": "",
    "inactive": "",
    "expire": "",
    "shell": "",
    "skel": ""
];

// default values for new users (just shotcuts from useradd_defaults):
global string default_shell = "/bin/bash";
global string default_skel = "/etc/skel";
global string default_home = "/home/";
global integer default_gid = 500; // TODO change to 500 with new version
global string default_groupname = "users";
global string default_inactive = "-1";
global string default_expire = "";

// console encoding - needed for preparation script
string encoding = "";

/*
 * The number of days after a password expires until the account is
 * permanently disabled. A value of 0 disables the
 * account as soon as the password has expired, and a value of -1
 * disables the feature.  The default value is -1.
 */
global integer pass_inact_days = -1;


/*
 * The date on which the user account will be disabled.
 * The date is specified in the format YYYY-MM-DD.
 */
global string pass_expire_date = "";

global string valid_logname_chars  = "0123456789abcdefghijklmnopqrstuvwxyz-_";
global string valid_password_chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#* ,.;:._-+!$%&/|\?{[()]}=";
global string valid_home_chars     = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/_-";
global string valid_group_chars    = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
global string valid_grouplist_chars= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,-_";
global string valid_id_chars       = "0123456789";

global integer max_uid	  = 60000;
global integer max_gid	  = 60000;
global integer max_system_uid = 500 - 1;
global integer max_system_gid = 500 - 1; // TODO change to 500 with new version
global integer max_length_uid = 5;// size(sformat("%1", max_uid));
global integer max_length_gid = 5;
global integer max_length_pas = 8;
global integer min_length_pas = 5;

// Maximum number of days a password may be used:
global integer pass_max_days = 99999;
// Minimum number of days allowed between password changes:
global integer pass_min_days = 0;
// Number of days warning given before a password expires:
global integer pass_warn_age = 7;

global string default_pw     = "******";

global symbol encryption	 = `des;

global string root_mail = "";

// password to LDAP server
string ldap_bind_pass = "";

// list of user sources - passwd entry from /etc/nsswitch.conf
list user_sources = [];

/* Tha main map of users */
global map users = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

/* Tha main map of groups */
global map groups  = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

// main maps of all local shadow and gshadow entries:
global map shadow = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

map gshadow = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

/* structures *_by_name are used for searching */
global map users_by_name = $[];
global map groups_by_name = $[];

/* maps of current user/group */
global map user_in_work = $[];
global map group_in_work = $[];

// the first user, added during install
global map saved_user = $[];

// users/groups, which has been deleted/modified:
map modified_users = $[];
map modified_groups = $[];

// users/groups sets in "Custom" selection:
global list user_custom_sets = [ `local ];
global list group_custom_sets = [ `local ];

// which sets of users/groups are we working with:
global list current_users = [];
global list current_groups = [];

// variables desctibing available users sets:
global boolean is_nis_available = false;
global boolean is_nis_master = false;
global boolean is_ldap_available = false;
global boolean is_ldap_server = false;

// type of pam kerberos authentication: required/optional/sufficient/""
global string kerberos_auth = "";

// users like ldap/nis are not read by default, but could be read on demand:
boolean nis_not_read = true;
boolean ldap_not_read = true;

// which sets of users/groups are available to work with:
global list available_usersets = [ `system, `local];
global list available_usersets_items = [];
global list available_groupsets = [ `system, `local];
global list available_groupsets_items = [];

/* where the user/group/password data are stored
   (can be different on NIS server) */
global string base_dir = "/etc";

// list of available shells (read in GetAllShells)
global list all_shells = [];
global list all_shells_items = [];

// the +/- entries in config files:
string plus_passwd = "";
string plus_group = "";
string plus_shadow = "";
string plus_gshadow = "";

// ldap configuration from /etc/openldap/ldap.conf
string ldap_host = "";
string ldap_base = "";

string tmpdir = "/tmp"; // do not write to /tmp only!

global string start_dialog = "users";
global boolean use_next_time = true; // what is it for ??

// if anything was done
global boolean modified = false;
global boolean ldap_modified = false;

// values to MenuItem in Summary dialog
global map userset_to_string = $[
    // the type of user set
    `system:    _("&System users"),
    // the type of user set
    `local:     _("&Local users"),
    // the type of user set
    `nis:       _("&NIS users"),
    // the type of user set
    `ldap:      _("L&DAP users"),
    // the type of user set
    `samba:     _("Sam&ba users"),
    // the type of user set
    `custom:    _("&Custom")
];

global map groupset_to_string = $[
    // the type of group set
    `system:    _("&System groups"),
    // the type of group set
    `local:     _("&Local groups"),
    // the type of group set
    `nis:       _("&NIS groups"),
    // the type of group set
    `ldap:      _("L&DAP groups"),
    // the type of group set
    `samba:     _("Sam&ba groups"),
    // the type of group set
    `custom:    _("&Custom")
];


/**
 * Read all the settings
 * @param abort the abort block
 * @param useUI boolean use user interface (change progress bar)
 * @return symbol `next if success, else `abort
 */
global define symbol Read (block abort, boolean useUI) ``{

	// progress caption
	string caption = _("Initializing user and group configuration");
	integer no_of_steps = 9;

	// We do not set help text here, because it was set outside
	if( useUI )
	    Progress::New (caption, " ", no_of_steps,
			// progress label
		       [ _("Read the default login settings"),
			// progress label
			 _("Read the default system settings"),
			// progress label
			 _("Read the configuration type"),
			// progress label
			 _("Build the data structures"),
			// progress label
			 _("Read the password settings"),
			// progress label
			 _("Read the group settings"),
			// progress label
			 _("Read the user settings"),
			// progress label
			 _("Read the custom settings"),
			// progress label
			 _("Build the cache structures")
           ],
			// progress label
		       [ _("Reading the default login settings..."),
			// progress label
			 _("Reading the default system setttings..."),
			// progress label
			 _("Reading the configuration type..."),
			// progress label
			 _("Building the data structures..."),
			// progress label
			 _("Reading the password settings..."),
			// progress label
			 _("Reading the group settings..."),
			// progress label
			 _("Reading the user settings..."),
			// progress label
			 _("Reading the custom settings"),
			// progress label
			 _("Building the cache structures"),
			// progress label
			 _("Finished") ],
			    "" );

	// read default login settings
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    UsersCache::PrintDate ("begin");

	if ( ! ReadLoginDefaults(useUI) )
	{
		// warning popup
	    Report::Warning (_("Cannot read the default login settings."));
	}

    if ( !CheckHomeMounted())
    {
        if (Mode::cont)
            return `nextmodule; // what to return during install ??
        else
            return `back;
    }

	// read default system settings
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

	if ( ! ReadSystemDefaults() )
	{
		// error popup
	    Report::Error (_("Cannot read the default systems settings."));
	}

	// read configuration type
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    UsersCache::PrintDate ("before sources");

    ReadSourcesSettings();

    if ( is_nis_master && useUI)
    {
        string dir = ReadNISConfigurationType (base_dir);
        if (dir == nil)
            return `abort; // aborted in NIS server dialog
        else
            base_dir = dir;
    }

	// run script for pre-building structures
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    tmpdir = SCR::Read(.target.tmpdir);
    UsersCache::PrintDate ("bef run prepare");

    if ( !RunPrepare("passwd") )
    {
	    Report::Error (_("Cannot run preparation script."));
    }
    UsersCache::PrintDate ("after run prepare");

	// read password settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    UsersCache::PrintDate ("before read");

    gshadow = ReadGshadow(tmpdir);

    UsersCache::PrintDate ("gshadow");

    shadow = ReadShadow (tmpdir);
    UsersCache::PrintDate ("shadow");

    plus_shadow = ReadPlusShadow(tmpdir);
    plus_gshadow = ReadPlusGshadow(tmpdir);

	if ( (gshadow == nil) || (shadow == nil) )
    {
		// error popup
	    Report::Error (_("Cannot read the password settings."));
	    //return `abort;
    }

	// read group settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    groups = ReadGroups(tmpdir);
    UsersCache::PrintDate ("groups");
    groups_by_name = ReadGroupsByName(tmpdir);
    UsersCache::PrintDate ("groups_by_name");
    plus_group = ReadPlusGroup(tmpdir);

	if ( groups [`local]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the local group settings."));
        groups [`local] = $[];
    }
    if ( groups [`system]:nil == nil)
    {
		// error popup
	    Report::Error (_("Cannot read the system group settings."));
        groups [`system] = $[];
    }

	// read user settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    users = ReadPasswd (tmpdir);
    UsersCache::PrintDate ("users");

    plus_passwd = ReadPlusPasswd (tmpdir);
    users_by_name = ReadPasswdByName (tmpdir);
    UsersCache::PrintDate ("users_by_name");

	if (users [`local]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the local user settings."));
        users [`local] = $[];
    }
    if ( users [`system]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the system user settings."));
        users [`system] = $[];
    }

	// read customs
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    user_custom_sets = ReadUserCustomSets();
    group_custom_sets = ReadGroupCustomSets();

    // There is no progress for this !!!
    ReadAllShells();
    ReadDefaultGroup(useUI);

	// build the cache
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    ReadUsersCache(true);
    UsersCache::PrintDate ("cache");

	// increase the progress to "finish"
	if( useUI ) Progress::NextStage ();

	return `next;
}

/**
 * Saves users into the system
 * @param abort abort block
 * @param useUI if user interface (progress bar and popups) should be used
 * @return symbol `next for success, `abort otherwise
 */
global define symbol Write (block abort, boolean useUI)``{

    string write_dir = base_dir;//"/tmp"; // -- just for testing

	// progress caption
	string caption = _("Writing user and group configuration");
	integer no_of_steps = 7;

	// We do not set help text here, because it was set outside
	if( useUI )
	    Progress::New (caption, " ", no_of_steps, [
			// progress label
			_("Backup the configuration files"),
			// progress label
			_("Check for deleted users"),
			// progress label
			_("Write users"),
			// progress label
			_("Write passwords"),
			// progress label
			_("Write groups"),
			// progress label
			_("Write the custom settings"),
			// progress label
		    _("Write the default login settings")
           ],
			// progress label
		       [ _("Creating backup of configuration files..."),
			// progress label
			_("Checking deleted users..."),
			// progress label
			_("Writing users..."),
			// progress label
			_("Writing passwords..."),
			// progress label
			_("Writing groups..."),
			// progress label
			_("Writing the custom settings..."),
			// progress label
		    _("Writing the default login settings..."),
			// progress label
			_("Finished") ],
			    "" );

	// backup
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    BackupConfFiles(base_dir);

	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    // currently there are deleted users in MOdified_users
    foreach (`uid, `user, modified_users [`local]:$[], ``{
        if (user["delete_home"]:false)
        {
            // -- what if the home was changed??
            string home = user["home"]:"";
            y2milestone ("The directory %1 is deleted", home);
            string command = sformat("/bin/rm -rf %1", home);
            y2debug("rm return value: %1",
                SCR::Execute(.target.bash, command));
        }
    });
    foreach (`uid, `user, modified_users [`system]:$[], ``{
        if (user["delete_home"]:false)
        {
            // -- what if the home was changed??
            string home = user["home"]:"";
            y2milestone ("The directory %1 is deleted", home);
            string command = sformat("/bin/rm -rf %1", home);
            y2debug("rm return value: %1",
                SCR::Execute(.target.bash, command));
        }
    });

    // write passwd
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    // add the edited or new users to modified_users
    modified_users [`passwd] = WritePasswd (write_dir, users [`system]:$[],
        users[`local]:$[], plus_passwd);

    if (modified_users [`passwd]:$[] == nil)
    {
        if ( useUI)
            // error popup
	        Report::Error (_("Cannot write passwd file."));
        else
            y2error ("Cannot write passwd file.");
        modified_users [`passwd] = $[];
    }

    // check for homedir changes
    foreach (`uid, `user, modified_users [`passwd]:$[], ``{
        string home = user["home"]:"";
        string username = user["username"]:"";
        string command = "";
        if (user["modified"]:`nothing == `added)
        {
            if (user["create_home"]:true)
            {
                // create a path to new home directory, if not exists
                string home_path = substring (home,0, findlastof(home,"/"));
                if (SCR::Read(.target.stat, home_path) == $[])
                    SCR::Execute(.target.mkdir, home_path);
                y2milestone ("The directory %1 is created", home);
                // copy homedir from skel
                command = sformat("/bin/cp -r %1 %2",default_skel,home);
                y2debug("cp return value: %1",
                    SCR::Execute(.target.bash, command));
            }
            // change the rights
            string groupname = user["groupname"]:default_groupname;
            command = sformat("/bin/chown -R %1:%2 %3",username,groupname,home);
            y2debug("chown return value: %1",
                SCR::Execute(.target.bash, command));
            // call the useradd.local (-- check the existence ??)
            command = sformat("/usr/sbin/useradd.local %1", username);
            y2debug("useradd.local return value: %1",
                SCR::Execute(.target.bash, command));

        }
        else // only `edited can be here
        {
            string org_home = user["org_home"]:home;
            if (home != org_home)
            {
                if (user["create_home"]:true) // move the home directory
                {
                    y2milestone ("The directory %1 is moved to %2",
                        org_home, home);
                    command = sformat("/bin/mv %1 %2", org_home, home);
                    y2debug("mv return value: %1",
                        SCR::Execute(.target.bash, command));
                }
                else // directory already exists
                {
                    // change the rights
                    string groupname = user["groupname"]:default_groupname;
                    command = sformat("/bin/chown -R %1:%2 %3", username,
                        groupname, home);
                    y2debug("chown return value: %1",
                        SCR::Execute(.target.bash, command));
                }
            }
            integer org_uid = user["org_uid"]:uid;
            string groupname = user["groupname"]:default_groupname;
            if (uid != org_uid)
            {
                // change the rights of user's files
                y2milestone ("UID of user %1 was changed, changing rights of files in %2", username, home);
                command = sformat("/bin/chown -R %1:%2 %3", username,
                    groupname, home);
                y2debug("chown return value: %1",
                    SCR::Execute(.target.bash, command));
            }
        }
    });
    // ldap users and groups
    /*
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}*/
    if (ldap_modified)
    {
        boolean succ = true;

        if (ldap_bind_pass == "" && useUI)
            ldap_bind_pass = GetLDAPPassword();

        WriteLDAPPrepare (tmpdir, ldap_bind_pass);
        // there are deleted users in modified_users [`ldap]
        if (size (modified_users [`ldap]:$[]) > 0)
        {
            succ = WriteLDAPUsers (
                modified_users [`ldap]:$[], is_ldap_server, tmpdir);
        }

        // now write all other modifications
        succ = succ && WriteLDAPUsers (
            users [`ldap]:$[], is_ldap_server, tmpdir);

        if (!succ)
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write ldap users."));
            else
                y2error ("Cannot write ldap users.");
        }

        succ = true;
        // there are deleted groups in modified_groups [`ldap]
        if (size (modified_groups [`ldap]:$[]) > 0)
        {
            succ = WriteLDAPGroups (modified_groups [`ldap]:$[], tmpdir);
        }

        // now write all other groups modifications
        succ = succ && WriteLDAPGroups (groups [`ldap]:$[], tmpdir);

        if (!succ)
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write ldap groups."));
            else
                y2error ("Cannot write ldap groups.");
        }

        WriteLDAPFinish(tmpdir); // temporary files _must_ be removed!
    }

    // shadow, gshadow
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    // TODO send whole structure and decide in the write function
    if (! WriteShadow(write_dir, shadow[`system]:$[], shadow[`local]:$[], plus_shadow))
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write shadow file."));
        else
            y2error ("Cannot write shadow file.");
    }

    if (! WriteGshadow(write_dir, gshadow[`system]:$[], gshadow[`local]:[], plus_gshadow))
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write gshadow file."));
        else
            y2error ("Cannot write gshadow file.");
    }

    // group
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (! WriteGroup (write_dir, groups [`system]:$[], groups[`local]:$[],
         plus_group))
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write group file."));
        else
            y2error("Cannot write group file.");
    }

    // call make on NIS server
    if (is_nis_master)
    {
        map ret = SCR::Execute(.target.bash_output, "/usr/bin/make -C /var/yp");
        if (ret["exit"]:1 != 0)
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot make NIS database."));
            else
                y2error("Cannot make NIS database: %1", ret);
        }
    }

    // customs
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    WriteUserCustomSets();

    // useradd defaults
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    WriteLoginDefaults();

    // mail forward from root
    if (Mode::cont && root_mail != "")
    {
        if (! MailAliases::SetRootAlias (root_mail))
            // error popup
            Report::Error(_("There was an error while setting forwarding for root's mail."));
    }

    // call only after `back or `abort
    //    RemoveTmp (tmpdir);

	// increase the progress to "finish"
	if( useUI ) Progress::NextStage ();

	return `next;
}


/**
 * Summary for autoinstalation
 * @return summary of the current configuration
 */
global define string Summary() ``{

    string ret = "Summary of users and groups:<br>";

    // do not show system users/groups ??
    ret = ret + "<p><i>Users:</i><p>";
    foreach (`uid, `user, users [`local]:$[], ``{
            ret = ret + sformat(" %1 %2 %3<br>", uid, user["username"]:"",
                user["fullname"]:"" );
    });
    ret = ret + "<p><i>Groups:</i><p>";
    foreach (`gid, `group, groups [`local]:$[], ``{
            ret = ret + sformat(" %1 %2<br>", gid, group["groupname"]:"");
    });

    return ret;
}

/**
 * Get all the user configuration from the list of maps.
 * Is called users_auto (preparing autoinstallation data).
 * @param settings	A list of maps of type:
 * [ users, groups, shadow, gshadow, useradds_defaults ]
 * to be added to the system.
 * @return	success
 */
global define boolean Import (list settings) ``{

    y2debug("importing: %1", settings);

    users = settings[0]:users;
    groups = settings[1]:groups;
    shadow = settings[2]:shadow;
    gshadow = settings[3]:gshadow;

    if (settings[4]:$[] == $[])
        ReadLoginDefaults(false);
    else
        useradd_defaults = settings[4]:$[];

    ReadSystemDefaults();
    tmpdir = SCR::Read(.target.tmpdir);
    RunPrepare("passwd"); // creates the files with data structures in tmpdir

    // read the system users from local file if they're not in parameters
// TODO system users must be read every time and compared with imported
    if (users [`system]:nil == nil || users [`system]:nil == $[])
    {
        map passwd_users = ReadPasswd (tmpdir);
        users [`system] = passwd_users [`system]:$[];
        map passwd_users_by_name = ReadPasswdByName (tmpdir);
        users_by_name [`system] = passwd_users_by_name[`system]:$[];
    }
    if (users [`local]:nil == nil)
        users = add (users, `local, $[]);

    users_by_name [`local] = UsersByName (users [`local]:$[]);
    // -- move the plus_strings to if sections ??
    plus_passwd = ReadPlusPasswd (tmpdir);

    if (groups [`system]:nil == nil || groups [`system]:nil == $[])
    {
        map all_groups = ReadGroups (tmpdir);
        map system_groups = all_groups [`system]:$[];
        // but we're not interested in local userlists...
        system_groups = RemoveDiskUsersFromGroups(system_groups);
        groups [`system] = system_groups;
    }
    groups_by_name [`system] = GroupsByName (groups [`system]:$[]);

    if (groups[`local, 100, "groupname"]:"" != "users" &&
        groups[`local, 500, "groupname"]:"" != "users")
    {
        // group users must be created
        map group = $[
             "gid": default_gid, "groupname": "users",
             "password": "x", "userlist": ""];
        groups [`local] = add (groups [`local]:$[], default_gid, group);
        gshadow [`local] = add (gshadow [`local]:$[], "users",
            $[ "password": "*", "disposer": "root", "userlist": ""]);
    }
    if (groups [`local]:nil == nil)
        groups = add (groups, `local, $[]);
    groups_by_name [`local] = GroupsByName (groups [`local]:$[]);
    plus_group = ReadPlusGroup(tmpdir);

    if (shadow [`system]:nil == nil || shadow [`system]:nil == $[])
    {
        map all_shadow = ReadShadow (tmpdir);
        shadow [`system] = all_shadow[`system]:$[];
    }
    if (shadow [`local]:nil == nil)
        shadow = add (shadow, `local, $[]);
    plus_shadow = ReadPlusShadow(tmpdir);

    if (gshadow [`system]:nil == nil || gshadow [`system]:nil == $[])
    {
        map all_gshadow = ReadGshadow (tmpdir);
        gshadow [`system] = all_gshadow[`system]:$[];
    }
    if (gshadow [`local]:nil == nil)
        gshadow = add (gshadow, `local, $[]);
    plus_gshadow = ReadPlusGshadow(tmpdir);

    // maybe the `system users/groups shouldn't be available??
    available_usersets = [`local, `system];
    available_groupsets = [`local, `system];

    ReadAllShells();
    ReadDefaultGroup(false);

// TODO: define more_users (for groups) and grouplist (for users)

    foreach (`uid, `user, users [`local]:$[], ``{
        string username = user["username"]:":";
        user["grouplist"] = FindGroupsBelongUser (username);
        map group = GetGroupFromAll (user["gid"]:default_gid);
        user["groupname"] = group ["groupname"]:default_groupname;
        users [`local, uid] = user;

        // update the group's more_users (use Commit?)
        string more_users = group ["more_users"]:"";
        list more_list = splitstring (more_users, ",");
        if (! contains (more_list, username))
        {
            if (more_users != "") more_users = more_users + ",";
            group ["more_users"] = more_users + username;
            groups [ group["type"]:`local, user["gid"]:default_gid] = group;
        }

    });

    foreach (`uid, `user, users [`system]:$[], ``{
        string username = user["username"]:":";
        user["grouplist"] = FindGroupsBelongUser (username);
        map group = GetGroupFromAll (user["gid"]:default_gid);
        user["groupname"] = group ["groupname"]:default_groupname;
        users [`system, uid] = user;

        // update the group's more_users (use Commit?)
        string more_users = group ["more_users"]:"";
        list more_list = splitstring (more_users, ",");
        if (! contains (more_list, username))
        {
            if (more_users != "") more_users = more_users + ",";
            group ["more_users"] = more_users + username;
            groups [ group["type"]:`system, user["gid"]:default_gid] = group;
        }
    });


    ReadUsersCache(false);
    return true;
}


/**
 * Reseting the values (probably to empty set) - to use for autoinstallation
 * @param settings same as in Import
 */
global define void Set (list settings) ``{

    // what about system users/groups ??

    users [`local] = settings[0, `local]:$[];
    users_by_name [`local] = UsersByName (users [`local]:$[]);

    groups [`local] = settings[1, `local]:$[];
    // why reading??? check this !!
    /*
    groups_by_name = union (ReadGroupsByName (tmpdir),
        GroupsByName (groups [`local]:$[]));
    */
    groups_by_name [`local] = GroupsByName (groups [`local]:$[]);

    shadow [`local] = settings[2, `local]:$[];
    gshadow [`local] = settings[3, `local]:$[];

    if (settings[4]:$[] != $[])
        useradd_defaults = settings[4]:$[];

    UsersCache::EmptyStructures();
    ReadUsersCache(false);
}

/**
 * Dump the users settings to list of maps
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export() ``{

    map system_users = modified_users[`system]:$[]; // these are deleted!
    map system_shadow = $[];
    foreach (`uid, `user, users[`system]:$[], ``{

        if (user["modified"]:`nothing != `nothing)
        {
            system_users = add (system_users, uid, user);
            string name = user["username"]:"";
            system_shadow = add (system_shadow, name,
                shadow[`system, name]:$[]);
        }
    });
    map system_groups = modified_groups[`system]:$[];
    map system_gshadow = $[];
    foreach (`gid, `group, groups[`system]:$[], ``{

        if (group["modified"]:`nothing != `nothing)
        {
            system_groups = add (system_groups, gid, group);
            string name = group["groupname"]:"";
                system_shadow = add (system_shadow, name,
                    shadow[`system, name]:$[]);
        }
    });

    return [
        $[
            `system: system_users, // only modified (also deleted)
            `local: users [`local]:$[] // all
        ],
        $[
            `system: system_groups,
            `local: groups [`local]:$[]
        ],
        $[
            `system: system_shadow,
            `local: shadow [`local]:$[]
        ],
        $[
            `system: system_gshadow,
            `local: gshadow [`local]:$[]
        ],
        useradd_defaults
    ];
}

/**
 * Helper function, which corects the userlist entry of each group.
 * During autoinstallation, system groups are loaded from the disk,
 * and the userlists of these groups can contain the local users,
 * which we don not want to Import. So they are removed here.
 * @param disk_groups the groups loaded from local disk
 * @return corrected map of groups
 */
global define map RemoveDiskUsersFromGroups (map disk_groups) ``{

	map ret = mapmap (`gid, `group, disk_groups, ``{

        map new_group = group;

        foreach (`list_of_users, ["userlist", "more_users"], ``{

            list userlist = splitstring (group[list_of_users]:"", ",");
            string userlist_s = "";
            foreach (`username, userlist, ``{
                if (haskey (users_by_name [`system]:$[], username) ||
                    haskey (users_by_name [`local]:$[], username))
                {
                    if (userlist_s == "")
                        userlist_s = username;
                    else
                        userlist_s = userlist_s + "," + username;
                }
            });
            new_group[list_of_users] = userlist_s;
        });

	    return [ gid, new_group ];
	});

    return ret;
}

// prepare user/group_in_work for Commit
global define boolean Add (string what, map data)``{

    if (what == "user")
        user_in_work = $[];
    else
        group_in_work = $[];
    //create some default values
    return true;
}

global define boolean Edit (string what, map data)``{

    // find user/group and prepare (user|group)_in_work
    return true;
}

global define boolean Delete (string what, map data)``{

    // find user/group and prepare (user|group)_in_work
    return true;
}


/**
 * Update the global user and/or group map with current
 * user_in work or group_in_work
 * @param object "user" or "group"
 * @param cache if cache structures (from UsersCache) should be updated
 * @return true on success
 */
global define boolean Commit (string object, boolean cache)``{

    modified = true;

    if (object == "user")
    {
//y2milestone("user : %1", user_in_work );
        integer uid = user_in_work ["uid"]:max_uid;
        integer org_uid = user_in_work ["org_uid"]:uid;
        symbol what_user = user_in_work ["what"]:`nothing;
        symbol type = user_in_work ["type"]:`local;
        string username = user_in_work ["username"]:"";
        string org_username = user_in_work ["org_username"]:username;
        string grouplist = user_in_work ["grouplist"]:"";
        string defgroup = user_in_work ["groupname"]:default_groupname;
        list group_list = splitstring (grouplist, ",");//remove ""
        group_list = filter (`g, group_list, ``(g != ""));

        if (type == `ldap)
            ldap_modified = true;

        // the action
        if ( what_user == `add_user )
        {
            // when writing the new user, the new home has to be created
            user_in_work ["modified"] = `added;
            // update the affected groups
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[])
                {
                    y2error("Group %1 doesn't exist!", group);
                }
                else
                {
                    group_in_work ["what"] = `user_change;
                    string userlist = group_in_work ["userlist"]:"";
                    list userlist_l = splitstring (userlist, ",");
                    if (!contains(userlist_l, username))
                    {
                        if (userlist != "") userlist = userlist + ",";
                        group_in_work ["userlist"] = userlist + username;
                        Commit ("group", cache);
                    }
                }
            });
            // add user to his default group -- updating only cache variables
            group_in_work = GetGroupByName (defgroup, type);
            if (group_in_work == $[])
            {
                y2error("Group %1 doesn't exist!", defgroup);
            }
            else
            {
                group_in_work ["what"] = `user_change;
                string more_users = group_in_work ["more_users"]:"";
                if (more_users != "") more_users = more_users + ",";
                group_in_work ["more_users"] = more_users + username;
                Commit ("group", cache);
            }
            // modify global shadow map:
            shadow [type] = add(shadow [type]:$[],
                 username, user_in_work["shadow"]:$[]);
        }
        else if ( what_user == `edit_user )
        {
            if (user_in_work ["modified"]:`nothing != `added)
                user_in_work ["modified"] = `edited;
            // check the change of additional group membership
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[]) return;
                string userlist = group_in_work ["userlist"]:"";
                list l_userlist = splitstring (userlist, ",");
                // username changed
                if ((org_username != username) &&
                    (contains (l_userlist, org_username)))
                {
                    group_in_work ["what"] = `user_change;
                    l_userlist = filter (`u, l_userlist, ``(u != org_username));
                    userlist = mergestring (l_userlist, ",");
                    if (userlist != "") userlist = userlist + ",";
                    group_in_work ["userlist"] = userlist + username;
                    Commit ("group", cache);
                }
                // user was added to the new group
                else if (!contains (l_userlist, org_username))
                {
                    group_in_work ["what"] = `user_change;
                    if (userlist != "") userlist = userlist + ",";
                    // username can be changed here
                    group_in_work ["userlist"] = userlist + username;
                    Commit ("group", cache);
                }
            });
            // check the removing user from some additional group
            list removed_group_list = user_in_work ["removed_grouplist"]:[];
            foreach (`group, removed_group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[]) return;
                string userlist = group_in_work ["userlist"]:"";
                list l_userlist = splitstring (userlist, ",");
                if (contains (l_userlist, org_username)) // always true?
                {
                    group_in_work ["what"] = `user_change;
                    l_userlist = filter (`u, l_userlist, ``(u != org_username));
                    userlist = mergestring (l_userlist, ",");
                    group_in_work ["userlist"] = userlist;
                    Commit ("group", cache);
                }
            });
            // check the change in default group
            string org_defgroup = user_in_work ["org_groupname"]:defgroup;
            if ((username != org_username) && (defgroup == org_defgroup))
            {
                // change the user's name in current default group
                group_in_work = GetGroupByName (defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change;
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            else if (defgroup != org_defgroup)
            {
                // note: username could be also changed!
                // remove the name from original group ...
                group_in_work = GetGroupByName (org_defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change;
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    group_in_work ["more_users"] = more_users;
                    Commit ("group", cache);
                }
                // and add it to the new one;
                group_in_work = GetGroupByName (defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change;
                    string more_users = group_in_work ["more_users"]:"";
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            // modify the shadow entry
            if (type == `local || type == `system) // - also for groups !
            {
                if (username != org_username)
                    shadow [type] = remove (shadow[type]:$[], org_username);
                shadow [type, username] = user_in_work["shadow"]:$[];
            }
        }
        else if ( what_user == `delete_user )
        {
            // check the change of group membership
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work != $[])
                {
                    string userlist = group_in_work ["userlist"]:"";
                    list l_userlist = splitstring (userlist, ",");
                    if (contains (l_userlist, username)) // always true?
                    {
                        group_in_work ["what"] = `user_change;
                        l_userlist = filter (`u, l_userlist, ``(u != username));
                        userlist = mergestring (l_userlist, ",");
                        group_in_work ["userlist"] = userlist;
                        Commit ("group", cache);
                    }
                }
            });
            // remove user from his default group -- only cache structures
            group_in_work = GetGroupByName (defgroup, type);
            group_in_work ["what"] = `user_change;
            string more_users = group_in_work ["more_users"]:"";
            list l_more_users = splitstring (more_users, ",");
            l_more_users = filter (`u, l_more_users, ``(u != username));
            more_users = mergestring (l_more_users, ",");
            group_in_work ["more_users"] = more_users;
            Commit ("group", cache);

            // prevent the add & delete of the same user
            if (user_in_work["modified"]:`nothing != `added)
            {
                user_in_work ["modified"] = `deleted;
                modified_users [type] = add (modified_users [type]:$[],
                    uid, user_in_work);
            }
            if (type != `ldap)
                shadow [type] = remove (shadow [type]:$[], org_username);
        }
        else if ( what_user == `group_change)
        {
                // prevent loading this argument with some unwanted value later
                if (type == `ldap)
                    user_in_work ["modified"] = `edited;
                else
                    user_in_work ["modified"] = `nothing;
        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeUser(what_user, user_in_work);

        // the main action: update users -- what if uid is changed?
        if (what_user == `delete_user)
        {
            users [type] = remove (users[type]:$[], uid);
            users_by_name [type] = remove (users_by_name[type]:[], username);
        }
        else // also `group_change !
        {
            if (uid != org_uid)
            {
                users_by_name [type, username ] = uid;
                users [type] = remove (users [type]:$[], org_uid);
            }
            users [ type, uid ] = eval (user_in_work);

            // this has to be done due to multiple changes of username -- ??
            // and what about the home and others??
            if (type != `ldap) // for changing ldap username old one is needed
                users [type, uid, "org_username"] = username;
        }
    }
    else if ( object == "group" )
    {
        integer gid = group_in_work ["gid"]:max_gid;
        integer org_gid = group_in_work ["org_gid"]:gid;
        symbol what_group = group_in_work ["what"]:`nothing;
        symbol type = group_in_work ["type"]:`local;
        string groupname = group_in_work ["groupname"]:"";
        string password = group_in_work ["password"]:"*";
        string org_groupname = group_in_work ["org_groupname"]:groupname;
        string userlist = group_in_work ["userlist"]:"";
        list l_userlist = splitstring (userlist, ",");
//y2error("group: %1", group_in_work);

        if (org_groupname == "")
            org_groupname = groupname;

        if (type == `ldap)
            ldap_modified = true;
        if ( what_group == `add_group )
        {
            group_in_work ["modified"] = `added;
            // update users's grouplists (only local structures)
            foreach (`user, l_userlist, ``{
                // -- what if user doesn't exist??
                user_in_work = GetUserByName (user);
                string grouplist = user_in_work ["grouplist"]:"";
                if (grouplist != "")
                   grouplist = grouplist + ",";
                user_in_work["grouplist"] = grouplist + groupname;
                user_in_work["what"] = `group_change;
                Commit("user", cache);
            });
            // create an entry for global gshadow map:
            gshadow [type] = add (gshadow[type]:$[], groupname, $[
                "password": password,
                "disposer": "root", // default??
                "userlist": ""]); // will be updated at the end
        }
        else if (what_group == `edit_group )
        {
            if (group_in_work ["modified"]:`nothing != `added)
                group_in_work ["modified"] = `edited;
            // update users's grouplists (mainly local structures)
            foreach (`user, l_userlist, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    boolean commit_user = false;
                    // new user added to group
                    if (! contains (l_grouplist, org_groupname))
                    {
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    else if (org_groupname != groupname)
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        // what about ",,"?
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    if (commit_user)
                    {
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                }
            });
            // check the additional users removed from this group
            list removed_user_list = group_in_work ["removed_userlist"]:[];
            foreach (`user, removed_user_list, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    if ( contains (l_grouplist, org_groupname))
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        user_in_work["grouplist"] = grouplist;
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                }
            });
            // correct the changed groupname/gid for users with this group
            // as default
            if ((groupname != org_groupname) || (gid != org_gid))
            {
                string more_users = group_in_work ["more_users"]:"";
                list l_more_users = splitstring (more_users, ",");
                foreach (`user, l_more_users, ``{
                    user_in_work = GetUserByName (user);
                    if (user_in_work != $[])
                    {
                        user_in_work["groupname"] = groupname;
                        user_in_work["gid"] = gid;
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                });
            }
            // modify the gshadow -- userlist ??
            if (groupname != org_groupname)
            {
                gshadow [type, groupname] = gshadow [type, org_groupname]:$[];
                gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            }
            if (password != "x" && password != "*")
                gshadow [type, groupname, "password"] = password;
        }
        else if (what_group == `delete_group )
        {
            if (group_in_work["modified"]:`nothing != `added)
            {
                group_in_work ["modified"] = `deleted;
                modified_groups [type] = add (modified_groups [type]:$[],
                    gid, group_in_work);
            }
            groups [type] = remove (groups [type]:$[], org_gid);
            groups_by_name [type] = remove (groups_by_name [type]:$[],
                org_groupname);
            if (haskey (gshadow [type]:$[], org_groupname))
                gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            // deleted group had no members -> no user change
        }
        else if ( what_group == `add_user ) // do not call Commit again
        {

        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeGroup(what_group, group_in_work);

        if (what_group != `delete_group) // also for `change_user!
        {
            // the main action: update groups
            if (gid != org_gid)
                groups [ type ] = remove (groups [type]:$[], org_gid);
            groups [ type, gid ] = group_in_work;

            // name could have been changed !!
            if (groupname != org_groupname)
                groups_by_name [type] = remove (groups_by_name [type]:$[],
                    org_groupname);
            groups_by_name [type, groupname] = group_in_work;

            // update userlist in gshadow
            if (haskey (gshadow [type]:$[], groupname))
                gshadow [type, groupname, "userlist"] = userlist;

            // this has to be done due to multiple changes of groupname ??
            if (type != `ldap)
                groups [type, gid, "org_groupname"] = groupname;
        }
    }
    return true;
}
/**
 * Checks the possible user sources
 */
global define void ReadSourcesSettings () ``{

    available_usersets = [ `local, `system ];
    available_groupsets = [ `local, `system ];

    user_sources = GetUsersSources ();
    is_nis_available = IsNISAvailable (user_sources);
    is_nis_master = IsNISMaster ();
    is_ldap_available = IsLDAPAvailable (user_sources);
    kerberos_auth = KerberosAuth();

    if ( !is_nis_master && is_nis_available )
    {
            available_usersets = add ( available_usersets, `nis);
            available_groupsets = add ( available_groupsets, `nis);
    }

    if ( is_ldap_available )
    {
        ldap_base = GetLDAPBase();
        ldap_host = GetLDAPHost();
        is_ldap_server = IsLDAPServer (ldap_host);

        available_usersets = add ( available_usersets, `ldap);
        available_groupsets = add ( available_groupsets, `ldap);
    }

    available_usersets = add ( available_usersets, `custom);
    available_groupsets = add ( available_groupsets, `custom);
}

/**
 * Return map for mapping user names to UIDs
 * @param usermap map of users of type $[ uid:user's map ]
 * @return new mapping of type $[ username: uid ]
 */
global define map UsersByName (map usermap) ``{
	map res = mapmap (`k, `v, usermap, ``{
	    return [ lookup (v, "username", ""), k ]; // only uid !!
	});
	return res;
}

/**
 * Maps groupname to group's map
 * @param groupsmap map of groups of type $[ gid:group's map ]
 * @return new mapping of type $[ groupname: group's map ]
 */
global define map GroupsByName (map groupsmap) ``{
	map res = mapmap (`k, `v, groupsmap, ``{
	    return [ lookup (v, "groupname", ""), v ]; // whole map??
	});
	return res;
}

/**
 * Fills the variables with the default values
 * (used only for better access)
 * @param useUI if UI is used
 */
define void SetDefaultValues(boolean useUI) ``{

    pass_inact_days  = tointeger( useradd_defaults["inactive"]:"-1" );
    pass_expire_date = useradd_defaults["expire"]:"";

    default_shell = useradd_defaults["shell"]:default_shell;
    default_skel = useradd_defaults["skel"]:default_skel;
    default_expire = useradd_defaults["expire"]:default_expire;
    default_inactive = useradd_defaults["inactive"]:default_inactive;
    default_home = GetDefaultHome(useUI);
}

/**
 * Reads settings from /etc/defaults/useradd
 * @param useUI if UI is used
 * @return true on success
 */
global define boolean ReadLoginDefaults(boolean useUI)``{

    path useradd_path = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{
        path entry_path = add (useradd_path, key);
        useradd_defaults[key] = deletechars (SCR::Read(entry_path), "\"");
    });

    if( useradd_defaults == $[] || useradd_defaults == nil )
	    return false;

    SetDefaultValues(useUI);
    return true;
}

/**
 * Writes settings to /etc/defaults/useradd
 * @return true on success
 */
global define boolean WriteLoginDefaults()``{

    boolean ret = true;
    path useradd = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{

        ret = ret && SCR::Write( add(useradd, key), value);
    });

    y2milestone ("Succesfully written useradd defaults: %1", ret);
    return ret;
}

/**
 * Reads all possible shels and builds the itemlist for add user dialog
 * @return true
 */
define boolean ReadAllShells()``{

    all_shells = GetAllShells (`stringlist);
    all_shells_items = GetAllShells (`items);

    return true;
}

/**
 * Sets the default gid and groupname
 * @param useUI if UI is used
 * @return true
 */
define boolean ReadDefaultGroup(boolean useUI)``{

    default_gid = GetDefaultGid(useUI);
    default_groupname = lookup (GetGroupFromAll(default_gid), "groupname","");

    return true;
}

/**
 * Read the security settings from the system, sets the encoding and various
 * variables
 * @return boolean true on success
 */
global define boolean ReadSystemDefaults()``{ //SecurityDef?

	// pam stuff
	map pam_unix_map = $[];
	list pam_list = SCR::Read(.pam.all.password.pam_unix2);
	if(pam_list != [] && pam_list != nil)
	    pam_unix_map = select(pam_list,0,$[]);

	map pam_check_map = $[];
	pam_list = SCR::Read(.pam.all.password.pam_pwcheck);
	if(pam_list != [] && pam_list != nil)
	    pam_check_map = select(pam_list,0,$[]);

	// set defaults
	max_uid = tointeger (SCR::Read (.etc.login_defs.UID_MAX));
	if (nil == max_uid)
	    max_uid = 60000;
    max_gid = tointeger (SCR::Read (.etc.login_defs.GID_MAX));
    if (nil == max_gid)
        max_gid = 60000;
	max_system_uid = tointeger (SCR::Read (.etc.login_defs.UID_MIN)) - 1;
    if (nil == max_system_uid)
        max_uid = 499;
    max_system_gid = tointeger (SCR::Read (.etc.login_defs.GID_MIN)) - 1;
    if (nil == max_system_gid)
        max_system_gid = 99;
	max_length_uid = size(sformat("%1", max_uid));
	max_length_gid = size(sformat("%1", max_gid));
    max_length_pas = tointeger (SCR::Read (.etc.login_defs.PASS_MAX_LEN));
    if (nil ==  max_length_pas)
        max_length_pas = 8;
    min_length_pas = tointeger (SCR::Read (.etc.login_defs.PASS_MIN_LEN));
    if (nil ==  min_length_pas)
        min_length_pas = 5;
    pass_max_days = tointeger (SCR::Read (.etc.login_defs.PASS_MAX_DAYS));
    if (nil ==  pass_max_days)
        pass_max_days = 99999;
    pass_min_days = tointeger (SCR::Read (.etc.login_defs.PASS_MIN_DAYS));
    if (nil == pass_min_days)
        pass_min_days = 0;
    pass_warn_age = tointeger (SCR::Read (.etc.login_defs.PASS_WARN_AGE));
    if (nil == pass_warn_age)
        pass_warn_age = 7;

	// password encryption
	boolean md5 = contains(splitstring(lookup(pam_unix_map , "arguments", ""),
        " "), "md5");
	boolean blowfish = contains(splitstring(lookup(pam_unix_map , "arguments",
        ""), " "), "blowfish");

	encryption = md5 ? `md5 : blowfish ? `blowfish : `des;

    y2debug ("encryption: %1", Users::encryption);
	// set maximal password length
	if (`des != encryption)
	    max_length_pas = 128;

    encoding = Console::encoding;

	return true;
}


/**
 * Return a map with the defaults for the shadow entry
 * @return map of shadow settings
 */
global define map GetDefaultShadow()``{

	return	$[
           "expire"	: default_expire,
		   "inact"	: default_inactive,
           "last_change": "", // LastChangeIsNow() is called from dialogs
		   "max"	: sformat("%1", pass_max_days),
		   "min"	: sformat("%1", pass_min_days),
		   "warn"	: sformat("%1", pass_warn_age)
    ];
}

/**
 * Return the default home value for a new user.
 * @param useUI if UI is used
 * @return string home directory
 */
global define string GetDefaultHome(boolean useUI)``{

    string def_home = useradd_defaults["home"]:"/home";

    // check for existence of prefix directory
    if (SCR::Read(.target.size, def_home ) == -1 && useUI)
    {
        // Popup tex
        if (UI::YesNoPopup(sformat (_("The default home directory \"%1\" doesn't exist.
Create it now?"), def_home)))
            SCR::Execute (.target.mkdir, def_home);
    }
    if ( (findlastof( def_home, "/") +1) != size(def_home ) )
    {
        def_home = def_home + "/";
    }
    return def_home;
}


/**
 * Return the default group id for a new user.
 * @param useUI if UI is used
 * @return integer gid
 */
global define integer GetDefaultGid(boolean useUI)``{

    string def_gid  = useradd_defaults["group"]:default_gid;
    integer def_int = tointeger(def_gid);
    map group = $[];

    group = GetGroupFromAll (def_int);
    if( group == $[])
    {
        if (useUI)
	        // error popup
	        Report::Error(sformat(_("The default group with the id %1 does not exist.
Please change the default group in /etc/default/useradd."), def_int ));

	    // TODO If group 100/500 does not exists ?
	    return default_gid;
    }
    return def_int;
}

/**
 * Read the /etc/shells file and return a item list or a string shell list.
 * @param todo `items or `stringlist
 * @return list of shells
 */
global define list GetAllShells(symbol todo ) ``{

	list available_shells =  [];
	list shells_read = SCR::Read(.etc.shells);

	foreach( `shell_entry, shells_read, ``{

	    if( is( shell_entry, string ))
	    {
		    if( (! issubstring( shell_entry, "passwd")) &&
		        (! issubstring( shell_entry, "bash1")) )
		    {
		        if(  SCR::Read(.target.size, shell_entry  )  != -1  )
		        {
			        if (todo == `items) available_shells = add(available_shells,
                            `item( `id(shell_entry), shell_entry ));
			        if ( todo == `stringlist ) available_shells =
                            add( available_shells, shell_entry);
		        }
		    }

	    }
	});
	return available_shells;
}



global define list ReadUserCustomSets() ``{

    return [`local];
}

global define boolean WriteUserCustomSets() ``{

    return true;
}

global define list ReadGroupCustomSets() ``{

    return [`local];
}

/**
 * Helper for building items of MenuButton in users/groups summary dialog
 */
global define void BuildMenuButtonItems() ``{

    available_usersets_items = [];
    foreach (`set, available_usersets, ``{
        available_usersets_items = add ( available_usersets_items,
            `item(`id(set), userset_to_string [ set ]:""));
    });

    // build the groups MenuButton items
    available_groupsets_items = [];
    foreach (`set, available_groupsets, ``{
        available_groupsets_items = add ( available_groupsets_items,
            `item(`id(set), groupset_to_string [ set ]:""));
    });

}

/**
 * Reads the settings, used for cache structures
 * @param read_prebuilded if there were some structures prebuilded by extern
 * script and should be readed from files
 */
global define void ReadUsersCache(boolean read_prebuilded) ``{

    // this is ugly -- move it to some Consts module ?
    UsersCache::max_uid         =    max_uid;
    UsersCache::max_gid         =    max_gid;
    UsersCache::max_system_uid  =    max_system_uid;
    UsersCache::max_system_gid  =    max_system_gid;
    UsersCache::max_length_uid  =    max_length_uid;
    UsersCache::max_length_gid  =    max_length_gid;

    UsersCache::encoding        =   encoding;

    // build the users MenuButton items
    BuildMenuButtonItems ();

    current_users = eval (user_custom_sets);
    current_groups = eval (group_custom_sets);

    UsersCache::user_custom_sets = user_custom_sets;
    UsersCache::group_custom_sets = group_custom_sets;

    // use the pre-builded structures also for cache
    if (read_prebuilded)
        UsersCache::ReadFromFiles (tmpdir);
    else
        UsersCache::Read (users, groups, current_users, current_groups);

}

/**
 * Returns the map of users specified by its name
 * @param name user's name
 * @return the desired user's map
 */
global define map GetUserByName ( string name )``{
    map ret = $[];
    integer uid = -1;
    foreach (`type, `usernames, users_by_name, ``{
        if (ret == $[])
        {
            uid = usernames [name]:-1;
            if (uid != -1)
                ret = users [type, uid]:$[];
        }
    });
    return ret;
}

/**
 * Gets the first group with given name
 * @param name group's name
 * @param usertype type of user - group will be searched in this set for first
 * @return the desired group's map
 */
global define map GetGroupByName (string name, symbol usertype)``{
    map ret = $[];

    ret = groups_by_name [usertype, name]:$[];
    if (ret != $[])
        return ret;

    foreach (`type, `groupmap, groups_by_name, ``{
        if (ret == $[])
        {
            ret = groupmap [name]:$[];
        }
    });
    return ret;

    // FIXME: what if there are groups with same name??
}

/**
 * Finds the user specified by uid and set is as current
 * @param uid the user id
 */
global define void SelectUser( integer uid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_users) )
    {
        ret = users[ current_users [i]:nil, uid ]:$[];
        if (ret != $[])
        {
            y2debug("selected user: %1", ret);
            break;
        }
        i = i + 1;
    }
    user_in_work = ret;
}

/**
 * Finds the group specified by gid and set is as current
 * @param gid the group id
 */
global define void SelectGroup( integer gid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_groups) )
    {
        ret = groups [ current_groups [i]:nil, gid ]:$[];
        if (ret != $[])
        {
            y2debug("selected group: %1", ret);
            break;
        }
        i = i + 1;
    }
	group_in_work = ret;
}

/**
 * Return the settings for a group.
 * @param gid the group id
 * @return map of group
 */
global define map GetGroupFromAll( integer gid )``{

    map group = $[];
    foreach (`grouptype, `groupset, groups, ``{
        if (group == $[])
        {
            group = groupset [gid]:$[];
            if (group != $[] && group["type"]:`no == `no)// FIXME
                group ["type"] = grouptype;
        }
    });
	return group;
}

/**
 * This define returns the groups of a user.
 * @param username the name of the user
 * @return string group comma separated list
 */
global define string FindGroupsBelongUser( string username ) ``{

    string grouplist = "";
    foreach (`type, `groupset, groups, ``{
        foreach (`gid, `group, groupset, ``{
            list userlist = splitstring (group["userlist"]:"", ",");
            if (contains (userlist, username))
            {
                if (grouplist == "")
                    grouplist = group["groupname"]:"";
                else
                    grouplist = grouplist + "," + group["groupname"]:"";
            }
        });
    });
    return grouplist;
}

/**
 * Check if homedir doesn't exist for another user
 * @param home the name
 * @return true if exists
 */
global define boolean HomeExists(string home) ``{

    return UsersCache::HomeExists(home);
}

/**
 * Check if UID doesn't already exist
 * @param uid UID
 * @return true if exists
 */
global define boolean UIDExists(integer uid) ``{

    return UsersCache::UIDExists(uid);
}

/**
 * Check if username already exists
 * @param username username
 * @return true if exists
 */
global define boolean UsernameExists(string username) ``{

    return UsersCache::UsernameExists(username);
}

/**
 * Read new set of users - "on demand" (called from running module)
 * @param type the type of users, currently `ldap or `nis
 */
define void ReadNewSet (symbol type) ``{

    if (type == `nis)
    {
        nis_not_read = false;

        UI::OpenDialog (`opt(`decorated ),
            // wait popup
            `Label(_("Reading sets of users and groups, wait please...")));

        // first: run preparation script:
        RunPrepare ("nis");
        // read NIS users now
        users [`nis] = ReadNISUsers (tmpdir);
        users_by_name [`nis] = ReadNISUsersByName (tmpdir);
        groups [`nis] = ReadNISGroups (tmpdir);
        groups_by_name [`nis] = ReadNISGroupsByName (tmpdir);
    }
    else if (type == `ldap)
    {
        // first: check for required packages:
        if (SCR::Execute(.target.bash, "rpm -q perl-ldap cpu yast2-ldap-client") !=0)
        {
            include "require.ycp"; // is it possible to have it here??
            if (RequireAndConflict (["perl-ldap","cpu","yast2-ldap-client"], [],
                // Popup text (required application):
                _("For managing LDAP users, the packages
\"perl-ldap\", \"cpu\" and \"yast2-ldap-client\"
are necessary, but some of them are not present.
Do you want to install them now?")) == false)
                return;
        }
        ldap_not_read = false;
        // check for cpu.cfg
        if (!CpuConfigured (ldap_host, ldap_base))
        {
            // popup text
            if (UI::YesNoPopup(_("It looks like your \"cpu\" program is not configured. 
(It is used for updating LDAP users and groups.)
Do you want to do configure it now?")))
            {
                import "Ldap"; // could it be here ??
                Ldap::Read();
                if (CallFunction(`cpu_configure(true)) == `next)
                    Ldap::WriteCpuSettings();
            }
        }
        ldap_bind_pass = GetLDAPPassword();
        // prepare config file
        WriteLDAPPrepare (tmpdir, ldap_bind_pass);

        UI::OpenDialog (`opt(`decorated ),
            // wait popup
            `Label(_("Reading sets of users and groups, wait please...")));

        // run preparation script for geting users and groups from server:
        if (!RunPrepare ("ldap"))
        {
            // Popup text (required application):
            UI::WarningPopup(_("There was a problem with connecting the LDAP server."));
            UI::CloseDialog(); // the wait popup
            return;
        }
        // read the LDAP users and groups now
        users [`ldap ] = ReadLDAPUsers (tmpdir);
        users_by_name [`ldap ] = ReadLDAPUsersByName (tmpdir);
        groups [`ldap] = ReadLDAPGroups (tmpdir);
        groups_by_name [`ldap] = ReadLDAPGroupsByName (tmpdir);
    }
    UsersCache::ReadUsers (type, tmpdir);
    UsersCache::ReadGroups (type, tmpdir);

    // correct also possible change in custom itemlist
    if (new == `custom)
        UsersCache::ChangeUserCustoms (current_users);

    UI::CloseDialog(); // the wait popup
}

/**
 * Check local groups for presence of non-local users, which was read now
 * and correct that users's grouplists
 * @param type type of users
 */
global define void CorrectUsers(symbol type) ``{

    list new_users = UsersCache::usernamelists [type]:[];

    /* 2 possible solutions:
    1. walk through set of new users and call FindGroupsBelongUser -> too slow
    2. walk through all groups (maybe except "users") and check the correctness
        of its userlist entry -> bit strange
    */
}

/**
 * Change the current users set, additional reading could be necessary
 * @param new the new current set
 */
global define void ChangeCurrentUsers(symbol new) ``{


    if ( new == `custom )
        current_users = eval (user_custom_sets);
    else
        current_users = [ new ];

    if (contains (current_users, `ldap) && ldap_not_read)
        ReadNewSet (`ldap);

    if (contains (current_users, `nis) && nis_not_read)
        ReadNewSet (`nis);

    UsersCache::current_users = current_users;// via some function?
}

/**
 * Change the set of current groups viewed
 * @param new the new current set
 */
global define void ChangeCurrentGroups(symbol new) ``{

    if ( new == `custom )
        current_groups = eval (group_custom_sets);
    else
        current_groups = [ new ];
    if (contains (current_groups, `nis) && nis_not_read)
        ReadNewSet(`nis);
    if (contains (current_groups, `ldap) && ldap_not_read)
        ReadNewSet(`ldap);

    UsersCache::current_groups = current_groups;// via some function?
}

/**
 * Change the value of custom user/group view
 * @param what "user" or "group"
 * @param new the new customs
 */
global define void ChangeCustoms(string what, list new) ``{

    if (what == "user")
    {
        user_custom_sets = new;
        UsersCache::ChangeUserCustoms(new);
    }
    else
    {
        group_custom_sets = new;
        UsersCache::ChangeGroupCustoms(new);
    }
}

/**
 * Change the structure with default values (/etc/defaults/useradd)
 * @param new_defaults new values
 * @param groupname the name of dew default group
 */
global define void SetDefaults (map new_defaults, string groupname)``{

    modified = true;

    foreach (`key, `value, new_defaults, ``{
        if (value != "")
            useradd_defaults[key] = new_defaults[key]:"";
    });
    // remove last '/' from home entry (??)
    string home = useradd_defaults["home"]:"";
    if ( (findlastof( home, "/") +1) == size(home) )
        useradd_defaults["home"] = substring (home, 0, size(home)-1);

    default_gid = tointeger(useradd_defaults["group"]:sformat("%1",default_gid));
    default_groupname = groupname;
    SetDefaultValues(false);
}

/**
 * Sets the time of last password change
 * @return current date string
 */
global define string LastChangeIsNow () ``{
    map out = SCR::Execute(.target.bash_output, "date +%s");
    string days_s = out["stdout"]:"0\n";
    days_s = substring(days_s, 0, size(days_s)-1);
    integer days = (tointeger(days_s) + 3600)/ (60*60*24);
    return sformat("%1", days);
}

/**
 * Runs a script, preparing the data structures
 * @param type type of user/group set to load, can be "passwd", "nis", "ldap"
 * @return true on success
 */
global define boolean RunPrepare(string type) ``{

    integer ret = 1;

    if (type == "passwd")
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_passwd_structures.pl %2 %3 %4 %5 %6", Directory::bindir,
        base_dir, tmpdir, max_system_uid, max_system_gid, encoding));
    }
    else if (type == "nis")
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_nis_structures.pl %2 %3", Directory::bindir, tmpdir,
        encoding));
    }
    else if ( issubstring (type, "ldap") )// ldap has some additional parameters
    {
        string anonymous = "false";
        if (ldap_bind_pass == "")
            anonymous = "true";
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_ldap_structures.pl %2 %3 %4", Directory::bindir,
        tmpdir, encoding, anonymous));
    }
    return (ret == 0);
}

/**
 * The default grouplist for new user
 * @param type type of new user (`local, `system, `nis, `ldap)
 * @return the grouplist
 */
global define string GetDefaultGrouplist (symbol type) ``{

    // check for existence of groups !!
    if (type == `local)
        return "dialout,uucp,video,audio";
    else
        return "";
    // TODO defaults for another types? (ldap)
}

/**
 * Gets the source of user lists from /etc/nsswitch.conf
 * @return list of sources (e.g. [ "ldap", "files" ]
 */
global define list GetUsersSources() ``{

    string passwd_source = SCR::Read(.etc.nsswitch_conf.passwd);
    y2debug("read nsswitch.passwd: %1", passwd_source);

    return splitstring(passwd_source, " ");
}

/**
 * Calls the script which builds the widget contens for EditGroup dialog
 * @param userlist the list of users, having this group as additional
 * @param more_users the list of users, having this group as default group
 * @return the map with widget contents
 */
global define map BuildAdditional (string userlist, string more_users) ``{

    SCR::Write(.target.string, tmpdir + "/additional_userlist", userlist);
    SCR::Write(.target.string, tmpdir + "/additional_moreusers", more_users);
    // do not write all usernames for non-local groups
    if (UsersCache::group_type == `ldap)
        SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
            UsersCache::usernamelists[`ldap]:[]);
    else
        SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
            UsersCache::usernamelists);

    if (0 != SCR::Execute(.target.bash, sformat(
        "%1/build_additional_users.pl %2", Directory::bindir, tmpdir)))
        return $[];
    else
        return $[
            `ulist: SCR::Read(.target.ycp, tmpdir + "/additional_ulist.ycp"),
            `more:  SCR::Read(.target.ycp, tmpdir + "/additional_more.ycp")
        ];
}

/**
 * Re-read the settings, when back was pushed during installation
 * @return true
 */
global define boolean StartAgain() ``{

    y2debug ("reloading unmodified values from disk...");
    Read ( nil, false);
    return true;
}

/**
 * Remove old config options - is used from inst_root.ycp
 */
global define void removeOldConf() ``{

	SCR::Write(.pam.all.password.pam_unix2, "-md5");
	SCR::Write(.pam.all.password.pam_pwcheck, "-md5");

	SCR::Write(.pam.login.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.login.password.pam_unix, "-md5");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.passwd.password.pam_unix, "-md5");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.sshd.password.pam_unix, "-md5");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.rlogin.password.pam_unix, "-md5");

	SCR::Write(.pam.all.password.pam_unix2, "-blowfish");
	SCR::Write(.pam.all.password.pam_pwcheck, "-blowfish");

	SCR::Write(.pam.login.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.login.password.pam_unix, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_unix, "-blowfish");

}

/**
 * Crypt the root password according to method defined in encryptionMethod
 * This is called during install
 * @param pw1 unencrypted password
 * @return void
 */
global define void cryptRootPassword(string pw1) ``{

	if (Mode::test) {
	    return;
	}
	if (encryptionMethod == "md5" )
	{
	    SCR::Write( .pam.all.password.pam_unix2,   "+md5" );
	    SCR::Write( .pam.all.password.pam_pwcheck, "+md5" );
	    rootPassword = cryptmd5 (pw1);
	}
	else if (encryptionMethod == "blowfish" )
	{
	    SCR::Write( .pam.all.password.pam_unix2,   "+blowfish" );
	    SCR::Write( .pam.all.password.pam_pwcheck, "+blowfish" );
	    rootPassword = cryptblowfish (pw1);
	}
	else
	{
	    rootPassword = crypt (pw1);
	}
	return;
}

/**
 * Writes password of superuser
 * @return true on success
 */
global define boolean SetRootPassword() ``{

	return (SCR::Write(.target.passwd.root, rootPassword));
}

/**
 * Checks if the home directory is properly mounted (bug #20365)
 * @return if user wants to continue
 */
global define boolean CheckHomeMounted() ``{

    string mountpoint_in = "";

    // remove last "/"
    string home = substring (default_home, 0, size(default_home) - 1);

    list fstab = SCR::Read(.etc.fstab);
    foreach (`line, fstab, ``{
        if (line["file"]:"" == home)
            mountpoint_in = "/etc/fstab";
    });

    if (SCR::Execute (.target.bash, "/usr/bin/test -e /etc/cryptotab") ==0)
    {
        list cryptotab = SCR::Read(.etc.cryptotab);
        foreach (`line, cryptotab, ``{
            if (line["mount"]:"" == home)
                mountpoint_in = "/etc/cryptotab";
        });
    }

    if (mountpoint_in != "")
    {
        boolean mounted = false;
        list mtab = SCR::Read(.etc.mtab);
        foreach (`line, mtab, ``{
            if (line["file"]:"" == home)
                mounted = true;
        });

        if (!mounted)
            return UI::YesNoPopup(
// Popup text: %1 is the directory (e.g. /home), %2 file name (e.g. /etc/fstab)
// For more info, look at the bug #20365
sformat(_("In %2 there is a mount point for directory
%1 which is used as a default home directory for new
users, but this directory is not mounted now.
If you will add new users using the default values,
their home directories will be created in current %1.
This can imply that these directories won't be accessible
after you mount correctly. Continue users configuration?
"), home, mountpoint_in));

    }
    return true;

}


}// EOF
