/**
 * File:	modules/Users.ycp
 * Package: Configuration of users and groups
 * Summary:	Main module, providing IO functions
 *
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Anas Nashif (nashif@suse.de),
 *          Jiri Suchomel (jsuchome@suse.cz)
 *
 *
 * $Id$
 */
{

module "Users";

textdomain "users";

import "Mode";
import "Progress";
import "Report";
import "UsersCache";
import "MailAliases";
import "Directory";
import "Console";

include "users/routines.ycp";
include "users/nis_routines.ycp";
include "users/ldap_routines.ycp";



// Encryption method: "des", "md5" - for future use: "blowfish"
global string encryptionMethod = "des";

// The root's password
global string rootPassword = "";

/**
 *  keys from /etc/defaults/useradd:
 **/
map useradd_defaults  = $[
    "group": "",
    "home": "",
    "inactive": "",
    "expire": "",
    "shell": "",
    "skel": ""
];

// default values for new users (just shotcuts from useradd_defaults):
global string default_shell = "/bin/bash";
global string default_skel = "/etc/skel";
global string default_home = "/home/";
global integer default_gid = 500; // TODO change to 500 with new version
global string default_groupname = "users";
global string default_inactive = "-1";
global string default_expire = "";

// console encoding - needed for preparation script
string encoding = "";

/*
 * The number of days after a password expires until the account is
 * permanently disabled. A value of 0 disables the
 * account as soon as the password has expired, and a value of -1
 * disables the feature.  The default value is -1.
 */
global integer pass_inact_days = -1;


/*
 * The date on which the user account will be disabled.
 * The date is specified in the format YYYY-MM-DD.
 */
global string pass_expire_date = "";

global string valid_logname_chars  = "0123456789abcdefghijklmnopqrstuvwxyz-_";
global string valid_password_chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#* ,.;:._-+!$%&/|\?{[()]}=";
global string valid_home_chars     = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/_-";
global string valid_group_chars    = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
global string valid_grouplist_chars= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,-_";
global string valid_id_chars       = "0123456789";

global integer max_uid	  = 60000;
global integer max_gid	  = 60000;
global integer max_system_uid = 500 - 1;
global integer max_system_gid = 500 - 1; // TODO change to 500 with new version
global integer max_length_uid = 5;// size(sformat("%1", max_uid));
global integer max_length_gid = 5;
global integer max_length_pas = 8;
global integer min_length_pas = 5;

// Maximum number of days a password may be used:
global integer pass_max_days = 99999;
// Minimum number of days allowed between password changes:
global integer pass_min_days = 0;
// Number of days warning given before a password expires:
global integer pass_warn_age = 7;

global string default_pw     = "******";

global symbol encryption	 = `des;

global string root_mail = "";

// list of user sources - passwd entry from /etc/nsswitch.conf
list user_sources = [];

/* Tha main map of users */
global map users = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

/* Tha main map of groups */
global map groups  = $[
    `system:    $[],
    `local:     $[]];

// main maps of all local shadow and gshadow entries:
global map shadow = $[
    `system:    $[],
    `local:     $[],
    `ldap:      $[]];

map gshadow = $[
    `system:    $[],
    `local:     $[]];

/* structures *_by_name are used for searching */
global map users_by_name = $[];
global map groups_by_name = $[];

/* maps of current user/group */
global map user_in_work = $[];
global map group_in_work = $[];

// the first user, added during install
global map saved_user = $[];

// users, which has been deleted/modified:
map modified_users = $[];
//list modified_groups = [];

// users/groups sets in "Custom" selection:
global list user_custom_sets = [ `local ];
global list group_custom_sets = [ `local ];

// which sets of users/groups are we working with:
global list current_users = [];
global list current_groups = [];

// variables desctibing available users sets:
global boolean is_nis_available = false;
global boolean is_nis_master = false;
global boolean is_ldap_available = false;
global boolean is_ldap_server = false;

// type of pam kerberos authentication: required/optional/sufficient/""
global string kerberos_auth = "";

// users like ldap/nis are not read by default, but could be read on demand:
boolean nis_not_read = true;
boolean ldap_not_read = true;

// which sets of users/groups are available to work with:
global list available_usersets = [ `system, `local];
global list available_usersets_items = [];
global list available_groupsets = [ `system, `local];
global list available_groupsets_items = [];

/* where the user/group/password data are stored
   (can be different on NIS server) */
global string base_dir = "/etc";

// list of available shells (read in GetAllShells)
global list all_shells = [];
global list all_shells_items = [];

// the +/- entries in config files:
string plus_passwd = "";
string plus_group = "";
string plus_shadow = "";
string plus_gshadow = "";

// ldap configuration from /etc/openldap/ldap.conf
string ldap_host = "";
string ldap_base = "";

string tmpdir = "/tmp"; // do not write to /tmp only!

global string start_dialog = "users";
global boolean use_next_time = true; // what is it for ??

// if anything was done
global boolean modified = false;

// values to MenuItem in Summary dialog
global map userset_to_string = $[
    // the type of user set
    `system:    _("&System users"),
    // the type of user set
    `local:     _("&Local users"),
    // the type of user set
    `nis:       _("&NIS users"),
    // the type of user set
    `ldap:      _("L&DAP users"),
    // the type of user set
    `samba:     _("Sam&ba users"),
    // the type of user set
    `custom:    _("&Custom")
];

global map groupset_to_string = $[
    // the type of group set
    `system:    _("&System groups"),
    // the type of group set
    `local:     _("&Local groups"),
    // the type of group set
    `ldap:      _("L&DAP groups"),
    // the type of group set
    `samba:     _("Sam&ba groups"),
    // the type of group set
    `custom:    _("&Custom")
];


/**
 * Read all the settings
 * @param useUI boolean use user interface (change progress bar)
 * @return symbol `next if success, else `abort
 */
global define symbol Read (block abort, boolean useUI) ``{

	// progress caption
	string caption = _("Initializing user and group configuration");
	integer no_of_steps = 9;

	// We do not set help text here, because it was set outside
	if( useUI )
	    Progress::New (caption, " ", no_of_steps,
			// progress label
		       [ _("Read the default login settings"),
			// progress label
			 _("Read the default system settings"),
			// progress label
			 _("Read the configuration type"),
			// progress label
			 _("Build the data structures"),
			// progress label
			 _("Read the password settings"),
			// progress label
			 _("Read the group settings"),
			// progress label
			 _("Read the user settings"),
			// progress label
			 _("Read the custom settings"),
			// progress label
			 _("Build the cache structures")
           ],
			// progress label
		       [ _("Reading the default login settings..."),
			// progress label
			 _("Reading the default system setttings..."),
			// progress label
			 _("Reading the configuration type..."),
			// progress label
			 _("Building the data structures..."),
			// progress label
			 _("Reading the password settings..."),
			// progress label
			 _("Reading the group settings..."),
			// progress label
			 _("Reading the user settings..."),
			// progress label
			 _("Reading the custom settings"),
			// progress label
			 _("Building the cache structures"),
			// progress label
			 _("Finished") ],
			    "" );

	// read default login settings
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    UsersCache::PrintDate ("begin");

	if ( ! ReadLoginDefaults(useUI) )
	{
		// warning popup
	    Report::Warning (_("Cannot read the default login settings."));
	}

	// read default system settings
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

	if ( ! ReadSystemDefaults() )
	{
		// error popup
	    Report::Error (_("Cannot read the default systems settings."));
	}

	// read configuration type
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    UsersCache::PrintDate ("before sources");

    ReadSourcesSettings();

    if ( is_nis_master && useUI)
    {
        string dir = ReadNISConfigurationType (base_dir);
        if (dir == nil)
            return `abort; // aborted in NIS server dialog
        else
            base_dir = dir;
    }

	// run script for pre-building structures
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    tmpdir = SCR::Read(.target.tmpdir);
    UsersCache::PrintDate ("bef run prepare");

    if ( !RunPrepare("passwd") )
    {
	    Report::Error (_("Cannot run preparation script."));
    }
    UsersCache::PrintDate ("after run prepare");

	// read password settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    UsersCache::PrintDate ("before read");

    gshadow = ReadGshadow(tmpdir);

    UsersCache::PrintDate ("gshadow");

    shadow = ReadShadow (tmpdir);
    UsersCache::PrintDate ("shadow");

    plus_shadow = ReadPlusShadow(tmpdir);
    plus_gshadow = ReadPlusGshadow(tmpdir);

	if ( (gshadow == nil) || (shadow == nil) )
    {
		// error popup
	    Report::Error (_("Cannot read the password settings."));
	    //return `abort;
    }

	// read group settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    groups = ReadGroups(tmpdir);
    UsersCache::PrintDate ("groups");
    groups_by_name = ReadGroupsByName(tmpdir);
    UsersCache::PrintDate ("groups_by_name");
    plus_group = ReadPlusGroup(tmpdir);

	if ( groups [`local]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the local group settings."));
        groups [`local] = $[];
    }
    if ( groups [`system]:nil == nil)
    {
		// error popup
	    Report::Error (_("Cannot read the system group settings."));
        groups [`system] = $[];
    }

	// read user settings
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}

    users = ReadPasswd (tmpdir);
    UsersCache::PrintDate ("users");

    plus_passwd = ReadPlusPasswd (tmpdir);
    users_by_name = ReadPasswdByName (tmpdir);
    UsersCache::PrintDate ("users_by_name");

	if (users [`local]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the local user settings."));
        users [`local] = $[];
    }
    if ( users [`system]:nil == nil )
    {
		// error popup
	    Report::Error (_("Cannot read the system user settings."));
        users [`system] = $[];
    }

	// read customs
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    user_custom_sets = ReadUserCustomSets();
    group_custom_sets = ReadGroupCustomSets();

    // There is no progress for this !!!
    ReadAllShells();
    ReadDefaultGroup(useUI);

	// build the cache
	if( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return `abort;
	    }
	}
    ReadUsersCache(true);
    UsersCache::PrintDate ("cache");

	// increase the progress to "finish"
	if( useUI ) Progress::NextStage ();

	return `next;
}

/**
 * Saves users into the system
 * @param abort abort block
 * @param useUI if user interface (progress bar and popups) should be used
 */
global define symbol Write (block abort, boolean useUI)``{

    string write_dir = base_dir;//"/tmp"; // -- just for testing

	// progress caption
	string caption = _("Writing user and group configuration");
	integer no_of_steps = 7;

	// We do not set help text here, because it was set outside
	if( useUI )
	    Progress::New (caption, " ", no_of_steps, [
			// progress label
			_("Backup the configuration files"),
			// progress label
			_("Check for deleted users"),
			// progress label
			_("Write users"),
			// progress label
			_("Write passwords"),
			// progress label
			_("Write groups"),
			// progress label
			_("Write the custom settings"),
			// progress label
		    _("Write the default login settings")
           ],
			// progress label
		       [ _("Creating backup of configuration files..."),
			// progress label
			_("Checking deleted users..."),
			// progress label
			_("Writing users..."),
			// progress label
			_("Writing passwords..."),
			// progress label
			_("Writing groups..."),
			// progress label
			_("Writing the custom settings..."),
			// progress label
		    _("Writing the default login settings..."),
			// progress label
			_("Finished") ],
			    "" );

	// backup
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    BackupConfFiles(base_dir);

    // currently I count only with system/local users
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    foreach (`user, modified_users [`local]:[], ``{
        if (user["delete_home"]:false)
        {
            // -- what if the home was changed??
            string home = user["home"]:"";
            y2milestone ("The directory %1 is deleted", home);
            string command = sformat("/bin/rm -rf %1", home);
            y2debug("rm return value: %1",
                SCR::Execute(.target.bash, command));
        }
    });
    foreach (`user, modified_users [`system]:[], ``{
        if (user["delete_home"]:false)
        {
            // -- what if the home was changed??
            string home = user["home"]:"";
            y2milestone ("The directory %1 is deleted", home);
            string command = sformat("/bin/rm -rf %1", home);
            y2debug("rm return value: %1",
                SCR::Execute(.target.bash, command));
        }
    });

    // write passwd
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    // add the edited or new users to modified_users
    modified_users [`passwd] = WritePasswd (write_dir, users [`system]:$[],
        users[`local]:$[], plus_passwd);

    if (modified_users [`passwd]:[] == nil)
    {
        if ( useUI)
            // error popup
	        Report::Error (_("Cannot write passwd file."));
        else
            y2error ("Cannot write passwd file.");
        modified_users [`passwd] = [];
    }

    // check for homedir changes
    foreach (`user, modified_users [`passwd]:[], ``{
        string home = user["home"]:"";
        string username = user["username"]:"";
        string command = "";
        if (user["modified"]:`nothing == `added)
        {
            if (user["create_home"]:true)
            {
                // TODO create a path to new home directory
                y2milestone ("The directory %1 is created", home);
                // copy homedir from skel
                command = sformat("/bin/cp -r %1 %2",default_skel,home);
                y2debug("cp return value: %1",
                    SCR::Execute(.target.bash, command));
            }
            // change the rights
            string groupname = user["groupname"]:default_groupname;
            command = sformat("/bin/chown -R %1:%2 %3",username,groupname,home);
            y2debug("chown return value: %1",
                SCR::Execute(.target.bash, command));
            // call the useradd.local (-- check the existence ??)
            command = sformat("/usr/sbin/useradd.local %1", username);
            y2debug("useradd.local return value: %1",
                SCR::Execute(.target.bash, command));

        }
        else // only `edited can be here
        {
            string org_home = user["org_home"]:home;
            if (home != org_home)
            {
                if (user["create_home"]:true) // move the home directory
                {
                    y2milestone ("The directory %1 is moved to %2",
                        org_home, home);
                    command = sformat("/bin/mv %1 %2", org_home, home);
                    y2debug("mv return value: %1",
                        SCR::Execute(.target.bash, command));
                }
                else // directory already exists
                {
                    // change the rights
                    string groupname = user["groupname"]:default_groupname;
                    command = sformat("/bin/chown -R %1:%2 %3", username,
                        groupname, home);
                    y2debug("chown return value: %1",
                        SCR::Execute(.target.bash, command));
                }
            }
            integer uid = user["uid"]:nil;
            integer org_uid = user["org_uid"]:uid;
            string groupname = user["groupname"]:default_groupname;
            if (uid != org_uid)
            {
                // change the rights of user's files
                y2milestone ("UID of user %1 was changed, changing rights of files in %2", username, home);
                command = sformat("/bin/chown -R %1:%2 %3", username,
                    groupname, home);
                y2debug("chown return value: %1",
                    SCR::Execute(.target.bash, command));
            }
        }
    });
    // ldap
    /*
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}*/
    if (size (modified_users [`ldap]:[]) > 0 )
    {
        // ask for bind password
        string pass = "";
        if (useUI)
            pass = GetLDAPPassword();

        if (! WriteLDAPUsers (
                modified_users [`ldap]:[], is_ldap_server, tmpdir, pass))
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write ldap users."));
            else
                y2error ("Cannot write ldap users.");
        }
    }

    // shadow, gshadow
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}

    // -- send whole structure and decide in the write function
    if (! WriteShadow(write_dir, shadow[`system]:$[], shadow[`local]:$[], plus_shadow))
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write shadow file."));
        else
            y2error ("Cannot write shadow file.");
    }

    if (! WriteGshadow(write_dir, gshadow[`system]:$[], gshadow[`local]:[], plus_gshadow))
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write gshadow file."));
        else
            y2error ("Cannot write gshadow file.");
    }

    // group
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    if (! WriteGroup (write_dir, groups [`system]:$[], groups[`local]:$[],
         plus_group))
    {
        if (useUI)
            // error popup
	        Report::Error (_("Cannot write group file."));
        else
            y2error("Cannot write group file.");
    }

    // call make on NIS server
    if (is_nis_master)
    {
        map ret = SCR::Execute(.target.bash_output, "/usr/bin/make -C /var/yp");
        if (ret["exit"]:1 != 0)
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot make NIS database."));
            else
                y2error("Cannot make NIS database: %1", ret);
        }
    }

    // customs
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    WriteUserCustomSets();

    // useradd defaults
	if ( useUI )
	{
	    Progress::NextStage ();
	    if (eval (abort))
		    return `abort;
	}
    WriteLoginDefaults();

    // mail forward from root
    if (Mode::cont && root_mail != "")
    {
        if (! MailAliases::SetRootAlias (root_mail))
            // error popup
            Report::Error(_("There was an error while setting forwarding for root's mail."));
    }

    // call only after `back or `abort
    //    RemoveTmp (tmpdir);

	// increase the progress to "finish"
	if( useUI ) Progress::NextStage ();

	return `next;
}


/**
 * Summary for autoinstalation
 */
global define string Summary() ``{

    string ret = "Summary of users and groups:<br>";

    // do not show system users/groups ??
    ret = ret + "<p><i>Users:</i><p>";
    foreach (`uid, `user, users [`local]:$[], ``{
            ret = ret + sformat(" %1 %2 %3<br>", uid, user["username"]:"",
                user["fullname"]:"" );
    });
    ret = ret + "<p><i>Groups:</i><p>";
    foreach (`gid, `group, groups [`local]:$[], ``{
            ret = ret + sformat(" %1 %2<br>", gid, group["groupname"]:"");
    });

    return ret;
}

/**
 * Get all the user configuration from the list of maps.
 * Is called users_auto (preparing autoinstallation data).
 * @param settings	A list of maps of type:
 * [ users, groups, shadow, gshadow, useradds_defaults ]
 * to be added to the system.
 * @return	success
 */
global define boolean Import (list settings) ``{

    // probably only the local users/groups are in settings
    y2debug("importing: %1", settings);

    users = settings[0]:users;
    groups = settings[1]:groups;
    shadow = settings[2]:shadow;
    gshadow = settings[3]:gshadow;

    if (settings[4]:$[] == $[])
        ReadLoginDefaults();
    else
        useradd_defaults = settings[4]:$[];

    ReadSystemDefaults();
    tmpdir = SCR::Read(.target.tmpdir);
    RunPrepare("passwd"); // creates the files with data structures in tmpdir

    // read the system users from local file if they're not in parameters
    if (users [`system]:nil == nil || users [`system]:nil == $[])
    {
        map passwd_users = ReadPasswd (tmpdir);
        users [`system] = passwd_users [`system]:$[];
        map passwd_users_by_name = ReadPasswdByName (tmpdir);
        users_by_name [`system] = passwd_users_by_name[`system]:$[];
    }
    if (users [`local]:nil == nil)
        users = add (users, `local, $[]);

    users_by_name [`local] = UsersByName (users [`local]:$[]);
    // -- move the plus_strings to if sections ??
    plus_passwd = ReadPlusPasswd (tmpdir);

    if (groups [`system]:nil == nil || groups [`system]:nil == $[])
    {
        map all_groups = ReadGroups (tmpdir);
        map system_groups = all_groups [`system]:$[];
        // but we're not interested in local userlists...
        system_groups = RemoveDiskUsersFromGroups(system_groups);
        groups [`system] = system_groups;
        // hack for group users, which is count as local
        if ( lookup (GetGroupFromAll (100), "groupname", "") != "users" &&
             lookup (GetGroupFromAll (500), "groupname", "") != "users")
        {
            map local_groups = all_groups [`local]:$[];
            map group = local_groups [default_gid]:
                $[ "gid": default_gid, "groupname": "users",
                   "password": "x", "userlist": "games"];
            local_groups = RemoveDiskUsersFromGroups ($[ default_gid: group ]);
            groups [`local] = union (groups [`local]:$[], local_groups);
        }
        groups_by_name = GroupsByName (system_groups);
    }
    if (groups [`local]:nil == nil)
        groups = add (groups, `local, $[]);
    groups_by_name = union (groups_by_name, GroupsByName (groups [`local]:$[]));
    plus_group = ReadPlusGroup(tmpdir);

    if (shadow [`system]:nil == nil || shadow [`system]:nil == $[])
    {
        map all_shadow = ReadShadow (tmpdir);
        shadow [`system] = all_shadow[`system]:$[];
    }
    if (shadow [`local]:nil == nil)
        shadow = add (shadow, `local, $[]);
    plus_shadow = ReadPlusShadow(tmpdir);

    if (gshadow [`system]:nil == nil || gshadow [`system]:nil == $[])
    {
        map all_gshadow = ReadGshadow (tmpdir);
        gshadow [`system] = all_gshadow[`system]:$[];
    }
    if (gshadow [`local]:nil == nil)
        gshadow = add (gshadow, `local, $[]);
    plus_gshadow = ReadPlusGshadow(tmpdir);

    // maybe the `system users/groups shouldn't be available??
    available_usersets = [`local, `system];
    available_groupsets = [`local, `system];

    ReadAllShells();
    ReadDefaultGroup(false);

    ReadUsersCache(false);

    return true;
}


/**
 * Reseting the values (probably to empty set) - to use for autoinstallation
 * @param settings same as in Import
 */
global define Set (list settings) ``{

    users [`local] = settings[0, `local]:$[];
    users_by_name [`local] = UsersByName (users [`local]:$[]);

    groups [`local] = settings[1, `local]:$[];
    groups_by_name = union (ReadGroupsByName (tmpdir),
        GroupsByName (groups [`local]:$[]));

    shadow [`local] = settings[2, `local]:$[];
    gshadow [`local] = settings[3, `local]:$[];

    if (settings[4]:$[] != $[])
        useradd_defaults = settings[4]:$[];

    UsersCache::EmptyStructures();
    ReadUsersCache(false);
}

/**
 * Dump the users settings to list of maps
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export() ``{

    return [ users, groups, shadow, gshadow, useradd_defaults ];
}

/**
 * Helper function, which corects the userlist entry of each group.
 * During autoinstallation, system groups are loaded from the disk,
 * and the userlists of these groups can contain the local users,
 * which we don not want to Import. So they are checked here.
 */
global define map RemoveDiskUsersFromGroups (map disk_groups) ``{

	map ret = mapmap (`gid, `group, disk_groups, ``{

        map new_group = group;

        foreach (`list_of_users, ["userlist", "more_users"], ``{

            list userlist = splitstring (group[list_of_users]:"", ",");
            string userlist_s = "";
            foreach (`username, userlist, ``{
                if (haskey (users_by_name [`system]:$[], username) ||
                    haskey (users_by_name [`local]:$[], username))
                {
                    if (userlist_s == "")
                        userlist_s = username;
                    else
                        userlist_s = userlist_s + "," + username;
                }
            });
            new_group[list_of_users] = userlist_s;
        });

	    return [ gid, new_group ];
	});

    return ret;
}

// prepare user/group_in_work for Commit
global define boolean Add (string what, map data)``{

    if (what == "user")
        user_in_work = $[];
    else
        group_in_work = $[];
    return true;
}

global define boolean Edit (string what, map data)``{

    return true;
}

global define boolean Delete (string what, map data)``{

    return true;
}


/**
 * Update the global user and/or group map with current
 * user_in work or group_in_work
 * @param object "user" or "group"
 * @return true on success
 */
global define boolean Commit (string object, boolean cache)``{

    modified = true;

    if (object == "user")
    {
//y2milestone("user : %1", user_in_work );
        integer uid = user_in_work ["uid"]:max_uid;
        integer org_uid = user_in_work ["org_uid"]:uid;
        symbol what_user = user_in_work ["what"]:`nothing;
        symbol type = user_in_work ["type"]:`local;
        string username = user_in_work ["username"]:"";
        string org_username = user_in_work ["org_username"]:username;
        string grouplist = user_in_work ["grouplist"]:"";
        string defgroup = user_in_work ["groupname"]:default_groupname;
        list group_list = splitstring (grouplist, ",");//remove ""
        group_list = filter (`g, group_list, ``(g != ""));

        // the action
        if ( what_user == `add_user )
        {
            // when writing the new user, the new home has to be created
            user_in_work ["modified"] = `added;
            // update the affected groups
            foreach (`group, group_list, ``{
                group_in_work = eval (groups_by_name [group]:$[]);
                if (group_in_work == $[])
                {
                    y2error("Group %1 doesn't exist!", group);
                }
                else
                {
                    group_in_work ["what"] = `user_change;
                    string userlist = group_in_work ["userlist"]:"";
                    list userlist_l = splitstring (userlist, ",");
                    if (!contains(userlist_l, username))
                    {
                        if (userlist != "") userlist = userlist + ",";
                        group_in_work ["userlist"] = userlist + username;
                        Commit ("group", cache);
                    }
                }
            });
            // add user to his default group -- updating only cache variables
            group_in_work = eval (groups_by_name [defgroup]:$[]);
            if (group_in_work == $[])
            {
                y2error("Group %1 doesn't exist!", defgroup);
            }
            else
            {
                group_in_work ["what"] = `user_change;
                string more_users = group_in_work ["more_users"]:"";
                if (more_users != "") more_users = more_users + ",";
                group_in_work ["more_users"] = more_users + username;
                Commit ("group", cache);
            }
            // modify global shadow map:
            shadow [type] = add(shadow [type]:$[],
                 username, user_in_work["shadow"]:$[]);

            if (type == `ldap)
                modified_users [type] = add (modified_users[type]:[],
                    user_in_work);
        }
        else if ( what_user == `edit_user )
        {
            if (user_in_work ["modified"]:`nothing != `added)
                user_in_work ["modified"] = `edited;
            // check the change of additional group membership
            foreach (`group, group_list, ``{
                group_in_work = eval (groups_by_name [group]:$[]);
                if (group_in_work == $[]) return;
                string userlist = group_in_work ["userlist"]:"";
                list l_userlist = splitstring (userlist, ",");
                // username changed
                if ((org_username != username) &&
                    (contains (l_userlist, org_username)))
                {
                    group_in_work ["what"] = `user_change;
                    l_userlist = filter (`u, l_userlist, ``(u != org_username));
                    userlist = mergestring (l_userlist, ",");
                    if (userlist != "") userlist = userlist + ",";
                    group_in_work ["userlist"] = userlist + username;
                    Commit ("group", cache);
                }
                // user was added to the new group
                else if (!contains (l_userlist, org_username))
                {
                    group_in_work ["what"] = `user_change;
                    if (userlist != "") userlist = userlist + ",";
                    // username can be changed here
                    group_in_work ["userlist"] = userlist + username;
                    Commit ("group", cache);
                }
            });
            // check the removing user from some additional group
            list removed_group_list = user_in_work ["removed_grouplist"]:[];
            foreach (`group, removed_group_list, ``{
                group_in_work = eval (groups_by_name [group]:$[]);
                if (group_in_work == $[]) return;
                string userlist = group_in_work ["userlist"]:"";
                list l_userlist = splitstring (userlist, ",");
                if (contains (l_userlist, org_username)) // always true?
                {
                    group_in_work ["what"] = `user_change;
                    l_userlist = filter (`u, l_userlist, ``(u != org_username));
                    userlist = mergestring (l_userlist, ",");
                    group_in_work ["userlist"] = userlist;
                    Commit ("group", cache);
                }
            });
            // check the change in default group
            string org_defgroup = user_in_work ["org_groupname"]:defgroup;
            if ((username != org_username) && (defgroup == org_defgroup))
            {
                // change the user's name in current default group
                group_in_work = eval (groups_by_name [defgroup]:$[]);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change;
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            else if (defgroup != org_defgroup)
            {
                // note: username could be also changed!
                // remove the name from original group ...
                group_in_work = eval (groups_by_name [org_defgroup]:$[]);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change;
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    group_in_work ["more_users"] = more_users;
                    Commit ("group", cache);
                }
                // and add it to the new one;
                group_in_work = eval (groups_by_name [defgroup]:$[]);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = `user_change;
                    more_users = group_in_work ["more_users"]:"";
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            // modify the shadow entry
            if (type == `local || type == `system) // - also for groups !
            {
                if (username != org_username)
                    shadow [type] = remove (shadow[type]:$[], org_username);
                shadow [type, username] = user_in_work["shadow"]:$[];
            }
            if (type == `ldap)
                modified_users [type] = eval (add (modified_users[type]:[],
                    user_in_work));
                // without that eval, there could be changed org_username
        }
        else if ( what_user == `delete_user )
        {
            // check the change of group membership
            foreach (`group, group_list, ``{
                group_in_work = eval (groups_by_name [group]:$[]);
                if (group_in_work != $[])
                {
                    string userlist = group_in_work ["userlist"]:"";
                    list l_userlist = splitstring (userlist, ",");
                    if (contains (l_userlist, username)) // always true?
                    {
                        group_in_work ["what"] = `user_change;
                        l_userlist = filter (`u, l_userlist, ``(u != username));
                        userlist = mergestring (l_userlist, ",");
                        group_in_work ["userlist"] = userlist;
                        Commit ("group", cache);
                    }
                }
            });
            // remove user from his default group -- only cache structures
            group_in_work = eval (groups_by_name [defgroup]:$[]);
            group_in_work ["what"] = `user_change;
            string more_users = group_in_work ["more_users"]:"";
            list l_more_users = splitstring (more_users, ",");
            l_more_users = filter (`u, l_more_users, ``(u != username));
            more_users = mergestring (l_more_users, ",");
            group_in_work ["more_users"] = more_users;
            Commit ("group", cache);

            // prevent the add & delete of the same user
            if (user_in_work["modified"]:`nothing != `added)
            {
                user_in_work ["modified"] = `deleted;
                modified_users [type] = add (modified_users [type]:[],
                    user_in_work);
            }
            else //was added and is beeing deleted
            {
                if (type == `ldap)
                    modified_users [type] = filter(`u, modified_users [type]:[],
                        ``(u ["username"]:"" != username));

            }
            if (type != `ldap)
                shadow [type] = remove (shadow [type]:$[], org_username);
        }
        else if ( what_user == `group_change)
        {
                // prevent loading this argument with some unwanted value later
                user_in_work ["modified"] = `nothing;
        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeUser(what_user, user_in_work);

        // the main action: update users -- what if uid is changed?
        if (what_user == `delete_user)
        {
            users [type] = remove (users[type]:$[], uid);
            users_by_name [type] = remove (users_by_name[type]:[], username);
        }
        else // also `group_change !
        {
            if (uid != org_uid)
            {
                users_by_name [type, username ] = uid;
                users [type] = remove (users [type]:$[], org_uid);
            }
            users [ type, uid ] = eval (user_in_work);

            // this has to be done due to multiple changes of username -- ??
            // and what about the home and others??
            users [type, uid, "org_username"] = username;
        }
    }
    else if ( object == "group" )
    {
        integer gid = group_in_work ["gid"]:max_gid;
        integer org_gid = group_in_work ["org_gid"]:gid;
        symbol what_group = group_in_work ["what"]:`nothing;
        symbol type = group_in_work ["type"]:`local;
        string groupname = group_in_work ["groupname"]:"";
        string password = group_in_work ["password"]:"*";
        string org_groupname = group_in_work ["org_groupname"]:groupname;
        string userlist = group_in_work ["userlist"]:"";
        list l_userlist = splitstring (userlist, ",");
//y2milestone("group: %1", group_in_work);

        if (org_groupname == "")
            org_groupname = groupname;

        if ( what_group == `add_group )
        {
            group_in_work ["modified"] = `added;
            // update users's grouplists (only local structures)
            foreach (`user, l_userlist, ``{
                // -- what if user doesn't exist??
                user_in_work = GetUserByName (user);
                string grouplist = user_in_work ["grouplist"]:"";
                if (grouplist != "")
                   grouplist = grouplist + ",";
                user_in_work["grouplist"] = grouplist + groupname;
                user_in_work["what"] = `group_change;
                Commit("user", cache);
            });
            // create an entry for global gshadow map:
            gshadow [type, groupname] = $[
               "password": password,
               "disposer": "root", // default??
               "userlist": ""]; // will be updated at the end
        }
        else if (what_group == `edit_group )
        {
            if (group_in_work ["modified"]:`nothing != `added)
                group_in_work ["modified"] = `edited;
            // update users's grouplists (mainly local structures)
            foreach (`user, l_userlist, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    boolean commit_user = false;
                    // new user added to group
                    if (! contains (l_grouplist, org_groupname))
                    {
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    else if (org_groupname != groupname)
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        // what about ",,"?
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    if (commit_user)
                    {
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                }
            });
            // check the additional users removed from this group
            list removed_user_list = group_in_work ["removed_userlist"]:[];
            foreach (`user, removed_user_list, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    if ( contains (l_grouplist, org_groupname))
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        user_in_work["grouplist"] = grouplist;
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                }
            });
            // correct the changed groupname/gid for users with this group
            // as default
            if ((groupname != org_groupname) || (gid != org_gid))
            {
                string more_users = group_in_work ["more_users"]:"";
                list l_more_users = splitstring (more_users, ",");
                foreach (`user, l_more_users, ``{
                    user_in_work = GetUserByName (user);
                    if (user_in_work != $[])
                    {
                        user_in_work["groupname"] = groupname;
                        user_in_work["gid"] = gid;
                        user_in_work["what"] = `group_change;
                        Commit("user", cache);
                    }
                });
            }
            // modify the gshadow -- userlist ??
            if (groupname != org_groupname)
            {
                gshadow [type, groupname] = gshadow [type, org_groupname]:$[];
                gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            }
            if (password != "x" && password != "*")
                gshadow [type, groupname, "password"] = password;
        }
        else if (what_group == `delete_group )
        {
            // deleted group had no members
            group_in_work ["modified"] = `deleted;
            groups [type] = remove (groups [type]:$[], org_gid);
            groups_by_name = remove (groups_by_name, org_groupname);
            gshadow [type] = remove (gshadow [type]:$[], org_groupname);
        }
        else if ( what_group == `add_user ) // do not call Commit again
        {

        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeGroup(what_group, group_in_work);

        if (what_group != `delete_group) // also for `change_user!
        {
            // the main action: update groups
            if (gid != org_gid)
                groups [ type ] = remove (groups [type]:$[], org_gid);
            groups [ type, gid ] = group_in_work;
            // name could have been changed !!
            if (groupname != org_groupname)
                groups_by_name = remove (groups_by_name, org_groupname);
            groups_by_name [ groupname ] = group_in_work;

            // update userlist in gshadow??
            if (haskey (gshadow [type]:$[], groupname))
                gshadow [type, groupname, "userlist"] = userlist;

            // this has to be done due to multiple changes of groupname ??
            groups [type, gid, "org_groupname"] = groupname;
        }
    }
    return true;
}
/**
 * Checks the possible user sources
 */
global define void ReadSourcesSettings () ``{

    available_usersets = [ `local, `system ];
    available_groupsets = [ `local, `system ];

    user_sources = GetUsersSources ();
    is_nis_available = IsNISAvailable (user_sources);
    is_nis_master = IsNISMaster ();
    is_ldap_available = IsLDAPAvailable (user_sources);
    kerberos_auth = KerberosAuth();

    if ( !is_nis_master && is_nis_available )
    {
            available_usersets = add ( available_usersets, `nis);
    }

    if ( is_ldap_available )
    {
        ldap_base = GetLDAPBase();
        ldap_host = GetLDAPHost();
        is_ldap_server = IsLDAPServer (ldap_host);

        available_usersets = add ( available_usersets, `ldap);
    }

    available_usersets = add ( available_usersets, `custom);
    available_groupsets = add ( available_groupsets, `custom);
}

/**
 * Return map for mapping user names to UIDs
 * @return map mapping
 */
global define map UsersByName (map usermap) ``{
	map res = mapmap (`k, `v, usermap, ``{
	    return [ lookup (v, "username", ""), k ]; // only uid !!
	});
	return res;
}

/**
 * Maps groupname to group's map
 * @return map mapping
 */
global define map GroupsByName (map groupsmap) ``{
	map res = mapmap (`k, `v, groupsmap, ``{
	    return [ lookup (v, "groupname", ""), v ]; // whole map??
	});
	return res;
}

/**
 * Fills the variables with the default values
 * (used only for better access)
 */
define void SetDefaultValues(boolean useUI) ``{

    pass_inact_days  = tointeger( useradd_defaults["inactive"]:"-1" );
    pass_expire_date = useradd_defaults["expire"]:"";

    default_shell = useradd_defaults["shell"]:default_shell;
    default_skel = useradd_defaults["skel"]:default_skel;
    default_expire = useradd_defaults["expire"]:default_expire;
    default_inactive = useradd_defaults["inactive"]:default_inactive;
    default_home = GetDefaultHome(useUI);
}

/**
 * Reads settings from /etc/defaults/useradd
 * @return true on success
 */
global define boolean ReadLoginDefaults(boolean useUI)``{

    path useradd_path = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{
        path entry_path = add (useradd_path, key);
        useradd_defaults[key] = deletechars (SCR::Read(entry_path), "\"");
    });

    if( useradd_defaults == $[] || useradd_defaults == nil )
	    return false;

    SetDefaultValues(useUI);
    return true;
}

/**
 * Writes settings to /etc/defaults/useradd
 * @return true on success
 */
global define boolean WriteLoginDefaults()``{

    boolean ret = true;
    path useradd = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{

        ret = ret && SCR::Write( add(useradd, key), value);
    });

    y2milestone ("Succesfully written useradd defaults: %1", ret);
    return ret;
}

/**
 * Reads all possible shels and builds the itemlist for add user dialog
 * @return true
 */
define boolean ReadAllShells()``{

    all_shells = GetAllShells (`stringlist);
    all_shells_items = GetAllShells (`items);

    return true;
}

/**
 * Sets the default gid and groupname
 * @return true
 */
define boolean ReadDefaultGroup(boolean useUI)``{

    default_gid = GetDefaultGid(useUI);
    default_groupname = lookup (GetGroupFromAll(default_gid), "groupname","");

    return true;
}

/**
 * Read the security settings from the system, sets the encoding and various
 * variables
 * @return boolean true on success
 */
global define boolean ReadSystemDefaults()``{ //SecurityDef?

	// pam stuff
	map pam_unix_map = $[];
	list pam_list = SCR::Read(.pam.all.password.pam_unix2);
	if(pam_list != [] && pam_list != nil)
	    pam_unix_map = select(pam_list,0,$[]);

	map pam_check_map = $[];
	pam_list = SCR::Read(.pam.all.password.pam_pwcheck);
	if(pam_list != [] && pam_list != nil)
	    pam_check_map = select(pam_list,0,$[]);

	// md5 support
	boolean md5 = contains(splitstring(lookup(pam_unix_map , "arguments", ""),
        " "), "md5");
	boolean blowfish = contains(splitstring(lookup(pam_unix_map , "arguments",
        ""), " "), "blowfish");

	// set defaults
	max_uid = tointeger (SCR::Read (.etc.login_defs.UID_MAX));
	if (nil == max_uid)
	    max_uid = 60000;
    max_gid = tointeger (SCR::Read (.etc.login_defs.GID_MAX));
    if (nil == max_gid)
        max_gid = 60000;
	max_system_uid = tointeger (SCR::Read (.etc.login_defs.UID_MIN)) - 1;
    if (nil == max_system_uid)
        max_uid = 499;
    max_system_gid = tointeger (SCR::Read (.etc.login_defs.GID_MIN)) - 1;
    if (nil == max_system_gid)
        max_system_gid = 99;
	max_length_uid = size(sformat("%1", max_uid));
	max_length_gid = size(sformat("%1", max_gid));
    max_length_pas = tointeger (SCR::Read (.etc.login_defs.PASS_MAX_LEN));
    if (nil ==  max_length_pas)
        max_length_pas = 8;
    min_length_pas = tointeger (SCR::Read (.etc.login_defs.PASS_MIN_LEN));
    if (nil ==  min_length_pas)
        min_length_pas = 5;
    pass_max_days = tointeger (SCR::Read (.etc.login_defs.PASS_MAX_DAYS));
    if (nil ==  pass_max_days)
        pass_max_days = 99999;
    pass_min_days = tointeger (SCR::Read (.etc.login_defs.PASS_MIN_DAYS));
    if (nil == pass_min_days)
        pass_min_days = 0;
    pass_warn_age = tointeger (SCR::Read (.etc.login_defs.PASS_WARN_AGE));
    if (nil == pass_warn_age)
        pass_warn_age = 7;

	encryption = md5 ? `md5 : blowfish ? `blowfish : `des;

	// set maximal password length
	if (`des != encryption)
	    max_length_pas = 128;

    encoding = Console::encoding;

	return true;
}


/**
 * Return a map with the defaults for the shadow entry
 * @return map of shadow settings
 */
global define map GetDefaultShadow()``{

	return	$[
           "expire"	: default_expire,
		   "inact"	: default_inactive,
           "last_change": "", // LastChangeIsNow() is called from dialogs
		   "max"	: sformat("%1", pass_max_days),
		   "min"	: sformat("%1", pass_min_days),
		   "warn"	: sformat("%1", pass_warn_age)
    ];
}

/**
 * Return the default home value for a new user.
 * @return string home directory
 */
global define string GetDefaultHome(boolean useUI)``{

    string def_home = useradd_defaults["home"]:"/home";

    // check for existence of prefix directory
    if (SCR::Read(.target.size, def_home ) == -1 && useUI)
    {
        if (UI::YesNoPopup(sformat (_("The default home directory \"%1\" doesn't exist.
Create it now?"), def_home)))
            SCR::Execute (.target.mkdir, def_home);
    }
    if ( (findlastof( def_home, "/") +1) != size(def_home ) )
    {
        def_home = def_home + "/";
    }
    return def_home;
}


/**
 * Return the default group id for a new user.
 * @return integer gid
 */
global define integer GetDefaultGid(boolean useUI)``{

    string def_gid  = useradd_defaults["group"]:default_gid;
    integer def_int = tointeger(def_gid);
    map group = $[];

    group = GetGroupFromAll (def_int);
    if( group == $[])
    {
        if (useUI)
	        // error popup
	        Report::Error(sformat(_("The default group with the id %1 does not exist.
Please change the default group in /etc/default/useradd."), def_int ));


	    // TODO If group 100/500 does not exists ?
	    return default_gid;
    }
    return def_int;
}

/**
 * Read the /etc/shells file and return a item list or a string shell list.
 * @param todo `items or `stringlist
 * @return list of shells
 */
global define list GetAllShells(symbol todo ) ``{

	list available_shells =  [];
	list shells_read = SCR::Read(.etc.shells);

	foreach( `shell_entry, shells_read, ``{

	    if( is( shell_entry, string ))
	    {
		    if( (! issubstring( shell_entry, "passwd")) &&
		        (! issubstring( shell_entry, "bash1")) )
		    {
		        if(  SCR::Read(.target.size, shell_entry  )  != -1  )
		        {
			        if (todo == `items) available_shells = add(available_shells,
                            `item( `id(shell_entry), shell_entry ));
			        if ( todo == `stringlist ) available_shells =
                            add( available_shells, shell_entry);
		        }
		    }

	    }
	});
	return available_shells;
}



global define list ReadUserCustomSets() ``{

    return [`local];//, `nis];
}

global define boolean WriteUserCustomSets() ``{

    return true;
}

global define list ReadGroupCustomSets() ``{

    return [`local];//, `system];//, `nis];
}

global define void BuildMenuButtonItems() ``{

    available_usersets_items = [];
    foreach (`set, available_usersets, ``{
        available_usersets_items = add ( available_usersets_items,
            `item(`id(set), userset_to_string [ set ]:""));
    });

    // build the groups MenuButton items
    available_groupsets_items = [];
    foreach (`set, available_groupsets, ``{
        available_groupsets_items = add ( available_groupsets_items,
            `item(`id(set), groupset_to_string [ set ]:""));
    });

}

/**
 * Reads the setting, used for cache
 */
global define boolean ReadUsersCache(boolean read_prebuilded) ``{

    // this is ugly!! -- move it to Consts module !!
    UsersCache::max_uid         =    max_uid;
    UsersCache::max_gid         =    max_gid;
    UsersCache::max_system_uid  =    max_system_uid;
    UsersCache::max_system_gid  =    max_system_gid;
    UsersCache::max_length_uid  =    max_length_uid;
    UsersCache::max_length_gid  =    max_length_gid;

    UsersCache::encoding        =   encoding;

    // build the users MenuButton items
    BuildMenuButtonItems ();

    current_users = eval (user_custom_sets);
    current_groups = eval (group_custom_sets);

    UsersCache::user_custom_sets = user_custom_sets;
    UsersCache::group_custom_sets = group_custom_sets;

    // use the pre-builded structures also for cache
    if (read_prebuilded)
        UsersCache::ReadFromFiles (tmpdir);
    else
        UsersCache::Read (users, groups, current_users, current_groups, "");

}

global define map GetUserByName ( string name )``{
    map ret = $[];
    integer uid = -1;
    foreach (`type, `usernames, users_by_name, ``{
        if (ret == $[])
        {
            uid = usernames [name]:-1;
            if (uid != -1)
                ret = users [type, uid]:$[];
        }
    });
    return ret;
}

/**
 * Finds the user specified by uid and set is as current
 * @param uid the user id
 */
global define void SelectUser( integer uid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_users) )
    {
        ret = users[ current_users [i]:nil, uid ]:$[];
        if (ret != $[])
        {
            y2debug("selected user: %1", ret);
            break;
        }
        i = i + 1;
    }
    user_in_work = ret;
}

/**
 * Finds the group specified by gid and set is as current
 * @param gid the group id
 */
global define void SelectGroup( integer gid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_groups) )
    {
        ret = groups [ current_groups [i]:nil, gid ]:$[];
        if (ret != $[])
        {
            y2debug("selected group: %1", ret);
            break;
        }
        i = i + 1;
    }
	group_in_work = ret;
}

/**
 * Return the settings for a group.
 * @param gid the group id
 * @return map of group
 */
global define map GetGroupFromAll( integer gid )``{

    map group = $[];
    foreach (`grouptype, `groupset, groups, ``{
        if (group == $[])
            group = groupset [gid]:$[];
    });
	return group;
}

/**
 * This define returns the groups of a user.
 * @param username the name of the user
 * @return string group comma separated list
 */
global define string FindGroupsBelongUser( string username ) ``{

    string grouplist = "";
    foreach (`type, `groupset, groups, ``{
        foreach (`gid, `group, groupset, ``{
            list userlist = splitstring (group["userlist"]:"", ",");
            if (contains (userlist, username))
            {
                if (grouplist == "")
                    grouplist = group["groupname"]:"";
                else
                    grouplist = grouplist + "," + group["groupname"]:"";
            }
        });
    });
    return grouplist;
}

/*
 */
global define boolean HomeExists(string home) ``{

    return UsersCache::HomeExists(home);
}

/*
 */
global define boolean UIDExists(integer uid) ``{

    return UsersCache::UIDExists(uid);
}

/*
 */
global define boolean UsernameExists(string username) ``{

    return UsersCache::UsernameExists(username);
}

/**
 * Change the current users set, additional reading could be necessary
 */
global define void ChangeCurrentUsers(symbol new) ``{


    if ( new == `custom )
        current_users = eval (user_custom_sets);
    else
        current_users = [ new ];

    if (contains (current_users, `ldap) && ldap_not_read)
    {
        // first: check for required packages:
        if (SCR::Execute(.target.bash, "rpm -q perl-ldap cpu") !=0)
        {
            // Popup text (required application):
            if (UI::YesNoPopup(_("For managing LDAP users, the packages
\"perl-ldap\" and \"cpu\" are necessary.
Do you want to install them now?")))
            {
                include "require.ycp"; // is it possible to have it here??
                DoInstallAndRemove(["perl-ldap", "cpu"], []);
            }
            // perl-ldap is necessary for reading
            if (SCR::Execute(.target.bash, "rpm -q perl-ldap") !=0)
                return;
        }
        ldap_not_read = false;
        // run preparation script:
        if (!RunPrepare (sformat("ldap %1 %2", ldap_host, ldap_base)))
        {
            // Popup text (required application):
            UI::WarningPopup(_("There was some problem with connecting to LDAP server."));
            return;
        }
        // read the LDAP users now
        users [`ldap ] = ReadLDAPUsers (tmpdir);
        users_by_name [`ldap ] = ReadLDAPUsersByName (tmpdir);
        UsersCache::BuildUsers (users [`ldap]:$[], `ldap, tmpdir);
        // also groups have to be reloaded
        CorrectGroups();
        // correct also possible change in custom itemlist
        if (new == `custom)
            UsersCache::ChangeUserCustoms (current_users);
    }
    if (contains (current_users, `nis) && nis_not_read)
    {
        nis_not_read = false;
        // first: run preparation script:
        RunPrepare ("nis");
        // read NIS users now
        users [`nis] = ReadNISUsers (tmpdir);
        users_by_name [`nis] = ReadNISUsersByName (tmpdir);
        UsersCache::BuildUsers (users [`nis]:$[], `nis, tmpdir);
        // also groups have to be reloaded
        CorrectGroups();
        // correct also possible change in custom itemlist
        if (new == `custom)
            UsersCache::ChangeUserCustoms (current_users);
    }

    UsersCache::current_users = current_users;// via some function?
}

/**
 * Update groups's more_users entries, after new read
 */
global define void CorrectGroups() ``{

    map correction = SCR::Read(.target.ycp, tmpdir + "/group_correct.ycp");
    foreach (`gid, `userslist, correction, ``{

        map corrected_group = GetGroupFromAll(gid);
        if (corrected_group == $[]) // can be e.g. for NIS groups
            return;
        // TODO here could be the conversion 100 <-> 500 done...

        if (corrected_group ["more_users"]:"" == "")
            corrected_group ["more_users"] = userslist;
        else
            corrected_group ["more_users"] = corrected_group ["more_users"]:""
                +  "," + userslist;

        groups [ corrected_group["type"]:`local, gid ] = corrected_group;

        // also the group's itemlist must be changed
        UsersCache::ChangeGroup (`itemlist, corrected_group);
    });
}

/**
 * Change the set of current groups viewed
 */
global define void ChangeCurrentGroups(symbol new) ``{

    if ( new == `custom )
        current_groups = eval (group_custom_sets);
    else
        current_groups = [ new ];
    UsersCache::current_groups = current_groups;// via some function?
}

global define void ChangeCustoms(string what, list new) ``{

    if (what == "user")
    {
        user_custom_sets = new;
        UsersCache::ChangeUserCustoms(new);
    }
    else
    {
        group_custom_sets = new;
        UsersCache::ChangeGroupCustoms(new);
    }
}

/**
 * Change the structure with default values (/etc/defaults/useradd)
 */
global define boolean SetDefaults (map new_defaults, string groupname)``{

    modified = true;

    foreach (`key, `value, new_defaults, ``{
        if (value != "")
            useradd_defaults[key] = new_defaults[key]:"";
    });
    // remove last '/' from home entry (??)
    string home = useradd_defaults["home"]:"";
    if ( (findlastof( home, "/") +1) == size(home) )
        useradd_defaults["home"] = substring (home, 0, size(home)-1);

    default_gid = tointeger(useradd_defaults["group"]:sformat("%1",default_gid));
    default_groupname = groupname;
    SetDefaultValues(false);

    return true;
}

/**
 * Sets the time of last password change
 */
global define string LastChangeIsNow () ``{
    map out = SCR::Execute(.target.bash_output, "date +%s");
    string days_s = out["stdout"]:"0\n";
    days_s = substring(days_s, 0, size(days_s)-1);
    integer days = (tointeger(days_s) + 3600)/ (60*60*24);
    return sformat("%1", days);
}

/*
 * Runs a script, preparing the data structures
 * @param type type of user/group set to load, can be "passwd", "nis", "ldap"
 */
global define boolean RunPrepare(string type) ``{

    integer ret = 1;

    if (type == "passwd")
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_passwd_structures.pl %2 %3 %4 %5 %6", Directory::bindir,
        base_dir, tmpdir, max_system_uid, max_system_gid, encoding));
    }
    else if (type == "nis")
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_nis_structures.pl %2 %3 %4", Directory::bindir,
        base_dir, tmpdir, encoding));
    }
    else if ( issubstring (type, "ldap") )// ldap has some additional parameters
    {
        ret = SCR::Execute(.target.bash, sformat(
        "%1/build_ldap_structures.pl %2 %3 %4", Directory::bindir,
        tmpdir, encoding, type));
    }
    return (ret == 0);
}

/**
 * Gets the bind password to LDAP database
 */
define string GetLDAPPassword() ``{

    UI::OpenDialog (`opt(`decorated),
        `VBox(
            `HSpacing(36),
            // password entering label
            `Password(`id(`pw), "&Enter the bind password for LDAP server:"),
            `PushButton(UI::OKButtonLabel())
            )
    );
    UI::UserInput();
    string pw = UI::QueryWidget(`id(`pw), `Value);
    UI::CloseDialog();
    return pw;
}

/**
 * The default grouplist for new user
 * @param type type of new user (`local, `system, `nis, `ldap)
 */
global define string GetDefaultGrouplist (symbol type) ``{

    // check for existence of groups !!
    if (type == `local)
        return "dialout,uucp,video,audio";
    else
        return "";
}

/**
 * Gets the source of user lists from /etc/nsswitch.conf
 */
global define list GetUsersSources() ``{

    string passwd_source = SCR::Read(.etc.nsswitch_conf.passwd);
    y2debug("read nsswitch.passwd: %1", passwd_source);

    return splitstring(passwd_source, " ");
}

/**
 * Calls the script which builds the widget contens for EditGroup dialog
 @ param userlist the list of users, having this group as additional
 @ param more_users the list of users, having this group as default group
 */
global define map BuildAdditional (string userlist, string more_users) ``{

    SCR::Write(.target.string, tmpdir + "/additional_userlist", userlist);
    SCR::Write(.target.string, tmpdir + "/additional_moreusers", more_users);
    SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
        UsersCache::usernamelists);

    if (0 != SCR::Execute(.target.bash, sformat(
        "%1/build_additional_users.pl %2", Directory::bindir, tmpdir)))
        return $[];
    else
        return $[
            `ulist: SCR::Read(.target.ycp, tmpdir + "/additional_ulist.ycp"),
            `more:  SCR::Read(.target.ycp, tmpdir + "/additional_more.ycp")
        ];
}

/**
 * Re-read the settings, when back was pushed during installation
 */
global define boolean StartAgain() ``{

    y2debug ("reload unmodified values from disk...");
    Read ( nil, false);
    return true;
}

/**
 * Remove old config options - is used from inst_root.ycp
 * @return void;
 */
global define void removeOldConf() ``{

	SCR::Write(.pam.all.password.pam_unix2, "-md5");
	SCR::Write(.pam.all.password.pam_pwcheck, "-md5");

	SCR::Write(.pam.login.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.login.password.pam_unix, "-md5");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.passwd.password.pam_unix, "-md5");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.sshd.password.pam_unix, "-md5");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.rlogin.password.pam_unix, "-md5");

	SCR::Write(.pam.all.password.pam_unix2, "-blowfish");
	SCR::Write(.pam.all.password.pam_pwcheck, "-blowfish");

	SCR::Write(.pam.login.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.login.password.pam_unix, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_unix, "-blowfish");

}

/**
 * Crypt the root password according to method defined in encryptionMethod
 * This is called during install
 * @param pw1 unencrypted password
 * @return void
 */
global define void cryptRootPassword(string pw1) ``{

	if (Mode::test) {
	    return;
	}
	if (encryptionMethod == "md5" )
	{
	    SCR::Write( .pam.all.password.pam_unix2,   "+md5" );
	    SCR::Write( .pam.all.password.pam_pwcheck, "+md5" );
	    rootPassword = cryptmd5 (pw1);
	}
	else if (encryptionMethod == "blowfish" )
	{
	    SCR::Write( .pam.all.password.pam_unix2,   "+blowfish" );
	    SCR::Write( .pam.all.password.pam_pwcheck, "+blowfish" );
	    rootPassword = cryptblowfish (pw1);
	}
	else
	{
	    rootPassword = crypt (pw1);
	}
	return;
}

/**
 * Writes password of superuser
 * @return true on success
 */
global define boolean SetRootPassword() ``{

	return (SCR::Write(.target.passwd.root, rootPassword));
}

}// EOF
