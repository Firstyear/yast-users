/**
 * File:	modules/Users.ycp
 * Package: Configuration of users and groups
 * Summary:	Main module, providing IO functions
 *
 * Authors:	Johannes Buchhold <jbuch@suse.de>,
 *          Anas Nashif (nashif@suse.de),
 *          Jiri Suchomel (jsuchome@suse.cz)
 *
 *
 * $Id$
 */
{

module "Users";

textdomain "users";

import "Mode";
import "Progress";
import "Report";
import "UsersCache";
import "MailAliases";
import "Directory";
import "Console";
import "Security";
import "Require";
import "Popup";

include "users/routines.ycp";
include "users/nis_routines.ycp";
include "users/ldap_routines.ycp";

/**
 * What module to call after auth. dialog during installation:
 * could be `users/"nis"/"nis"plus/"ldap", see inst_auth.ycp
 */
global string after_auth = "users";

/**
 * Encryption method: "des", "md5" - for future use: "blowfish"
 */
global string encryptionMethod = "des";

// The root's password
global string rootPassword = "";


// Export all settings, not only modified
global boolean ExportAll = false;


// Write only, keep progress turned off
global boolean write_only = false;

/**
 *  keys from /etc/defaults/useradd:
 **/
map useradd_defaults  = $[
    "group": "",
    "home": "",
    "inactive": "",
    "expire": "",
    "shell": "",
    "skel": "",
    "groups": "",
];

/**
 *  If user should be warned when using uppercase letters
 */
global boolean not_ask_uppercase = false;

// default values for new local/system users (shotcuts from useradd_defaults):
global string default_shell = "/bin/bash";
global string default_skel = "/etc/skel";
global integer default_gid = 100; // TODO change to 500 with new version
global string default_groupname = "users";
global string default_inactive = "-1";
global string default_expire = "";

// console encoding - needed for preparation script
string encoding = "";

/**
 * The number of days after a password expires until the account is
 * permanently disabled. A value of 0 disables the
 * account as soon as the password has expired, and a value of -1
 * disables the feature.  The default value is -1.
 */
global integer pass_inact_days = -1;


/**
 * The date on which the user account will be disabled.
 * The date is specified in the format YYYY-MM-DD.
 */
global string pass_expire_date = "";

global string valid_logname_chars  = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-_";
global string valid_password_chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#* ,.;:._-+!$%^&/|\?{[()]}=";
global string valid_home_chars     = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/_-.";
global string valid_group_chars    = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-_";
global string valid_grouplist_chars= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,-_";
global string valid_id_chars       = "0123456789";
global string invalid_gecos_chars = ",:";

global integer max_length_uid = 5;
global integer max_length_gid = 5;
/**
 * map of maximum uid values (defined for various user types)
 */
global map max_uid = $[
    "local"	: 60000,
    "system"	: 500-1,
    "ldap"	: 60000
];
global map min_uid = $[
    "local"	: 500,
    "system"	: 0,
    "ldap"	: 500
];
/**
 * map of maximum gid values (defined for various group types)
 */
global map max_gid = $[
    "local"	: 60000,
    "system"	: 100-1, // TODO change to 500 with new version
    "ldap"	: 60000
];
global map min_gid = $[
    "local"	: 100, // TODO change to 500 with new version
    "system"	: 0,
    "ldap"	: 500
];

/**
 * map of allowed password length (defined for various user types)
 */
global map pass_length = $[
    "local": $[ "max": 8, "min":5 ],
    "ldap" : $[ "max": 8, "min":5 ],
];

// Maximum number of days a password may be used:
global integer pass_max_days = 99999;
// Minimum number of days allowed between password changes:
global integer pass_min_days = 0;
// Number of days warning given before a password expires:
global integer pass_warn_age = 7;

global string default_pw     = "******";

/**
 * if password should be checked against crack
 */
global boolean use_cracklib = false;
/**
 * default path to password cracking dictionary
 */
global string cracklib_dictpath = "/usr/lib/cracklib_dict";

/**
 * if password should be checked
 */
global boolean obscure_checks = false;

global string root_mail = "";

// autologin without showing kdm (value is username)
global string autologin = "";
global boolean autologin_used = true;
global boolean autologin_available = true;

// list of user sources - passwd entry from /etc/nsswitch.conf
list user_sources = [];

/**
 * The main map of users
 * example:
 * users = $[
 *  "local":$[
 *	500 :$[
 *	    "fullname":"Hans H", "gid":100, "home":"/local/hh",
 *	    "password":"x","shell":"/bin/bash",
 *	    "uid":500, "username":"hh",
 *	    "shadow":$[
 *		"expire":0, "inact":-1, "last_change":11984, "max":99999,
 *		"min":0, "warn":7
 *	    ]
 *	 ],
 *	 501 : ...
 *    ]]
 */
global map users = $[
    "system":    $[],
    "local":     $[],
    "ldap":      $[]];

/**
 * The main map of groups
 */
global map groups  = $[
    "system":    $[],
    "local":     $[],
    "ldap":      $[]];

// main maps of all local shadow and gshadow entries:
global map shadow = $[
    "system":    $[],
    "local":     $[],
    "ldap":      $[]];

map gshadow = $[
    "system":    $[],
    "local":     $[],
    "ldap":      $[]];

/**
 * structures *_by_name are used for searching
 */
global map users_by_name = $[];

/**
 * structures *_by_name are used for searching
 */
global map groups_by_name = $[];

/**
 * map of current user
 */
global map user_in_work = $[];

/**
 * map of current group
 */
global map group_in_work = $[];

/**
 * the first user, added during install
 */
global map saved_user = $[];

/**
 * users, which has been deleted/modified:
 */
map modified_users = $[];
map modified_groups = $[];

/**
 * users sets in "Custom" selection:
 */
global list user_custom_sets = [ "local" ];
global list group_custom_sets = [ "local" ];

/**
 * which sets of users are we working with:
 */
global list current_users = [];
global list current_groups = [];

// variables desctibing available users sets:
global boolean is_nis_available = false;
global boolean is_nis_master = false;
global boolean is_ldap_available = false;
global boolean is_ldap_server = false; // currently not used
// if ldap home directiories are on this machine
global boolean ldap_file_server = false;
global string ldap_encryption = "crypt";

/**
 * nis users are not read by default, but could be read on demand:
 */
boolean nis_not_read = true;

/**
 * ldap users are not read by default, but could be read on demand:
 */
global boolean ldap_not_read = true;

/**
 * which sets of users are available to work with:
 */
global list available_usersets = [ "system", "local"];
global list available_usersets_items = [];
global list available_groupsets = [ "system", "local"];
global list available_groupsets_items = [];

/**
 * where the user/group/password data are stored
 *  (can be different on NIS server)
 */
global string base_dir = "/etc";

/**
 * list of available shells (read in GetAllShells)
 */
global list all_shells = [];
global list all_shells_items = [];

// the +/- entries in config files:
global string plus_passwd = "";
global string plus_group = "";
global string plus_shadow = "";
global string plus_gshadow = "";

global string ldap_user_base = "";
global string ldap_group_base = "";
// default filters (read from Ldap module):
global string ldap_default_user_filter = "objectClass=posixAccount";
global string ldap_default_group_filter = "objectClass=posixGroup";
// current filters (must be empty on start):
global string ldap_user_filter = "";
global string ldap_group_filter = "";

// config maps (stored on LDAP server)
global map ldap_user_config = $[];
global map ldap_group_config = $[];
global map ldap_user_template = $[];
global map ldap_group_template = $[];
global map ldap_user_defaults = $[];
global map ldap_group_defaults = $[];

global string ldap_user_config_dn = "";
global string ldap_group_config_dn = "";

// filters could be read alone
global boolean ldap_filters_read = false;
global boolean ldap_initialized = false;

// default shadow settings for LDAP users
global map ldap_shadow = $[];
// other default settings (home, shell, etc.) for LDAP users
global map ldap_defaults = $[];

global string ldap_default_groupname = "";
global string ldap_default_grouplist = "";

// default object classes of LDAP users (read from Ldap module)
global list ldap_user_class = ["top","posixAccount","shadowAccount",
    "inetOrgPerson"];
// default object classes of LDAP groups (read from Ldap module)
global list ldap_group_class = [ "top", "posixGroup", "groupOfUniqueNames"];

global string ldap_user_naming_attr = "uid";
global string ldap_group_naming_attr = "cn";
// last uid/gid used
global integer ldap_last_uid = 0;
global integer ldap_last_gid = 0;

string tmpdir = "/tmp"; // do not write to /tmp only!

// starting dialog for installation mode
global string start_dialog = "users";
global boolean use_next_time = false;

// if anything was done
global boolean users_modified = false;
global boolean groups_modified = false;
global boolean customs_modified = false;
global boolean defaults_modified = false;
global boolean ldap_modified = false;
global boolean security_modified = false;

// home directories to delete
global list removed_homes = [];

// values to MenuItem in Summary dialog
global map userset_to_string = $[
    // the type of user set
    "system":    _("&System Users"),
    // the type of user set
    "local":     _("&Local Users"),
    // the type of user set
    "nis":       _("&NIS Users"),
    // the type of user set
    "ldap":      _("L&DAP Users"),
    // the type of user set
    "samba":     _("Sam&ba Users"),
    // the type of user set
    "custom":    _("&Custom")
];

// values to MenuItem in Summary dialog
global map groupset_to_string = $[
    // the type of group set
    "system":    _("&System Groups"),
    // the type of group set
    "local":     _("&Local Groups"),
    // the type of group set
    "nis":       _("&NIS Groups"),
    // the type of group set
    "ldap":      _("L&DAP Groups"),
    // the type of group set
    "samba":     _("Sam&ba Groups"),
    // the type of group set
    "custom":    _("&Custom")
];

// keys in user's map which are not saved anywhere (internal use only :-))
global list user_internal_keys = [ "create_home", "grouplist","groupname",
    "modified", "org_username", "org_uid", "org_home","org_user", "type",
    "org_groupname", "what", "dn", "org_dn", "removed_grouplist", "delete_home"
];

global list group_internal_keys = [ "modified", "type", "what", "more_users",
    "dn", "org_dn", "org_groupname", "org_gid", "removed_userlist" ];

// conversion table of parameter names used in yast (passwd-style) and
// in LDAP schema
global map ldap_attrs_conversion = $[
    // user:
    "username":		"uid",
    "uid":		"uidNumber",
    "gid":		"gidNumber",
    "home":		"homeDirectory",
    "fullname":		"cn",
    "password":		"userPassword",
    "shell":		"loginShell",
    // shadow settings:
    "last_change":	"shadowLastChange",
    "warn":		"shadowWarning",
    "inact":		"shadowInactive",
    "expire":		"shadowExpire",
    "min":		"shadowMin",
    "max":		"shadowMax",
    // group:
//    "userlist":		"memberUid",
    "userlist":		"uniqueMember",
    "groupname":	"cn"
];

// conversion table from parameter names used in LDAP to ones used in
// yast (passwd-style)
global map ldap2yast_user_attrs = $[
    "uid":		"username",
    "uidNumber":	"uid",
    "cn":		"fullname",
    "homeDirectory":	"home",
    "loginShell":	"shell",
    "gidNumber":	"gid",
    "userPassword":	"password",
];
global map ldap2yast_group_attrs = $[
    "gidNumber":	"gid",
    "userPassword":	"password",
    "cn":		"groupname",
    "uniqueMember":	"userlist"
];




/**
 * Read all the settings
 * @param abort the abort block
 * @param useUI boolean use user interface (change progress bar)
 * @return symbol `next if success, else `abort
 */
global define symbol Read (block abort, boolean useUI) ``{

    // progress caption
    string caption = _("Initializing user and group configuration");
    integer no_of_steps = 9;

    // We do not set help text here, because it was set outside
    if( useUI )
	Progress::New (caption, " ", no_of_steps,
			// progress stage label
		       [ _("Read the default login settings"),
			// progress stage label
			 _("Read the default system settings"),
			// progress stage label
			 _("Read the configuration type"),
			// progress stage label
			 _("Build the data structures"),
			// progress stage label
			 _("Read the password settings"),
			// progress stage label
			 _("Read the group settings"),
			// progress stage label
			 _("Read the user settings"),
			// progress stage label
			 _("Read the custom settings"),
			// progress stage label
			 _("Build the cache structures")
           ],
			// progress step label
		       [ _("Reading the default login settings..."),
			// progress step label
			 _("Reading the default system setttings..."),
			// progress step label
			 _("Reading the configuration type..."),
			// progress step label
			 _("Building the data structures..."),
			// progress step label
			 _("Reading the password settings..."),
			// progress step label
			 _("Reading the group settings..."),
			// progress step label
			 _("Reading the user settings..."),
			// progress step label
			 _("Reading the custom settings..."),
			// progress step label
			 _("Building the cache structures..."),
			// final progress step label
			 _("Finished") ],
			    "" );

    // read default login settings
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    if ( ! ReadLoginDefaults(useUI) )
    {
	// warning popup
	Report::Warning (_("Cannot read the default login settings."));
    }

    if ( !CheckHomeMounted())
    {
        if (Mode::cont)
            return `nextmodule; // what to return during install ??
        else
            return `back;
    }

    // read default system settings
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    if ( ! ReadSystemDefaults() )
    {
	// error popup
	Report::Error (_("Cannot read the default systems settings."));
    }

    // read configuration type
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    ReadSourcesSettings();

    if ( is_nis_master && useUI)
    {
        string dir = ReadNISConfigurationType (base_dir);
        if (dir == nil)
	{
	    if (Mode::cont)
		return `nextmodule; // what to return during install ??
	    else
		return `abort; // aborted in NIS server dialog
	}
        else
            base_dir = dir;
    }

    // run script for pre-building structures
    if( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    tmpdir = SCR::Read(.target.tmpdir);

    map prepare = RunPrepare("passwd");
    if ( prepare["exit"]:0 != 0 )
    {
        Report::Error (GetErrorMessage(prepare));
        if (Mode::cont)
            return `nextmodule; // what to return during install ??
	else
	    return `abort;
    }

    // read password settings
    if( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    gshadow = ReadGshadow(tmpdir);
    shadow = ReadShadow (tmpdir);

    plus_shadow = ReadPlusShadow(tmpdir);
    plus_gshadow = ReadPlusGshadow(tmpdir);

    if ( (gshadow == nil) || (shadow == nil) )
    {
	// error popup
	Report::Error (_("Cannot read the password settings."));
        if (Mode::cont)
            return `nextmodule; // what to return during install ??
	else
	    return `abort;
    }

    // read group settings
    if( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    groups = ReadGroups(tmpdir);
    groups_by_name = ReadGroupsByName(tmpdir);
    plus_group = ReadPlusGroup(tmpdir);

    if ( groups ["local"]:nil == nil )
    {
	// error popup (settings of local groups)
	Report::Error (_("Cannot read the local group settings."));
        groups ["local"] = $[];
    }
    if ( groups ["system"]:nil == nil)
    {
	// error popup (settings of system groups)
	Report::Error (_("Cannot read the system group settings."));
        groups ["system"] = $[];
    }

    // read user settings
    if( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }

    users = ReadPasswd (tmpdir);
    plus_passwd = ReadPlusPasswd (tmpdir);
    users_by_name = ReadPasswdByName (tmpdir);

    if (users ["local"]:nil == nil )
    {
	// error popup
	Report::Error (_("Cannot read the local user settings."));
        users ["local"] = $[];
    }
    if ( users ["system"]:nil == nil )
    {
	// error popup
	Report::Error (_("Cannot read the system user settings."));
        users ["system"] = $[];
    }

    // read customs
    if( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }
    ReadCustomSets();

    // There is no progress for this !!!
    ReadAllShells();
    ReadDefaultGroup(useUI);

    // build the cache
    if( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	{
	    return `abort;
	}
    }
    ReadUsersCache(true);

    // increase the progress to "finish"
    if( useUI ) Progress::NextStage ();

    // check for KDM (needed for autologin)
    if (SCR::Read (.sysconfig.displaymanager.DISPLAYMANAGER) != "kdm" ||
	!Require::IsAnyPackageInstalled (["kdebase3-kdm"]))
    {
	autologin_available = false;
	autologin_used = false;
    }
    if (!Mode::cont && autologin_used)
    {
	string auto_user = SCR::Read (.sysconfig.displaymanager.DISPLAYMANAGER_AUTOLOGIN);
	if (auto_user == nil || auto_user == "")
	    autologin_used = false;
    }

    return `next;
}

/**
 * Saves users into the system
 * @param abort abort block
 * @param useUI if user interface (progress bar and popups) should be used
 * @return symbol `next for success, `abort otherwise
 */
global define symbol Write (block abort, boolean useUI)``{

    string write_dir = base_dir;//"/tmp"; // tmp is just for testing

    // progress caption
    string caption = _("Writing user and group configuration...");
    integer no_of_steps = 8;

    // We do not set help text here, because it was set outside
    if( useUI )
	    Progress::New (caption, " ", no_of_steps, [
		// progress stage label
		_("Back up the configuration files"),
		// progress stage label
		_("Write groups"),
		// progress stage label
		_("Check for deleted users"),
		// progress stage label
		_("Write users"),
		// progress stage label
		_("Write passwords"),
		// progress stage label
		_("Write LDAP users and groups"),
		// progress stage label
		_("Write the custom settings"),
		// progress stage label
		_("Write the default login settings")
           ], [
		// progress step label
		_("Creating backup of configuration files..."),
		// progress step label
		_("Writing groups..."),
		// progress step label
		_("Checking deleted users..."),
		// progress step label
		_("Writing users..."),
		// progress step label
		_("Writing passwords..."),
		// progress step label
		_("Writing LDAP users and groups..."),
		// progress step label
		_("Writing the custom settings..."),
		// progress step label
		_("Writing the default login settings..."),
		// final progress step label
		_("Finished") ],
	    "" );
// TODO: LDAP writing in separarate funcitons before Write
// (so we can return back when anything fails...)

    // backup
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }
    if (users_modified || groups_modified)
        BackupConfFiles(base_dir); // should be removed at the end?

    // write group before passwd! (bug #24130)
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }
    if (groups_modified)
    {
        if (! WriteGroup (write_dir, groups ["system"]:$[], groups["local"]:$[],
             plus_group))
        {
            if (useUI)
                // error popup
                Report::Error (_("Cannot write group file."));
            else
                y2error("Cannot write group file.");
        }
        // remove the group cache for nscd (bug 24748)
        SCR::Execute (.target.bash_output, "/usr/sbin/nscd -i group");
    }

    // check for deleted users (-> remove homes)
    if ( useUI )
    {
	Progress::NextStage ();
        if (eval (abort))
		return `abort;
    }

    DeleteHomeDirs();

    // write passwd
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }

    if (users_modified)
    {
        // add the edited or new users to modified_users
        modified_users [`passwd] = WritePasswd (write_dir, users ["system"]:$[],
            users["local"]:$[], plus_passwd);
        // remove the passwd cache for nscd (bug 24748)
        SCR::Execute (.target.bash, "/usr/sbin/nscd -i passwd");
    }

    if (modified_users [`passwd]:$[] == nil)
    {
        if (useUI)
            // error popup
	    Report::Error (_("Cannot write passwd file."));
        else
            y2error ("Cannot write passwd file.");
        modified_users [`passwd] = $[];
    }

    // check for homedir changes
    foreach (`uid, `user, modified_users [`passwd]:$[], ``{
        string home = user["home"]:"";
        string username = user["username"]:"";
        string command = "";
        string user_mod = user["modified"]:"no";
        integer gid = user["gid"]:default_gid;
        if (user_mod == "imported" || user_mod == "added")
        {
            if ((user["create_home"]:true || user_mod == "imported") &&
		SCR::Read(.target.stat, home) == $[])
            {
		CreateHome (default_skel, home);
            }
	    ChownHome (uid, gid, home);
            // call the useradd.local (-- check the existence ??)
            command = sformat("/usr/sbin/useradd.local %1", username);
            y2debug("useradd.local return value: %1",
                SCR::Execute(.target.bash, command));
        }
        else // only "edited" can be here
        {
            string org_home = user["org_home"]:home;
            if (home != org_home)
            {
                if (user["create_home"]:true) // move the home directory
                {
		    MoveHome (org_home, home);
                }
            }
	    ChownHome (uid, gid, home);
        }
    });
    // shadow, gshadow
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }

    if (users_modified)
    {
        // TODO use structure and decide in the write function
        if (! WriteShadow(write_dir, shadow["system"]:$[], shadow["local"]:$[],
                plus_shadow))
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write shadow file."));
            else
                y2error ("Cannot write shadow file.");
        }
    }
    if (groups_modified)
    {
        if (!WriteGshadow(write_dir, gshadow["system"]:$[], gshadow["local"]:[],
                plus_gshadow))
        {
            if (useUI)
                // error popup
	            Report::Error (_("Cannot write gshadow file."));
            else
                y2error ("Cannot write gshadow file.");
        }
    }

    // call make on NIS server
    if ((users_modified || groups_modified) && is_nis_master)
    {
        map ret = SCR::Execute(.target.bash_output, "/usr/bin/make -C /var/yp");
        if (ret["exit"]:1 != 0)
        {
            if (useUI)
                // error popup
	        Report::Error (_("Cannot make NIS database."));
            else
                y2error("Cannot make NIS database: %1", ret);
        }
    }

    // ldap users and groups
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }

    if (ldap_modified)
    {
	map error = $[];

        if ((Ldap::anonymous || Ldap::bind_pass == nil) && useUI)
	{
	    Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
        }

        // nil means "canceled"
        if (Ldap::bind_pass != nil)
        {
	    // 1st: delete users in modified_users ["ldap"]
	    do
	    {
		if (size (modified_users ["ldap"]:$[]) > 0)
		{
		    error = WriteLDAPUsers (modified_users ["ldap"]:$[],
			ldap_file_server);
		    if (error != $[] && useUI)
		    {
			Ldap::LDAPErrorMessage ("users", error["msg"]:"");
			if (error["code"]:0 == 8)
			{
			    Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
			}
		    }
		}
	    }
	    // when anonymous is set, bind is OK, but writing not
	    // error LDAP_STRONG_AUTH_REQUIRED is returned after LDAP command
	    while (error["code"]:0 == 8 && Ldap::bind_pass!=nil && useUI);

            // 2nd: now write all other user modifications (add/edit)
	    do
	    {
		error = WriteLDAPUsers ( users ["ldap"]:$[], ldap_file_server);
		if (error != $[] && useUI)
		{
		    Ldap::LDAPErrorMessage ("users", error["msg"]:"");
		    if (error["code"]:0 == 8)
		    {
			Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
		    }
		}
	    }
	    while (error["code"]:0 == 8 && Ldap::bind_pass!=nil && useUI);

            // 3rd: there are deleted groups in modified_groups ["ldap"]
	    do
	    {
		if (size (modified_groups ["ldap"]:$[]) > 0)
		{
		    error = WriteLDAPGroups (modified_groups ["ldap"]:$[]);
		    if (error != $[] && useUI)
		    {
			Ldap::LDAPErrorMessage ("users", error["msg"]:"");
			if (error["code"]:0 == 8)
			{
			    Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
			}
		    }
		}
	    }
	    while (error["code"]:0 == 8 && Ldap::bind_pass!=nil && useUI);

	    // 4th: now write all other groups modifications
	    do
	    {
		error = WriteLDAPGroups (groups ["ldap"]:$[]);
		if (error != $[] && useUI)
		{
		    Ldap::LDAPErrorMessage ("users", error["msg"]:"");
		    if (error["code"]:0 == 8)
		    {
			Ldap::bind_pass = Ldap::LDAPAskAndBind(true);
		    }
		}
	    }
	    while (error["code"]:0 == 8 && Ldap::bind_pass!=nil && useUI);
	}
    }

    // customs
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }
    if (customs_modified)
        WriteCustomSets();

    // useradd defaults
    if ( useUI )
    {
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;
    }
    if (defaults_modified)
        WriteLoginDefaults();

    if (security_modified)
	WriteSecurity();// TODO: add progress?

    if (Mode::cont)
    {
	// mail forward from root
        if (root_mail != "" && !MailAliases::SetRootAlias (root_mail))
            // error popup
            Report::Error(_("There was an error while setting forwarding for root's mail."));

	if (autologin_available)
	{
	    if (autologin != "" &&
		(is_nis_available || is_ldap_available ||
		size (UsersCache::usernamelists["local"]:[]) != 1))
	    {
		autologin = "";
	    }

	    // write autologin information
	    SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER_AUTOLOGIN,
		autologin);
	    SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER_PASSWORD_LESS_LOGIN,
		autologin == "" ? "no" : "yes");
	    // flush changes (#30124)
	    SCR::Write(.sysconfig.displaymanager, nil);
	}
    }
    else // not installation
    {
	// FIXME this should be handled with some warning popup...
	if (autologin_available && autologin_used)
	{
	    // disable autologin when there are more users (bug #31141)
	    if (is_nis_available || is_ldap_available ||
		size (UsersCache::usernamelists["local"]:[]) != 1)

	    SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER_AUTOLOGIN, "");
	    SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER_PASSWORD_LESS_LOGIN, "no");
	    SCR::Write(.sysconfig.displaymanager, nil);
	    // run suseconfig
	    SCR::Execute (.target.bash, "/sbin/SuSEconfig --module kdm3");
	}
    }

    // increase the progress to "finish"
    if( useUI ) Progress::NextStage ();

    // do not show user in first dialog when all has been writen
    if (Mode::cont)
    {
        use_next_time = false;
        saved_user = $[];
        user_in_work = $[];
    }

    return `next;
}


/**
 * Summary for autoinstalation
 * @return summary of the current configuration
 */
global define string Summary() ``{

    string ret = "";

    // show only modified system and all local ones
    ret = ret + "<h3>Users</h3>";
    foreach (`type, ["local", "system"], ``{
        foreach (`uid, `user, users [type]:$[], ``{
            if (user ["modified"]:"no" != "no")
                ret = ret + sformat(" %1 %2 %3<br>", uid, user["username"]:"",
                    user["fullname"]:"" );
        });
    });
    ret = ret + "<h3>Groups</h3>";
    foreach (`type, ["local", "system"], ``{
        foreach (`gid, `group, groups [type]:$[], ``{
            if (group ["modified"]:"no" != "no")
                ret = ret + sformat(" %1 %2<br>", gid, group["groupname"]:"");
        });
    });

    return ret;
}


/**
 * Converts autoyast's user's map for users module usage
 * @param user map with user data provided by users_auto client
 * @return map with user data as defined in Users module
 */
define map ImportUser (map user) ``{

    y2debug("Importing User=%1", user);
    map currentUser = eval(user);
    string forename = currentUser["forename"]:"";
    string surname = currentUser["surname"]:"";
    string fullname = currentUser["fullname"]:"";
    string username = currentUser["username"]:"";
    y2debug("Username=%1", username);

    integer uid = currentUser["uid"]:-1 ;

    if (fullname == "")
    {
	if( forename != "" )
	{
	    if( surname != "") fullname = forename + " " + surname;
	    else fullname = forename;
	}
	else fullname = surname;
    }

    string type = "local";
    if ((uid <= max_uid ["system"]:500 || username == "nobody") && uid != -1)
        type = "system";

    // if empty, set to default, might be changed later..
    map user_shadow = user ["password_settings"]:GetDefaultShadow(type);

    string pass = user ["user_password"]:"x";

    if (!currentUser["encrypted"]:true  && pass != "x" && !Mode::config)
    {
	// encrypt password for shadow
	if (encryptionMethod == "md5")
	    pass = cryptmd5 (pass);
	else if (encryptionMethod == "blowfish")
	    pass = cryptblowfish (pass);
	else
	    pass = crypt (pass);
    }

    user_shadow = add (user_shadow, "password", pass);

    if (uid == -1)
    {
	// check for existence of user -> change it
	map existing = GetUserByName (username);
	if (existing != $[])
	{
	    y2milestone("Exisitng user=%1", existing);
	    type = existing ["type"]:"system"; // these should be system
	    // change only imported values...
	    if (!haskey (user,"password_settings"))
	    {
		user_shadow = shadow [type, username]:$[];
		// real password is in shadow
		user_shadow["password"] =
		( pass != "x") ? pass : shadow[type,username,"password"]:"x";
	    }
	    string finalpw = "";
	    if (pass != "x")
		finalpw = pass;
	    else
		finalpw = existing["password"]:"x";

	    if (!haskey (user,"forename") && !haskey (user, "surname") &&
		fullname == "")
		fullname = existing["fullname"]:"";

	    map ret = $[
		"encrypted":    user ["encrypted"]:existing["encrypted"]:true,
		"password":     finalpw,
		"username":     username,
//		"forename":     currentUser["forename"]:existing["forename"]:"",
//		"surname":      currentUser["surname"]:existing["surname"]:"",
		"fullname":     fullname,
		"shell": currentUser ["shell"]:existing["shell"]:default_shell,
		"uid":          existing["uid"]:-1,
		"gid":          currentUser ["gid"]:existing["gid"]:default_gid,
		"grouplist":    currentUser ["grouplist"]:"",
		"home":         currentUser ["home"]:existing["home"]:"",
		"type":         type,
		"modified":     "imported",
		"shadow":       user_shadow
	    ];
	    return ret;
	}
    }
    string home = GetDefaultHome (false, type) + username;
    return $[
        "encrypted":        user ["encrypted"]:true,
        //can be distinct (uncrypted) from pass (which is always crypted)
        "password":         pass,
        "username":         username,
//        "forename":         forename,
//        "surname":          surname,
        "fullname":         fullname,
        "shell":            currentUser ["shell"]:default_shell,
        "uid":              uid,
        "gid":              currentUser ["gid"]:default_gid,
        "grouplist":        currentUser ["grouplist"]:"",
        "home":             currentUser ["home"]:home,
        "type":             type,
        "modified":         "imported",
        "shadow":           user_shadow
    ];
};

/**
 * Converts autoyast's group's map for groups module usage
 * @param group map with group data provided by users_auto client
 * @return map with group data as defined in Users module
 */
define map ImportGroup (map group) ``{

    string groupname = group["groupname"]:"";
    string type = "local";
    if ((group["gid"]:-1 <= max_gid ["system"]:100 ||
        groupname == "nobody" ||
        groupname == "nogroup") &&
        groupname != "users")

        type = "system";
    return $[
        "password":         group ["group_password"]:"x",
        "groupname":        groupname,
        "gid":              group ["gid"]:-1,
        "userlist":         group ["userlist"]:"",
        "modified":         "imported",
        "type":             type
    ];
};

/**
 * Get all the user configuration from the list of maps.
 * Is called users_auto (preparing autoinstallation data).
 * @param settings	A map with keys: "users", "groups", "user_defaults"
 * and values to be added to the system.
 * @return true
 */
global define boolean Import (map settings) ``{

    y2debug("importing: %1", settings);

    if (settings["user_defaults"]:$[] == $[])
        ReadLoginDefaults(false);
    else
    {
        useradd_defaults = settings["user_defaults"]:$[];
        defaults_modified = true;
    }

    ReadSystemDefaults();
    tmpdir = SCR::Read(.target.tmpdir);
    RunPrepare("passwd");

    // --- get shadow
    map all_shadow = ReadShadow (tmpdir);
    shadow ["system"] = all_shadow["system"]:$[];
    shadow ["local"] = $[];

    plus_shadow = ReadPlusShadow(tmpdir);

    // --- get users
    map passwd_users = ReadPasswd (tmpdir);

    // system users must be read every time and compared with imported ones
    users ["system"] = passwd_users ["system"]:$[];
    users ["local"] = $[];

    users_by_name ["system"] = UsersByName (users["system"]:$[]);
    users_by_name ["local"] = $[];

    if (settings["users"]:[] != [])
        users_modified = true;
    if (settings["groups"]:[] != [])
        groups_modified = true;

    // Problem: what if UID is not provided?
    list without_uid = [];

    foreach (`imp_user, settings["users"]:[], ``{
        map user = ImportUser (imp_user);
        string type = user ["type"]:"local";
        integer uid = user ["uid"]:-1;
        string username = user["username"]:"";
        if (uid == -1)
            without_uid = add (without_uid, user);
        else
        {
            users [type] = add (users[type]:$[], uid, user);
            users_by_name [type] = add (users_by_name[type]:$[], username,uid);
            // TODO: what if uid was changed??

            // update shadow
            shadow[type] = add (shadow[type]:$[], username, user["shadow"]:$[]);
        }
    });

    // these are _ugly hacks_ to import users without UIDs...
    if (size (without_uid) > 0)
    {
        list uids = UsersCache::BuildUIDList (users["local"]:$[]);
        integer last = uids [ size(uids)-1 ]:max_uid ["system"]:500;
        foreach (`user, without_uid, ``{
            // new local user -> generate new uid (use Commit?)
            integer uid = last + 1;
            while (contains (uids, uid))
                uid = uid + 1;
            uids = add (uids, uid); last = uid;
            user ["type"] = "local";
            user ["uid"] = uid;
            users ["local"] = add (users["local"]:$[], uid, user);
            users_by_name ["local"] = add (users_by_name["local"]:$[],
                user["username"]:"", uid);
	    shadow["local"] = add (shadow["local"]:$[], user["username"]:"", user["shadow"]:$[]);
        });
    }

    plus_passwd = ReadPlusPasswd (tmpdir);// TODO use this for autoinstall??

    // --- get gshadow
    map all_gshadow = ReadGshadow (tmpdir);
    gshadow ["system"] = all_gshadow["system"]:$[];
    gshadow ["local"] = $[];

    plus_gshadow = ReadPlusGshadow(tmpdir);

    // --- get groups
    map all_groups = ReadGroups (tmpdir);
    map system_groups = all_groups ["system"]:$[];
    // but we're not interested in local userlists...
    system_groups = RemoveDiskUsersFromGroups(system_groups);
    // group users should be "local"
    if (system_groups [100, "groupname"]:"" == "users")
        system_groups = remove (system_groups, 100);
    if (system_groups [500, "groupname"]:"" == "users")
        system_groups = remove (system_groups, 500);

    groups ["system"] = system_groups;
    groups ["local"] = $[];

    foreach (`imp_group, settings["groups"]:[], ``{
        map group = ImportGroup (imp_group);
        string type = group ["type"]:"local";
        string groupname = group ["groupname"]:"";
        groups [type] = add (groups[type]:$[], group["gid"]:-1, group);
        // TODO: what if gid was changed??

        // update gshadow
        map gshadow_entry = gshadow [type, groupname]:$[];
        if (gshadow_entry == $[])
        {
            gshadow_entry = $["password":"*", "disposer":"root", "userlist":""];
        }
        gshadow_entry ["userlist"] = group["userlist"]:"";
        string pass = group["password"]:"x";
        if ( pass != "x" && pass != "*" && pass != "!" )
            gshadow_entry ["password"] = pass;

        gshadow [type] = add (gshadow[type]:$[], group ["groupname"]:"",
            gshadow_entry);
    });

    if (groups["local", 100, "groupname"]:"" != "users" &&
        groups["local", 500, "groupname"]:"" != "users")
    {
        // group users must be created
        map group = $[
             "gid": default_gid, "groupname": "users",
             "password": "x", "userlist": ""];
        groups ["local"] = add (groups ["local"]:$[], default_gid, group);
        gshadow ["local"] = add (gshadow ["local"]:$[], "users",
            $[ "password": "*", "disposer": "root", "userlist": ""]);
    }

    groups_by_name ["system"] = GroupsByName (groups ["system"]:$[]);
    groups_by_name ["local"] = GroupsByName (groups ["local"]:$[]);

    plus_group = ReadPlusGroup(tmpdir);

    available_usersets = ["local", "system"];
    available_groupsets = ["local", "system"];

    ReadAllShells();
    ReadDefaultGroup(false);

    // create more_users (for groups), grouplist and groupname (for users)
    foreach (`type, ["system", "local"], ``{

        foreach (`uid, `user, users [type]:$[], ``{
            string username = user["username"]:":";
            user ["grouplist"] = FindGroupsBelongUser (username, "");
            integer gid = user["gid"]:default_gid;

            // hack: change of default group's gid
	    // (example: user games has gid 100, but there is only group 500!)
            map group = GetGroupFromAll (gid);
	    if (group == $[])
	    {
		if (gid == 100)		gid = 500;
		else if (gid == 500)	gid = 100;
		// one more chance...
		group = GetGroupFromAll (gid);
		// adapt user's gid to new one:
		if (group != $[])
		    user ["gid"] = gid;
	    }
            user ["groupname"] = group ["groupname"]:default_groupname;
            users [type, uid] = user;

            // update the group's more_users
            string more_users = group ["more_users"]:"";
            list more_list = splitstring (more_users, ",");
            if (!contains (more_list, username) && group != $[])
            {
                if (more_users != "") more_users = more_users + ",";
                group ["more_users"] = more_users + username;
                groups [ group["type"]:"local", gid] = group;
            }
        });
    });

    ReadUsersCache(false);
    return true;
}

/**
 * Converts user's map for autoyast usage
 * @param user map with user data as defined in Users module
 * @return map with user data in format used by autoyast
 */
define map ExportUser (map user) ``{

    string type = user["type"]:"local";
    string full = user["fullname"]:"";
    string username = user["username"]:"";
    map user_shadow = user ["shadow"]:shadow[type, username]:$[];
    string pass = user_shadow["password"]:user ["password"]:"x";
    if (user_shadow != $[])
        user_shadow = remove (user_shadow, "password");

    return $[
        "encrypted":        user ["encrypted"]:true,
        "user_password":    pass,
        "username":         username,
	// TODO: are fore/surname needed for autoast? -> ask Anas
        "forename":         SplitFullName (`givenName, full),
        "surname":          SplitFullName (`sn, full),
	"fullname":		full,
        "shell":            user ["shell"]:default_shell,
        "uid":              user ["uid"]:-1,
        "gid":              user ["gid"]:default_gid,
        "grouplist":        user ["grouplist"]:"",
        "home":             user ["home"]:"",
        "password_settings":user_shadow
    ];

};

/**
 * Converts group's map for autoyast usage
 * @param group map with group data as defined in Users module
 * @return map with group data in format used by autoyast
 */
define map ExportGroup (map group) ``{

    return $[
        "group_password":   group ["password"]:"x",
        "groupname":        group ["groupname"]:"",
        "gid":              group ["gid"]:-1,
        "userlist":         group ["userlist"]:""
    ];
};


/**
 * Dump the users settings to list of maps
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export() ``{

    // all local users:
    list exported_users = [];
    // local users when modified
    foreach (`uid, `user, users["local"]:$[], ``{

        if (user ["modified"]:"no" != "no" || ExportAll)
        {
            exported_users = add (exported_users, ExportUser(user));
        }
    });
    /* deleted system users (??):
    foreach (`uid, `user, modified_users["system"]:$[], ``{
        exported_users = add (exported_users, ExportUser(user));
    });*/

    // modified system users:
    foreach (`uid, `user, users["system"]:$[], ``{

        if (user["modified"]:"no" != "no" || ExportAll)
        {
            exported_users = add (exported_users, ExportUser(user));
        }
    });

    list exported_groups = [];
    // modified local system groups:
    foreach (`uid, `group, groups["local"]:$[], ``{

        if (group ["modified"]:"no" != "no" || ExportAll)
        {
            exported_groups = add (exported_groups, ExportGroup(group));
        }
    });
    /* deleted system groups (??):
    foreach (`uid, `group, modified_groups["system"]:$[], ``{
        exported_groups = add (exported_groups, ExportGroup(group));
    });*/

    // modified system groups:
    foreach (`uid, `group, groups["system"]:$[], ``{

        if (group ["modified"]:"no" != "no" || ExportAll)
        {
            exported_groups = add (exported_groups, ExportGroup(group));
        }
    });

    return $[
        "users": exported_users,
        "groups": exported_groups,
        "user_defaults": useradd_defaults
    ];

}

/**
 * Helper function, which corects the userlist entry of each group.
 * During autoinstallation, system groups are loaded from the disk,
 * and the userlists of these groups can contain the local users,
 * which we don not want to Import. So they are removed here.
 * @param disk_groups the groups loaded from local disk
 * @return corrected map of groups
 */
global define map RemoveDiskUsersFromGroups (map disk_groups) ``{

	map ret = mapmap (`gid, `group, disk_groups, ``{

        map new_group = group;

        foreach (`list_of_users, ["userlist", "more_users"], ``{

            list userlist = splitstring (group[list_of_users]:"", ",");
            string userlist_s = "";
            foreach (`username, userlist, ``{
                if (haskey (users_by_name ["system"]:$[], username) ||
                    haskey (users_by_name ["local"]:$[], username))
                {
                    if (userlist_s == "")
                        userlist_s = username;
                    else
                        userlist_s = userlist_s + "," + username;
                }
            });
            new_group[list_of_users] = userlist_s;
        });

	    return [ gid, new_group ];
	});

    return ret;
}

/**
 * Take the object (user or group) and substitute the values of arguments with
 * default values (marked in object template). Translates attribute names from
 * LDAP types to internal yast-names.
 * @param what "user" or "group"
 * @param data map of already gathered keys and values
 * @example map of default values contains pair "homeDirectory": "/home/%uid"
 * -> value of "home" is set to "/home" + username
 * @return new data map with substituted values
 */
global define map SubstituteValues (string what, map data) ``{

    map ret = data;
    list internal = (what == "user") ? user_internal_keys: group_internal_keys;
    map defaults = (what == "user") ? ldap_user_defaults : ldap_group_defaults;
    // 'value' of 'attr' should be changed
    foreach (`attr,`value, data, ``{

	string svalue = "";
	if (!is (value, string) && !is(value, list))
	    return;
	if (is (value, list))
	{
	    if (size (value)>1)
		return;
	    svalue = value[0]:"";
	}
	else
	    svalue = value;
	// substitute only when current value is empty or contains "%"
	if (contains (internal, attr) ||
	    (svalue != "" && !issubstring (svalue, "%")))
	    return;

	// translate attribute names from LDAP to yast-type
	string ldap_attr = ldap_attrs_conversion [attr]:attr;
	string val = defaults [ldap_attr]:nil;

	if (val != nil && issubstring (val, "%"))
	{
	    list parts = splitstring (val, "%");
	    string result = parts [0]:"";
	    integer i = 1;
	    while (i < size (parts))
	    {
		string part = parts[i]:"";
		boolean replaced = false;
		// find a contens of substitution (filled in current user/group)
		foreach (`at, `v, data, ``{
		    if (contains (internal, at) || replaced)
			return;
		    if (!is (v, list) && !is(v,string) && !is(v,integer))
			return;
		    string sv = "";
		    if (is (v, list))		sv = v[0]:"";
		    else if (is(v,integer))	sv = sformat ("%1",v);
		    else sv = v;
		    string a = ldap_attrs_conversion [at]:at;
		    if (substring (part, 0, size (a)) == a)
		    {
			result = result + sv + substring (part, size (a));
			replaced = true;
		    }
		});
		if (!replaced)
		    result = result + "%" + part;
		i = i + 1;
	    }
	    if (result != svalue)
	    {
		y2milestone ("attribute '%1' changed from '%2' to '%3'",
		    attr, svalue, result);
		ret [attr] = result;
	    }
	}
    });
    return ret;
}

/**
 * Initializes (user|group)_in_work map with default values
 * @param what "user" or "group"
 * @param data user/group initial data (could be an empty map)
 * @return success
 */
global define boolean Add (string what, map data)``{

    string type = data["type"]:nil;
    if (what == "user")
    {
	// what could be in "data":
	// - something from saved_user (during installation sequence)
	// - calling Add User->Details->Next = one more Add call
	// - TODO base values, like username/uid/fullname(in cmd-line interface)
        user_in_work = eval (data);
	// create some default values
	if (type == nil)
	{
	    type = "local";
	    // nis user cannot be added from client
	    integer i = size (current_users) - 1;
	    while (i >= 0 )
	    {
		if (current_users[i]:"local" != "nis")
		    type = current_users[i]:"local";
		i = i - 1;
	    }
	}

	UsersCache::user_type	= type;
	user_in_work["type"]	= type;
	user_in_work["uid"]	= data["uid"]:NextFreeUid();
	if ( user_in_work["uid"]:nil ==  nil )
	{
	    // error label
	    Report::Error(_("There is no free UID for this type of user."));
	    return false;
	}
	string username		= data["username"]:"";
	user_in_work["username"] = username;
	user_in_work["fullname"] = data["fullname"]:"";
	user_in_work["groupname"] = data["groupname"]:GetDefaultGroupname(type);
	user_in_work["grouplist"] = data["grouplist"]:GetDefaultGrouplist(type);

	// Do not use default value as function (["value"]:GetDefault()),
	// bacause it is evaluated always and warning could be shown when
	// not necessary...
	user_in_work["home"]	= data["home"]:nil;
	if (user_in_work ["home"]:nil == nil)
	    user_in_work ["home"] = GetDefaultHome (true, type) + username;

	user_in_work["gid"]	= data["gid"]:nil;
	if (user_in_work ["gid"]:nil == nil)
	    user_in_work ["gid"] = GetDefaultGid (true, type);

	user_in_work["shell"]	= data["shell"]:GetDefaultShell(type);
	user_in_work["password"] = data["password"]:"";
	user_in_work["create_home"] = data["create_home"]:true;
	user_in_work["what"] = "add_user";
	map user_shadow		= data["shadow"]:GetDefaultShadow(type);
	if (type == "ldap")
	{
	    user_in_work = union (user_in_work, user_shadow);
	    // add default object classes
	    user_in_work["objectClass"] = data["objectClass"]:ldap_user_class;
	    // add other default values
	    foreach (`attr, `val, ldap_user_defaults, ``{
		string a = ldap2yast_user_attrs [attr]:attr;
		if (!haskey (user_in_work, a) || user_in_work[a]:"" == "")
		    user_in_work [a] = val;
	    });
	    user_in_work ["dn"] = data["dn"]:CreateUserDN (data);
	}
	else
	    user_in_work["shadow"] = user_shadow;
    }
    else
    {
        group_in_work = eval (data);
	// create some default values
	if (type == nil)
	{
	    type = "local";
	    // nis group cannot be added from client
	    integer i = size (current_groups) - 1;
	    while (i >= 0 )
	    {
		if (current_groups[i]:"local" != "nis")
		    type = current_groups[i]:"local";
		i = i - 1;
	    }
	}
	UsersCache::group_type = type;
	group_in_work["type"]	= type;
	group_in_work["gid"]	= data["gid"]:NextFreeGid();
	if ( group_in_work["gid"]:nil ==  nil )
	{
	    // error label - TODO: solve for command-line mode!
	    Report::Error(_("There is no free GID for this type of group."));
	    return false;
	}
	group_in_work["what"] = "add_group";
	if (type == "ldap")
	{
	    // add default object classes
	    group_in_work["objectClass"] = data["objectClass"]:ldap_group_class;
	    // add other default values
	    foreach (`attr, `val, ldap_group_defaults, ``{
		string a = ldap2yast_group_attrs [attr]:attr;
		if (!haskey (group_in_work, a) || group_in_work[a]:"" == "")
		    group_in_work [a] = val;
	    });
	    group_in_work ["dn"] = data["dn"]:CreateGroupDN (data);
	}
    }
    return true;
}

/**
 * Initializes (user|group)_in_work map for editing
 * @param what "user" or "group"
 * @param data user/group data map
 * @return success
 * TODO:
 *  - find out user/group in global map - currently done by SelectUser
 *  - update the current map?
 *  - groups
 */
global define boolean Edit (string what, map data)``{

    string type = data["type"]:"local";
    if (what == "user")
    {
	string username = data["username"]:"";
	// user is edited for first time
	if (!haskey (data, "org_user") && data["what"]:"" != "add_user")
	{
	    if (type == "ldap")
	    {
		// convert values with wrong type to string
		data = eval (user_in_work);
	    }
	    // local users have to load shadow settings from global map
	    if (user_in_work["shadow"]:$[] == $[] && type != "ldap")
	    {
		user_in_work["shadow"] = eval
		    (shadow[type, username]:GetDefaultShadow(type));
	    }
	    // save first map for later checks of modification...
	    user_in_work["org_user"] = eval (data);
	    // grouplist wasnt fully generated while reading nis & ldap users
	    if (type == "nis" || type == "ldap")
	    {
		user_in_work["grouplist"] = FindGroupsBelongUser (username,
		    data["dn"]:"");
	    }
	    // empty password entry for autoinstall config (do not want to
	    // read password from disk: #30573)
	    if (Mode::config && user_in_work["password"]:nil == "x")
		user_in_work["password"] = "";
	}
	user_in_work["what"] = "edit_user";
	UsersCache::user_type = type;
	/*
	// TODO update the settings when present??
	foreach (`key, `value, data, ``{
	    user_in_work[key] = value;
	});
	*/
    }
    else
    {
	group_in_work["what"] = "edit_group";
	UsersCache::group_type = type;
	/*
	// group is edited for first time
	if (!haskey (data, "org_group") && data["what"]:"" != "add_group" &&
	    type == "ldap")
	{
	    // save first map for later checks of modification...
	    group_in_work["org_group"] = eval (data);
	}
	*/

    }
    return true;
}

global define boolean Delete (string what, map data)``{

    // find user/group and prepare (user|group)_in_work
    return true;
}

/**
 * Checks if commited user is really modified and has to be saved
 */
global define boolean UserReallyModified () ``{

    if (user_in_work["what"]:"no" == "group_change")
        return false;
    if (user_in_work["what"]:"no" != "edit_user")
        return true;

    boolean ret = false;

    if (user_in_work["type"]:"local" != "ldap")
    {
	// grouplist can be ignored, it is a modification of groups
	foreach (`key, `value, user_in_work["org_user"]:$[], ``{
	    if (key != "grouplist" && user_in_work[key]:nil != value)
	    {
		ret = true;
		y2debug ("old value:%1, changed to:%2",
		    value, user_in_work[key]:nil);
	    }
	});
	return ret;
    }
    // for LDAP users, it is possible thet some values were not present in
    // search result: we must test different way
    foreach (`key, `value, user_in_work, ``{

	if (contains (user_internal_keys, key) || is (value, map))
	    return;
	// single values are returned as string from agent, not as list
	// TODO use lists every time
        if (is (value, list) && is (user_in_work["org_user",key]:"", string)
	    && user_in_work["org_user",key]:"" == value[0]:"")
	    return;
        if (user_in_work["org_user",key]:"" != value)
	{
	    ret = true;
	    y2debug ("old value:%1, changed to:%2",
		user_in_work["org_user",key]:"", value);
	}
    });
    return ret;
}

/**
 * Remove user from the list of members of current group
 */
define boolean RemoveUserFromGroup (string user) ``{

    boolean ret		= false;
    string group_type	= group_in_work ["type"]:"local";
    string userlist	= group_in_work ["userlist"]:"";
    list l_userlist	= splitstring (userlist, ",");
    if (group_type == "ldap")
    {
	l_userlist	= group_in_work ["uniqueMember"]:[];
	user		= user_in_work ["org_dn"]:user_in_work["dn"]:"";
    }
    if (contains (l_userlist, user))
    {
	ret = true;
	group_in_work ["what"] = "user_change";
	l_userlist = filter (`u, l_userlist, ``(u != user));
	if (group_type != "ldap")
	{
	    userlist = mergestring (l_userlist, ",");
	    group_in_work ["userlist"] = userlist;
	}
	else
	{
	    group_in_work ["uniqueMember"] = l_userlist;
	}
    }
    return ret;
}

/**
 * Make user the new member of current group
 */
define boolean AddUserToGroup (string user) ``{

    boolean ret = false;
    string group_type	= group_in_work ["type"]:"local";
    string userlist	= group_in_work ["userlist"]:"";
    list l_userlist	= splitstring (userlist, ",");
    if (group_type == "ldap")
    {
	l_userlist	= group_in_work ["uniqueMember"]:[];
	user		= user_in_work ["dn"]:"";
    }

    if (!contains (l_userlist, user))
    {
	ret = true;
	group_in_work ["what"] = "user_change";
	if (group_type == "ldap")
	{
	    group_in_work["uniqueMember"] = add (l_userlist, user);
	}
	else
	{
	    if (userlist != "") userlist = userlist + ",";
	    group_in_work ["userlist"] = userlist + user;
	}
    }
    return ret;
}

/**
 * Update the global user and/or group map with current
 * user_in work or group_in_work
 * @param object "user" or "group"
 * @param cache if cache structures (from UsersCache) should be updated
 * @return true on success
 */
global define boolean Commit (string object, boolean cache)``{

    if (object == "user")
    {
        string what_user = user_in_work ["what"]:"no";
        string type = user_in_work ["type"]:"local";
	if (type == "ldap" && what_user == "add_user")
	{
	    user_in_work = SubstituteValues (object, user_in_work);
	}
        integer uid = user_in_work ["uid"]:max_uid[type]:60000;
        integer org_uid = user_in_work ["org_uid"]:uid;
        string username = user_in_work ["username"]:"";
        string org_username = user_in_work ["org_username"]:username;
        string grouplist = user_in_work ["grouplist"]:"";
        string defgroup = user_in_work ["groupname"]:GetDefaultGroupname(type);
	string home = user_in_work["home"]:"";
        list group_list = splitstring (grouplist, ",");//remove ""
        group_list = filter (`g, group_list, ``(g != ""));

//y2warning ("user: %1", user_in_work);
        if ((type == "local" || type == "system") &&
            !users_modified && UserReallyModified())
	    users_modified = true;
//FIXME if !UserReallyModified && Mode::config -> unset user["modified"] ???
//--- or set user_modified to true?
        if (type == "ldap" && !ldap_modified && UserReallyModified())
            ldap_modified = true;

        // the action
        if ( what_user == "add_user" )
        {
            // when writing the new user, the new home has to be created
            user_in_work ["modified"] = "added";
            // update the affected groups
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work != $[] && AddUserToGroup (username))
                    Commit ("group", cache);
            });
	    // check if home directory for this user doesn't already exist
	    if (!user_in_work["create_home"]:true &&
		contains (removed_homes, home))
	    {
		removed_homes = filter (`h, removed_homes, ``(h != home));
	    }
            // add user to his default group -- updating only cache variables
            group_in_work = GetGroupByName (defgroup, type);
            if (group_in_work != $[])
            {
                group_in_work ["what"] = "user_change_default";
                string more_users = group_in_work ["more_users"]:"";
                if (more_users != "") more_users = more_users + ",";
                group_in_work ["more_users"] = more_users + username;
                Commit ("group", cache);
            }
            // modify global shadow map:
            shadow [type] = add(shadow [type]:$[],
                 username, user_in_work["shadow"]:$[]);
        }
        else if ( what_user == "edit_user" )
        {
            if (user_in_work ["modified"]:"no" != "added")
                user_in_work ["modified"] = "edited";
            // check the change of additional group membership
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[]) return;
                // username changed - remove org_username
                if (org_username != username)
                {
		    RemoveUserFromGroup (org_username);
		}
		if (AddUserToGroup (username))
                    Commit ("group", cache);
            });
            // check the removing user from some additional group
            list removed_group_list = user_in_work ["removed_grouplist"]:[];
            foreach (`group, removed_group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work == $[]) return;
		if (RemoveUserFromGroup (org_username))
                    Commit ("group", cache);
            });
            // check the change in default group
            string org_defgroup = user_in_work ["org_groupname"]:defgroup;
            if ((username != org_username) && (defgroup == org_defgroup))
            {
                // change the user's name in current default group
                group_in_work = GetGroupByName (defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = "user_change_default";
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
            else if (defgroup != org_defgroup)
            {
                // note: username could be also changed!
                // remove the name from original group ...
                group_in_work = GetGroupByName (org_defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = "user_change_default";
                    string more_users = group_in_work ["more_users"]:"";
                    list l_more_users = splitstring (more_users, ",");
                    l_more_users = filter (`u, l_more_users,
                        ``(u != org_username));
                    more_users = mergestring (l_more_users, ",");
                    group_in_work ["more_users"] = more_users;
                    Commit ("group", cache);
                }
                // and add it to the new one;
                group_in_work = GetGroupByName (defgroup, type);
                if (group_in_work != $[])
                {
                    group_in_work ["what"] = "user_change_default";
                    string more_users = group_in_work ["more_users"]:"";
                    if (more_users != "") more_users = more_users + ",";
                    group_in_work ["more_users"] = more_users + username;
                    Commit ("group", cache);
                }
            }
	    // check if home directory for this user doesn't already exist
	    if (!user_in_work["create_home"]:true &&
		contains (removed_homes, home))
	    {
		removed_homes = filter (`h, removed_homes, ``(h != home));
	    }
            // modify the shadow entry
            if (type == "local" || type == "system") // - also for groups !
            {
                if (username != org_username)
                    if (haskey (shadow[type]:$[], org_username))
                        shadow [type] = remove (shadow[type]:$[], org_username);
                shadow [type, username] = user_in_work["shadow"]:$[];
            }
        }
        else if ( what_user == "delete_user" )
        {
            // check the change of group membership
            foreach (`group, group_list, ``{
                group_in_work = GetGroupByName (group, type);
                if (group_in_work != $[] && RemoveUserFromGroup (org_username))
                    Commit ("group", cache);
            });
            // remove user from his default group -- only cache structures
            group_in_work = GetGroupByName (defgroup, type);
            group_in_work ["what"] = "user_change_default";
            string more_users = group_in_work ["more_users"]:"";
            list l_more_users = splitstring (more_users, ",");
            l_more_users = filter (`u, l_more_users, ``(u != username));
            more_users = mergestring (l_more_users, ",");
            group_in_work ["more_users"] = more_users;
            Commit ("group", cache);

	    // store deleted directories... someone could want to use them
	    if (user_in_work["delete_home"]:false && type != "ldap")
	    {
		removed_homes = add (removed_homes, user_in_work["org_home"]:
		    user_in_work["home"]:"");
	    }
            // prevent the add & delete of the same user
            if (user_in_work["modified"]:"no" != "added")
            {
                user_in_work ["modified"] = "deleted";
		// TODO: modified_users is not needed when we use removed_homes
		// (but are still needed for ldap)
		modified_users [type] = add (modified_users [type]:$[],
                    uid, user_in_work);
            }
            if (type != "ldap")
                shadow [type] = remove (shadow [type]:$[], org_username);
        }
        else if ( what_user == "group_change_default")
	{
	    // gid of default group was chnaged!
	    user_in_work ["modified"] = "edited";
        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeUser(what_user, user_in_work);

        // the main action: update users
        if (what_user == "delete_user")
        {
            users [type] = remove (users[type]:$[], uid);
            users_by_name [type] = remove (users_by_name[type]:$[], username);
        }
        else // also "group_change" !
        {
            if (uid != org_uid && haskey (users[type]:$[], org_uid))
            {
                users [type] = remove (users [type]:$[], org_uid);
            }
	    if (username != org_username)
	    {
                users_by_name [type] = remove (users_by_name [type]:$[],
		    org_username);
	    }
            users [ type, uid ] = eval (user_in_work);
            users_by_name [ type, username ] = uid;

            users [type, uid, "org_username"] = username;
        }
    }
    else if ( object == "group" )
    {
//y2internal ("group: %1", group_in_work);
        string type		= group_in_work ["type"]:"local";
        string what_group	= group_in_work ["what"]:"no";
	if (type == "ldap" && what_group == "add_group")
	{
	    group_in_work = SubstituteValues (object, group_in_work);
	}
        integer gid		= group_in_work ["gid"]:max_gid [type]:60000;
        integer org_gid		= group_in_work ["org_gid"]:gid;
        string groupname	= group_in_work ["groupname"]:"";
        string password		= group_in_work ["password"]:"*";
        string org_groupname	= group_in_work ["org_groupname"]:groupname;
        string userlist		= group_in_work ["userlist"]:"";
        list l_userlist		= splitstring (userlist, ",");
	if (type == "ldap")
	    l_userlist		= group_in_work ["uniqueMember"]:[];

        if (org_groupname == "")
            org_groupname = groupname;

        if (type == "system" || type == "local")
            groups_modified = true;

        if (type == "ldap" && what_group != "no")
            ldap_modified = true;

        if ( what_group == "add_group" )
        {
            group_in_work ["modified"] = "added";
            // update users's grouplists (only local structures)
            foreach (`user, l_userlist, ``{
                user_in_work = GetUserByName (user);
                string grouplist = user_in_work ["grouplist"]:"";
                if (grouplist != "")
                   grouplist = grouplist + ",";
                user_in_work["grouplist"] = grouplist + groupname;
                user_in_work["what"] = "group_change";
                Commit("user", cache);
            });
            // create an entry for global gshadow map:
            gshadow [type] = add (gshadow[type]:$[], groupname, $[
                "password": password,
                "disposer": "root", // default??
                "userlist": ""]); // will be updated at the end
        }
        else if (what_group == "edit_group" )
        {
            if (group_in_work ["modified"]:"no" != "added")
                group_in_work ["modified"] = "edited";
            // update users's grouplists (mainly local structures)
            foreach (`user, l_userlist, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    boolean commit_user = false;
                    // new user added to group
                    if (! contains (l_grouplist, org_groupname))
                    {
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    else if (org_groupname != groupname)
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        // what about ",,"?
                        if (grouplist != "")
                           grouplist = grouplist + ",";
                        user_in_work["grouplist"] = grouplist + groupname;
                        commit_user = true;
                    }
                    if (commit_user)
                    {
                        user_in_work["what"] = "group_change";
                        Commit("user", cache);
                    }
                }
            });
            // check the additional users removed from this group
            list removed_user_list = group_in_work ["removed_userlist"]:[];
            foreach (`user, removed_user_list, ``{
                user_in_work = GetUserByName (user);
                if (user_in_work != $[])
                {
                    string grouplist = user_in_work ["grouplist"]:"";
                    list l_grouplist = splitstring (grouplist, ",");
                    if ( contains (l_grouplist, org_groupname))
                    {
                        l_grouplist = filter (`g, l_grouplist,
                            ``(g!=org_groupname));
                        grouplist = mergestring (l_grouplist, ",");
                        user_in_work["grouplist"] = grouplist;
                        user_in_work["what"] = "group_change";
                        Commit("user", cache);
                    }
                }
            });
            // correct the changed groupname/gid for users with this group
            // as default
            if ((groupname != org_groupname) || (gid != org_gid))
            {
                string more_users = group_in_work ["more_users"]:"";
                list l_more_users = splitstring (more_users, ",");
                foreach (`user, l_more_users, ``{
                    user_in_work = GetUserByName (user);
                    if (user_in_work != $[])
                    {
                        user_in_work["groupname"] = groupname;
                        user_in_work["gid"] = gid;
			if (gid != org_gid)
			    user_in_work["what"] = "group_change_default";
			else
			    user_in_work["what"] = "group_change";
                        Commit("user", cache);
                    }
                });
            }
            if (groupname != org_groupname && type != "ldap")
            {
                gshadow [type, groupname] = gshadow [type, org_groupname]:$[];
                if (haskey (gshadow [type]:$[], org_groupname))
                    gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            }
	    if (!contains (["x","*","!"], password) && type != "ldap")
                gshadow [type, groupname, "password"] = password;
        }
        else if (what_group == "delete_group" )
        {
            if (group_in_work ["modified"]:"no" != "added")
            {
                group_in_work ["modified"] = "deleted";
                modified_groups [type] = add (modified_groups [type]:$[],
                    gid, group_in_work);
            }
            groups [type] = remove (groups [type]:$[], org_gid);
            groups_by_name [type] = remove (groups_by_name [type]:$[],
                org_groupname);
            if (haskey (gshadow [type]:$[], org_groupname))
                gshadow [type] = remove (gshadow [type]:$[], org_groupname);
            // deleted group had no members -> no user change
        }
        else if ( what_group == "user_change" ) // do not call Commit again
        {
            if (group_in_work ["modified"]:"no" != "added")
            {
                group_in_work ["modified"] = "edited";
            }
        }
        else if ( what_group == "user_change_default" )
        {
            // current group is some user's default - changin only cache
            // structures and don't set modified flag
        }
        // change the cache variables
        if (cache)
            UsersCache::ChangeGroup(what_group, group_in_work);

        if (what_group != "delete_group") // also for `change_user!
        {
            // the main action: update groups
            if (gid != org_gid && haskey (groups [type]:$[], org_gid))
                groups [ type ] = remove (groups [type]:$[], org_gid);
            groups [ type, gid ] = group_in_work;

            // name could have been changed !!
            if (groupname != org_groupname &&
                haskey (groups_by_name [type]:$[], org_groupname))
                groups_by_name [type] = remove (groups_by_name [type]:$[],
                    org_groupname);
            groups_by_name [type, groupname] = group_in_work;

            // update userlist in gshadow
            if (haskey (gshadow [type]:$[], groupname))
                gshadow [type, groupname, "userlist"] = userlist;

            // this has to be done due to multiple changes of groupname
            groups [type, gid, "org_groupname"] = groupname;
        }
    }
    return true;
}
/**
 * Checks the possible user sources
 */
global define void ReadSourcesSettings () ``{

    available_usersets = [ "local", "system" ];
    available_groupsets = [ "local", "system" ];

    user_sources = GetUsersSources ();
    is_nis_available = IsNISAvailable (user_sources);
    is_nis_master = IsNISMaster ();
    is_ldap_available = IsLDAPAvailable (user_sources);

    if ( !is_nis_master && is_nis_available )
    {
        available_usersets = add ( available_usersets, "nis");
        available_groupsets = add ( available_groupsets, "nis");
    }

    if ( is_ldap_available )
    {
	import "Ldap";
        available_usersets = add ( available_usersets, "ldap");
        available_groupsets = add ( available_groupsets, "ldap");
    }

    available_usersets = add ( available_usersets, "custom");
    available_groupsets = add ( available_groupsets, "custom");
}

/**
 * Return map for mapping user names to UIDs
 * @param usermap map of users of type $[ uid:user's map ]
 * @return new mapping of type $[ username: uid ]
 */
global define map UsersByName (map usermap) ``{
	map res = mapmap (`k, `v, usermap, ``{
	    return [ lookup (v, "username", ""), k ]; // only uid !!
	});
	return res;
}

/**
 * Maps groupname to group's map
 * @param groupsmap map of groups of type $[ gid:group's map ]
 * @return new mapping of type $[ groupname: group's map ]
 */
global define map GroupsByName (map groupsmap) ``{
	map res = mapmap (`k, `v, groupsmap, ``{
	    return [ lookup (v, "groupname", ""), v ]; // whole map??
	});
	return res;
}

/**
 * Fills the variables with the default values
 * (used only for better access)
 * @param useUI if UI is used
 */
define void SetDefaultValues(boolean useUI) ``{

    pass_inact_days  = tointeger( useradd_defaults["inactive"]:"-1" );
    pass_expire_date = useradd_defaults["expire"]:"";

    default_shell = useradd_defaults["shell"]:default_shell;
    default_skel = useradd_defaults["skel"]:default_skel;
    default_expire = useradd_defaults["expire"]:default_expire;
    default_inactive = useradd_defaults["inactive"]:default_inactive;
}

/**
 * Reads settings from /etc/defaults/useradd
 * @param useUI if UI is used
 * @return true on success
 */
global define boolean ReadLoginDefaults(boolean useUI)``{

    path useradd_path = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{
	string entry = SCR::Read(add (useradd_path, key));
	if (entry == nil) entry = "";
        useradd_defaults[key] = deletechars (entry, "\"");
    });

    if( useradd_defaults == $[] || useradd_defaults == nil )
	return false;

    SetDefaultValues(useUI);
    return true;
}

/**
 * Writes settings to /etc/defaults/useradd
 * @return true on success
 */
global define boolean WriteLoginDefaults()``{

    boolean ret = true;
    path useradd = .etc.default.useradd;

    foreach (`key, `value, useradd_defaults, ``{

        ret = ret && SCR::Write( add(useradd, key), value);
    });

    y2milestone ("Succesfully written useradd defaults: %1", ret);
    return ret;
}

/**
 * Save Security settings (encryption method) if changed in Users module
 * @return success
 */
global define boolean WriteSecurity () ``{

    boolean ret = true;
    if ( encryptionMethod != Security::Settings["PASSWD_ENCRYPTION"]:"des" )
    {
	y2milestone( "Changing encryption method to %1", encryptionMethod);
        Security::modified = true;
	Security::Settings["PASSWD_ENCRYPTION"] = encryptionMethod;
	Progress::off();
	ret = Security::Write();
	if (!write_only)
	    Progress::on();
    }
    return ret;
}

/**
 * Removes directories marked for deletion
 * (there are stored in global list removed_homes
 */
global define boolean DeleteHomeDirs () ``{

    boolean ret = true;
    foreach (`home, removed_homes, ``{
	ret = ret && DeleteHome (home);
    });
    return ret;
}


/**
 * Reads all possible shels and builds the itemlist for add user dialog
 * @return true
 */
define boolean ReadAllShells()``{

    all_shells = GetAllShells (`stringlist);
    all_shells_items = GetAllShells (`items);

    return true;
}

/**
 * Sets the default gid and groupname
 * @param useUI if UI is used
 * @return true
 */
define boolean ReadDefaultGroup(boolean useUI)``{

    default_gid = GetDefaultGid(useUI, "local");
    default_groupname = lookup (GetGroupFromAll(default_gid), "groupname","");

    return true;
}

/**
 * Read the security settings from the system (using the Security module),
 * sets the encoding and various variables
 * @return boolean true on succes
 */
global define boolean ReadSystemDefaults()``{

    Progress::off();
    Security::Read();
    Progress::on();

    max_uid ["local"] = tointeger (Security::Settings["UID_MAX"]:"60000");
    max_gid ["local"] = tointeger (Security::Settings["GID_MAX"]:"60000");
    max_uid ["system"] = tointeger (Security::Settings ["UID_MIN"]:"500") - 1;
    max_gid ["system"] = tointeger (Security::Settings ["GID_MIN"]:"500") - 1;
    max_length_uid = size(sformat("%1", max_uid ["local"]:60000));
    max_length_gid = size(sformat("%1", max_gid ["local"]:60000));

    pass_max_days = tointeger (Security::Settings ["PASS_MAX_DAYS"]:"99999");
    pass_min_days = tointeger (Security::Settings ["PASS_MIN_DAYS"]:"0");
    pass_warn_age = tointeger (Security::Settings ["PASS_WARN_AGE"]:"7");

    encryptionMethod = Security::Settings["PASSWD_ENCRYPTION"]:"des";

    use_cracklib = (Security::Settings["PASSWD_USE_CRACKLIB"]:"no" == "yes");
    cracklib_dictpath=Security::Settings["CRACKLIB_DICTPATH"]:cracklib_dictpath;

    obscure_checks = (Security::Settings["OBSCURE_CHECKS_ENAB"]:"no" == "yes");

    pass_length ["local", "min"] =
	tointeger (Security::Settings ["PASS_MIN_LEN"]:"5");

    pass_length ["local", "max"] = (encryptionMethod != "des") ?
	    Security::PasswordMaxLengths [encryptionMethod]:8 :
	    tointeger (Security::Settings ["PASS_MAX_LEN"]:"8");

    y2debug ("encryption: %1", encryptionMethod);

    encoding = Console::encoding;

    return true;
}


/**
 * Return a map with the defaults for the shadow entry
 * @param type user type ("local","ldap" etc.)
 * @return map of shadow settings
 */
global define map GetDefaultShadow(string type)``{

    map ret = $[
	"expire": default_expire,
	"inact"	: default_inactive,
	"max"	: sformat("%1", pass_max_days),
	"min"	: sformat("%1", pass_min_days),
	"warn"	: sformat("%1", pass_warn_age),
	"last_change": LastChangeIsNow()
    ];
    if (type == "ldap")
    {
	ret = eval (ldap_shadow);
	ret ["shadowLastChange"] = LastChangeIsNow();
    }
    return ret;
}

/**
 * Return the default home value for a new user.
 * @param useUI if UI is used
 * @param type user type ("local","ldap" etc.)
 * @return string home directory
 */
global define string GetDefaultHome(boolean useUI, string type)``{

    string def_home = useradd_defaults["home"]:"/home";
    if (type == "ldap")
    {
	def_home = ldap_defaults["home"]:def_home;
	// it is not on this machine, so we cannot check it now...
	if (!ldap_file_server)
	    return def_home;
	// there should be some substitution, so we cannot check it now...
	if (issubstring (def_home, "%"))
	    return def_home;
    }

    // check for existence of prefix directory
    if (SCR::Read(.target.size, def_home ) == -1 && useUI)
    {
        // Popup tex
        if (Popup::YesNo(sformat (_("The default home directory \"%1\" does not exist.
Create it now?
"), def_home)))
            SCR::Execute (.target.mkdir, def_home);
    }
    if ( (findlastof( def_home, "/") +1) != size(def_home ) )
    {
        def_home = def_home + "/";
    }
    return def_home;
}

/**
 * Return the default shell
 * @param type user type ("local", "ldap" etc.)
 * @return string shell
 */
global define string GetDefaultShell(string type)``{

    if (type == "ldap")
    {
	return ldap_defaults["shell"]:default_shell;
    }
    else
	return default_shell;
}

/**
 * Return the default group id for a new user.
 * @param useUI if UI is used
 * @param type user type ("local", "ldap" etc.)
 * @return integer gid
 */
global define integer GetDefaultGid(boolean useUI, string type)``{

    string def_gid  = useradd_defaults["group"]:sformat("%1",default_gid);
    if (type == "ldap")
    {
	def_gid = ldap_defaults["group"]:def_gid;
    }
    integer def_int = tointeger(def_gid);
    // first, try the same type as user's
    map group = groups [type, def_int]:$[];

    if (group == $[])
	group = GetGroupFromAll (def_int);
    if (group == $[])
    {
        if (useUI)
	{
	    // error popup, part 2/2
	    string rest = _("Change the default group in /etc/default/useradd.");
	    if (type == "ldap")
		// error popup, part 2/2
		rest = _("Change the default group in LDAP settings.");
	    // error popup, part 1/2, %1 is number, %2 is next part
	    Report::Error(sformat(_("The default group with the ID %1 does not exist.
%2
"), def_int, rest));
	}
        return default_gid;
    }
    return def_int;
}

/**
 * The default grouplist for new user
 * @param type type of new user ("local", "system", "nis", "ldap")
 * @return the grouplist
 */
global define string GetDefaultGrouplist (string type) ``{

    // check for existence of groups !!
    if (type == "local")
	return useradd_defaults ["groups"]:"";
    else if (type == "ldap")
	return ldap_default_grouplist;
    else
        return "";
}

/**
 * The name of default group
 * @param type type of new user ("local", "system", "nis", "ldap")
 * @return the groupname
 */
global define string GetDefaultGroupname (string type) ``{

    if (type != "ldap")
        return default_groupname;
    else
    {
	if (ldap_default_groupname == "")
	{
	    ldap_default_groupname = groups["ldap", GetDefaultGid (false, type),
		"groupname"]:default_groupname;
	}
        return ldap_default_groupname;
    }
}

/**
 * Read the /etc/shells file and return a item list or a string shell list.
 * @param todo `items or `stringlist
 * @return list of shells
 */
global define list GetAllShells(symbol todo ) ``{

    list available_shells =  [];
    list shells_read = SCR::Read(.etc.shells);

    foreach( `shell_entry, shells_read, ``{

	if( is( shell_entry, string ))
	{
	    if ( (! issubstring( shell_entry, "passwd")) &&
		 (! issubstring( shell_entry, "bash1")) )
	    {
		if(  SCR::Read(.target.size, shell_entry  )  != -1  )
		{
		    if (todo == `items)
			available_shells = add(available_shells,
			    `item( `id(shell_entry), shell_entry ));
		    if ( todo == `stringlist )
			available_shells = add( available_shells, shell_entry);
		}
	    }
	}
    });
    return available_shells;
}

/**
 * Reads the set of values in "Custom" filter from disk and other internal
 * variables ("not_ask")
 */
global define void ReadCustomSets() ``{

    string file = Directory::vardir + "/users.ycp";
    SCR::Execute (.target.bash, sformat ("/bin/touch %1", file));
    any customs = SCR::Read (.target.ycp, file);

    if (is (customs, map))
    {
	user_custom_sets = customs ["custom_users"]:[];
	if (user_custom_sets == [])
	    user_custom_sets = ["local"];

	group_custom_sets = customs ["custom_groups"]:[];
	if (group_custom_sets == [])
	    group_custom_sets = ["local"];

	if (customs["dont_warn_when_uppercase"]:false == true)
	    not_ask_uppercase = true;
    }

}

/**
 * Writes the set of values in "Custom" filter and other internal varianbles
 * @return writing success
 */
global define boolean WriteCustomSets() ``{

    map customs = $[
        "custom_users": user_custom_sets,
        "custom_groups": group_custom_sets,
        "dont_warn_when_uppercase": not_ask_uppercase,
    ];
    return
    SCR::Write (.target.ycp, Directory::vardir + "/users.ycp", customs);
}

/**
 * Helper for building items of MenuButton in users/groups summary dialog
 */
global define void BuildMenuButtonItems() ``{

    available_usersets_items = [];
    foreach (`set, available_usersets, ``{
        available_usersets_items = add ( available_usersets_items,
            `item(`id(set), userset_to_string [ set ]:""));
    });

    // build the groups MenuButton items
    available_groupsets_items = [];
    foreach (`set, available_groupsets, ``{
        available_groupsets_items = add ( available_groupsets_items,
            `item(`id(set), groupset_to_string [ set ]:""));
    });

}

/**
 * Reads the settings, used for cache structures
 * @param read_prebuilded if there were some structures prebuilded by extern
 * script and should be readed from files
 */
global define void ReadUsersCache(boolean read_prebuilded) ``{

    // this is ugly -- move it to some Consts module ?
    UsersCache::max_uid         =    max_uid;
    UsersCache::max_gid         =    max_gid;
    UsersCache::min_uid         =    min_uid;
    UsersCache::min_gid         =    min_gid;
    UsersCache::max_length_uid  =    max_length_uid;
    UsersCache::max_length_gid  =    max_length_gid;

    UsersCache::encoding        =   encoding;

    UsersCache::ldap_file_server = ldap_file_server;

    // build the users MenuButton items
    BuildMenuButtonItems ();

    current_users = eval (user_custom_sets);
    current_groups = eval (group_custom_sets);

    UsersCache::user_custom_sets = user_custom_sets;
    UsersCache::group_custom_sets = group_custom_sets;

    // use the pre-builded structures also for cache
    if (read_prebuilded)
    {
        ChangeCurrentUsers ("custom");
        ChangeCurrentGroups ("custom");
        UsersCache::ReadFromFiles (tmpdir);
    }
    else
        UsersCache::Read (users, groups, current_users, current_groups);
}

/**
 * Returns the map of users specified by its name
 * @param name user's identification (username or DN)
 * @return the desired user's map
 */
global define map GetUserByName ( string user)``{
    map ret = $[];
    string name = user;
    if (issubstring (name, "="))
	name = get_first (name);
    integer uid = -1;
    foreach (`type, `usernames, users_by_name, ``{
        if (ret == $[])
        {
            uid = usernames [name]:-1;
            if (uid != -1)
                ret = users [type, uid]:$[];
        }
    });
    return ret;
}

/**
 * Gets the first group with given name
 * @param name group's name
 * @param usertype type of user - group will be searched in this set for first
 * @return the desired group's map
 */
global define map GetGroupByName (string name, string usertype)``{
    map ret = $[];

    ret = groups_by_name [usertype, name]:$[];
    if (ret != $[])
        return ret;

    foreach (`type, `groupmap, groups_by_name, ``{
        if (ret == $[])
        {
            ret = groupmap [name]:$[];
        }
    });
    if (ret == $[])
	y2warning("Group %1 doesn't exist!", name);
    return ret;
}

/**
 * Finds the user specified by uid and set is as current
 * @param uid the user id
 */
global define void SelectUser( integer uid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_users) )
    {
        ret = users[ current_users [i]:nil, uid ]:$[];
        if (ret != $[])
        {
            y2debug("selected user: %1", ret);
            break;
        }
        i = i + 1;
    }
    user_in_work = eval (ret);
}

/**
 * Finds the group specified by gid and set is as current
 * @param gid the group id
 */
global define void SelectGroup( integer gid )``{
    map ret = $[];
    integer i = 0;
    while ( i < size (current_groups) )
    {
        ret = groups [ current_groups [i]:nil, gid ]:$[];
        if (ret != $[])
        {
            y2debug("selected group: %1", ret);
            break;
        }
        i = i + 1;
    }
	group_in_work = ret;
}

/**
 * Return the settings for a group.
 * @param gid the group id
 * @return map of group
 */
global define map GetGroupFromAll( integer gid )``{

    map group = $[];
    foreach (`grouptype, `groupset, groups, ``{
        if (group == $[])
        {
            group = groupset [gid]:$[];
        }
    });
	return group;
}

/**
 * This define returns the groups of a user.
 * @param username the name of the user
 * @param dn DN of LDAP user (for LDAP groups only)
 * @return string group comma separated list
 */
global define string FindGroupsBelongUser( string username, string dn ) ``{

    string grouplist = "";
    foreach (`type, `groupset, groups, ``{
        foreach (`gid, `group, groupset, ``{
            list userlist = splitstring (group["userlist"]:"", ",");
	    string user = username;
	    if (type == "ldap")
	    {
		userlist = group["uniqueMember"]:[];
		user = dn;
	    }
            if (contains (userlist, user))
            {
                if (grouplist == "")
                    grouplist = group["groupname"]:"";
                else
                    grouplist = grouplist + "," + group["groupname"]:"";
            }
        });
    });
    return grouplist;
}

/**
 * Check if homedir doesn't exist for another user
 * @param home the name
 * @return true if exists
 */
global define boolean HomeExists(string home) ``{

    return UsersCache::HomeExists(home);
}

/**
 * Check if UID doesn't already exist
 * @param uid UID
 * @return true if exists
 */
global define boolean UIDExists(integer uid) ``{

    return UsersCache::UIDExists(uid);
}

/**
 * Check if username already exists
 * @param username username
 * @return true if exists
 */
global define boolean UsernameExists(string username) ``{

    return UsersCache::UsernameExists(username);
}

/**
 * Scan uidlist for the next free uid.
 * @return integer free uid
 */
global define integer NextFreeUid() ``{
    return UsersCache::NextFreeUid();
}

/**
 * Scan gidlist for the next free gid.
 * @return integer free gid
 */
global define integer NextFreeGid() ``{
    return UsersCache::NextFreeGid();
}

/**
 * Read new set of users - "on demand" (called from running module)
 * @param type the type of users, currently "ldap" or "nis"
 * @return success
 */
global define boolean ReadNewSet (string type) ``{

    if (type == "nis")
    {
        nis_not_read = false;

        UI::OpenDialog (`opt(`decorated ),
            // wait popup
            `Label(_("Reading sets of users and groups. Please wait...")));

        // first: run preparation script:
        RunPrepare ("nis");
        // read NIS users now
        users ["nis"] = ReadNISUsers (tmpdir);
        users_by_name ["nis"] = ReadNISUsersByName (tmpdir);
        groups ["nis"] = ReadNISGroups (tmpdir);
        groups_by_name ["nis"] = ReadNISGroupsByName (tmpdir);
    }
    else if (type == "ldap")
    {
        // first: check for required packages:
        if (!Require::RequireAndConflict (["yast2-ldap-client"], [], sformat (
// Popup text (%1 are required packages):
_("For managing LDAP users, package
<br>%1<br>
is required.
Install it now?"),
"<b>yast2-ldap-client</b>")))
                return false;


	// read all needed LDAP settings now:
	if (!ReadLDAPSettings ())
	    return false;

        UI::OpenDialog (`opt(`decorated ),
            // wait popup
            `Label(_("Reading sets of users and groups. Please wait...")));

	string ldap_mesg = ReadLDAP();
	if (ldap_mesg != "")
	{
            Ldap::LDAPErrorMessage("read", ldap_mesg);
            UI::CloseDialog(); // close the wait popup
            return false;
        }
        ldap_not_read = false;
        // read the LDAP users and groups now
        users ["ldap" ]		= ReadLDAPUsers ();
        users_by_name ["ldap" ] = ReadLDAPUsersByName ();
        groups ["ldap"]		= ReadLDAPGroups ();
        groups_by_name ["ldap"] = ReadLDAPGroupsByName ();
    }
    UsersCache::ReadUsers (type, tmpdir);
    UsersCache::ReadGroups (type, tmpdir);

    UI::CloseDialog(); // the wait popup
    return true;
}

/**
 * Change the current users set, additional reading could be necessary
 * @param new the new current set
 * @return success
 */
global define boolean ChangeCurrentUsers(string new) ``{

    list current = current_users;

    if ( new == "custom" )
        current_users = eval (user_custom_sets);
    else
        current_users = [ new ];

    if (contains (current_users, "ldap") && ldap_not_read)
    {
        if (!ReadNewSet ("ldap"))
        {
            current_users = current;
            return false;
        }
    }

    if (contains (current_users, "nis") && nis_not_read)
    {
        if (!ReadNewSet ("nis"))
        {
            current_users = current;
            return false;
        }
    }

    // correct also possible change in custom itemlist
    if (new == "custom")
        UsersCache::ChangeUserCustoms (current_users);

    UsersCache::current_users = current_users;

    return true;
}

/**
 * Change the set of current groups viewed
 * @param new the new current set
 * @return success
 */
global define boolean ChangeCurrentGroups(string new) ``{

    list current = current_groups;

    if ( new == "custom" )
        current_groups = eval (group_custom_sets);
    else
        current_groups = [ new ];
    if (contains (current_groups, "nis") && nis_not_read)
        if (!ReadNewSet("nis"))
        {
            current_groups = current;
            return false;
        }
    if (contains (current_groups, "ldap") && ldap_not_read)
        if (!ReadNewSet("ldap"))
        {
            current_groups = current;
            return false;
        }

    // correct also possible change in custom itemlist
    if (new == "custom")
        UsersCache::ChangeGroupCustoms (current_groups);

    UsersCache::current_groups = current_groups;
    return true;
}

/**
 * Change the value of custom user/group view
 * @param what "user" or "group"
 * @param new the new customs
 * @return success
 */
global define boolean ChangeCustoms(string what, list new) ``{

    if (what == "user")
    {
        list old = user_custom_sets;
        user_custom_sets = new;
        customs_modified = ChangeCurrentUsers ("custom");
        if (!customs_modified)
            user_custom_sets = old;
    }
    else
    {
        list old = group_custom_sets;
        group_custom_sets = new;
        customs_modified = ChangeCurrentGroups ("custom");
        if (!customs_modified)
            group_custom_sets = old;
    }

    return customs_modified;
}

/**
 * Change the structure with default values (/etc/defaults/useradd)
 * @param new_defaults new values
 * @param groupname the name of dew default group
 */
global define void SetDefaults (map new_defaults, string groupname)``{

    foreach (`key, `value, new_defaults, ``{
        if (value != "")
            useradd_defaults[key] = new_defaults[key]:"";
    });
    // remove last '/' from home entry (??)
    string home = useradd_defaults["home"]:"";
    if ( (findlastof( home, "/") +1) == size(home) )
        useradd_defaults["home"] = substring (home, 0, size(home)-1);

    default_gid = tointeger(useradd_defaults["group"]:sformat("%1",default_gid));
    default_groupname = groupname;
    SetDefaultValues(false);
    defaults_modified = true;
}

/**
 * Sets the time of last password change
 * @return current date string
 */
global define string LastChangeIsNow () ``{
    map out = SCR::Execute(.target.bash_output, "date +%s");
    string seconds_s = deletechars (out["stdout"]:"0", "\n");
    integer days = (tointeger(seconds_s))/ (60*60*24);
    return sformat("%1", days);
}

/**
 * Runs a script, preparing the data structures
 * @param type type of user/group set to load, can be "passwd", "nis", "ldap"
 * @return map with return value, stdout and stderr
 */
global define map RunPrepare(string type) ``{

    map ret = $[];

    if (type == "passwd")
    {
        ret = SCR::Execute(.target.bash_output, sformat(
        "%1/build_passwd_structures.pl %2 %3 %4 %5 %6", Directory::bindir,
        base_dir, tmpdir, max_uid ["system"]:500, max_gid["system"]:100, encoding));
    }
    else if (type == "nis")
    {
        ret = SCR::Execute(.target.bash_output, sformat(
        "%1/build_nis_structures.pl %2 %3", Directory::bindir, tmpdir,
        encoding));
    }
    return ret;
}


/**
 * Gets the source of user lists from /etc/nsswitch.conf
 * @return list of sources (e.g. [ "ldap", "files" ]
 */
global define list GetUsersSources() ``{

    string passwd_source = SCR::Read(.etc.nsswitch_conf.passwd);
    y2debug("read nsswitch.passwd: %1", passwd_source);

    return splitstring(passwd_source, " ");
}

/**
 * Calls the script which builds the widget contens for EditGroup dialog
 * @param userlist the list of users, having this group as additional
 * @param more_users the list of users, having this group as default group
 * @return the map with widget contents
 */
global define map BuildAdditional (string userlist, string more_users) ``{

    SCR::Write(.target.string, tmpdir + "/additional_userlist", userlist);
    SCR::Write(.target.string, tmpdir + "/additional_moreusers", more_users);
    // do not write local usernames for non-local groups
    string type = UsersCache::group_type;
    if (contains (["ldap", "nis"], type))
        SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
            $[ type : UsersCache::usernamelists[type]:[] ]);
    else
        SCR::Write(.target.ycp, tmpdir + "/additional_usernames",
            UsersCache::usernamelists);

    if (0 != SCR::Execute(.target.bash, sformat(
        "%1/build_additional_users.pl %2", Directory::bindir, tmpdir)))
        return $[];
    else
        return $[
            `ulist: SCR::Read(.target.ycp, tmpdir + "/additional_ulist.ycp"),
            `more:  SCR::Read(.target.ycp, tmpdir + "/additional_more.ycp")
        ];
}

global define map BuildAdditionalLDAP (list members, string more_users) ``{

    SCR::Write(.target.ycp, tmpdir + "/additional_userlist", members);
    SCR::Write(.target.string, tmpdir + "/additional_moreusers", more_users);

    SCR::Write(.target.ycp,tmpdir+"/additional_userdns",UsersCache::userdnlist);

    if (0 != SCR::Execute(.target.bash, sformat(
        "%1/build_additional_users.pl %2 ldap", Directory::bindir, tmpdir)))
        return $[];
    else
        return $[
            `ulist: SCR::Read(.target.ycp, tmpdir + "/additional_ulist.ycp"),
            `more:  SCR::Read(.target.ycp, tmpdir + "/additional_more.ycp")
        ];
}


/**
 * Re-read the settings, when back was pushed during installation
 * @return true
 */
global define boolean StartAgain() ``{

    y2debug ("reloading unmodified values from disk...");
    Read ( ``{return false;}, false);
    return true;
}

/**
 * Remove old config options - is used from inst_root.ycp
 */
global define void removeOldConf() ``{

	SCR::Write(.pam.all.password.pam_unix2, "-md5");
	SCR::Write(.pam.all.password.pam_pwcheck, "-md5");

	SCR::Write(.pam.login.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.login.password.pam_unix, "-md5");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.passwd.password.pam_unix, "-md5");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.sshd.password.pam_unix, "-md5");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-md5");
	SCR::Write(.pam.rlogin.password.pam_unix, "-md5");

	SCR::Write(.pam.all.password.pam_unix2, "-blowfish");
	SCR::Write(.pam.all.password.pam_pwcheck, "-blowfish");

	SCR::Write(.pam.login.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.login.password.pam_unix, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.passwd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.sshd.password.pam_unix, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_pwcheck, "-blowfish");
	SCR::Write(.pam.rlogin.password.pam_unix, "-blowfish");

}

/**
 * Crypt the given password according to method defined in encryptionMethod
 * @param pw unencrypted password
 * @param type user type (local/system/ldap)
 * @return encrypted password
 */
global define string CryptPassword (string pw, string type) ``{

    string method = encryptionMethod;
    if (type == "ldap")
    {
	method = ldap_encryption;
    }
    if (method == "clear")
        return pw;// no crypting
    else if (method == "md5" )
	return cryptmd5 (pw);
    else if (method == "blowfish" )
	return cryptblowfish (pw);
    else
	return crypt (pw);
}

/**
 * Crypt the root password according to method defined in encryptionMethod
 * This is called during install
 * @param pw unencrypted password
 * @return void
 */
global define void cryptRootPassword(string pw) ``{

    if (Mode::test) {
	return;
    }
    rootPassword = CryptPassword (pw, "system");
    return;
}


/**
 * Writes password of superuser
 * @return true on success
 */
global define boolean SetRootPassword() ``{

    return (SCR::Write(.target.passwd.root, rootPassword));
}

/**
 * Check if it is possible to write (=create homes) to given directory
 * @param dir the directory
 * @return empty string on success or name of directory which is not writable
 */
global define string IsDirWritable (string dir) ``{

    // maybe more directories in path don't exist
    while (SCR::Read(.target.stat, dir) == $[] && dir != "")
    {
        dir = substring (dir,0, findlastof(dir,"/"));
    }

    string tmpfile = dir + "/tmpfile";
    while (SCR::Execute (.target.bash, "/usr/bin/test -e " + tmpfile) == 0)
        tmpfile = tmpfile + "0";

    map out =  SCR::Execute (.target.bash_output, "/bin/touch " + tmpfile);
    if (out["exit"]:1 == 0)
    {
        SCR::Execute (.target.bash_output, "/bin/rm " + tmpfile);
        return "";
    }
    else
        return dir;
}

/**
 * Checks if the home directory is properly mounted (bug #20365)
 * @return if user wants to continue
 */
global define boolean CheckHomeMounted() ``{

    // check below fails for live eval
    if ( Mode::live_eval )
    {
	return true;
    }

    string mountpoint_in = "";

    // remove last "/"
    string default_home = GetDefaultHome(true, "local");
    string home = substring (default_home, 0, size(default_home) - 1);

    list fstab = SCR::Read(.etc.fstab);
    foreach (`line, fstab, ``{
        if (line["file"]:"" == home)
            mountpoint_in = "/etc/fstab";
    });

    if (SCR::Execute (.target.bash, "/usr/bin/test -e /etc/cryptotab") ==0)
    {
        list cryptotab = SCR::Read(.etc.cryptotab);
        foreach (`line, cryptotab, ``{
            if (line["mount"]:"" == home)
                mountpoint_in = "/etc/cryptotab";
        });
    }
    if (mountpoint_in != "")
    {
        boolean mounted = false;
        list mtab = SCR::Read(.etc.mtab);
        foreach (`line, mtab, ``{
            if (line["file"]:"" == home)
                mounted = true;
        });

        if (!mounted)
            return Popup::YesNo(
// Popup text: %1 is the directory (e.g. /home), %2 file name (e.g. /etc/fstab)
// For more info, look at the bug #20365
sformat(_("In %2, there is a mount point for the directory
%1, which is used as a default home directory for new
users, but this directory is not currently mounted.
If you add new users using the default values,
their home directories will be created in the current %1.
This can imply that these directories will not be accessible
after you mount correctly. Continue user configuration?
"), home, mountpoint_in));

    }
    return true;

}

/**
 * Creates DN of user. It is supposed there are yast (not LDAP)
 * keys in parameter map
 */
global define string CreateUserDN (map user) ``{

    string dn_attr = ldap_user_naming_attr;
    string user_attr = ldap2yast_user_attrs [dn_attr]:dn_attr;
    return sformat ("%1=%2,%3", dn_attr, user[user_attr]:"", ldap_user_base);
}

/**
 * Creates DN of group. It is supposed there are yast (not LDAP)
 * keys in parameter map
 */
global define string CreateGroupDN (map group) ``{

    string dn_attr = ldap_group_naming_attr;
    string group_attr = ldap2yast_group_attrs [dn_attr]:dn_attr;
    return sformat ("%1=%2,%3", dn_attr, group[group_attr]:"", ldap_group_base);
}


}// EOF
