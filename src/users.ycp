/**
 * small client to test the minimum features (e.g. command-line) of new
 * Users module
 */

{

textdomain "users";

y2milestone ("----------------------------------------");
y2milestone ("Users module started");

import "Users";
import "Mode";
import "CommandLine";
import "Ldap";

include "users/wizards.ycp";

string  start_dialog	= "summary";

any	ret		= nil;
integer arg		= 0;
list    possible_start_dialogs = ["user_add", "group_add", "summary", "user_inst_start", "users", "groups" ];
// do not pass arguments to cmd-line interpreter
boolean no_cmdline	= false;

while ( arg < size( WFM::Args() ) )
{
    any a = WFM::Args( arg );
    if ( is (a, string) && contains( possible_start_dialogs, a))
    {
	start_dialog = (string) WFM::Args( arg );
	no_cmdline		= true;
    }
    arg = arg + 1;
}

if (start_dialog == "users" || start_dialog == "groups")
{
    UsersCache::SetCurrentSummary (start_dialog);
    start_dialog	= "summary";
}

if (no_cmdline)
{
    y2milestone( "Starting with %1 - test mode: %2", start_dialog, Mode::test );
    Users::SetStartDialog (start_dialog);
    ret = UsersSequence (start_dialog);
    y2milestone("Users module finished with %1", ret);
    y2milestone("----------------------------------------");
    return ret;
}

// else parse arguments in cmdline
y2milestone( "Starting with arguments: %1", WFM::Args() );


// --------------------------------------------------------------------------
// --------------------------------- cmd-line handlers

define map<string,any> convert_keys (map<string,any> input) ``{

    map<string,any> ret	= $[];
    map keys = $[
	"username"	: "uid",
	"password"	: "userpassword",
	"home"		: "homedirectory",
	"shell"		: "loginshell",
	"fullname"	: "cn",
	"gid"		: "gidnumber",
	"uid"		: "uidnumber",
	"no_home"	: "create_home",
	"groups"	: "grouplist"
    ];
    foreach (string key, any value, input, ``{
	string new_key	= keys[key]:key;
	if (new_key == "create_home")
	    value = false;
	if (new_key == "gidnumber" && value != "")
	{
	    // check group existence!
	    if (!UsersCache::GIDExists (tointeger ((string)value)))
		return;
	}
	if (new_key == "grouplist" && is (value, string))
	{
	    value = listmap (string g, splitstring ((string)value,","),
		``($[g : 1]));
	}
	ret [ new_key ] = value;
    });
    return ret;
}

/**
 * List users
 * @return boolean false
 */
define boolean UsersListHandler (map<string,any> options ) ``{

    list<string> sets		= [];
    list<string> attributes	= [];
    map<string,any> amap	= $[];
    foreach (string key, any val, options, ``{
	if (contains (["local","system","ldap","nis"], key))
	    sets = add (sets, key);
	else
//	    attributes	= (list<string>) union (attributes, [type]);
	    amap [key]	= val;
    });
    if (sets == [])
	sets		= ["local"];
    attributes = maplist (string k,any val, convert_keys (amap), ``(k));
    if (!contains (attributes, "uid"))
	attributes	= prepend (attributes, "uid");
    foreach (string type, sets, ``{
	if (type == "nis" && Users::NISAvailable () && Users::NISNotRead ())
	{
	    Users::ReadNewSet ("nis");
	}
	if (type == "ldap" && Users::LDAPAvailable () && Users::LDAPNotRead ())
	{
	    Ldap::SetAnonymous (true);
	    Users::ReadNewSet ("ldap");
	}
	foreach (string uname, map user, (map<string,map>) Users::GetUsers ("uid",type), ``{
	    string out = "";
	    // FIXME when using convert_keys, the order is broken...
	    foreach (string attr, attributes, ``{
		if (haskey (user,attr))
		    out = out + user[attr]:"" + " ";
	    });
	    CommandLine::Print (out);
	});
    });
    return false; // do not call Write...
}

/**
 * Show one user information
 * @return boolean false
 */
define boolean UsersShowHandler (map options ) ``{

    map<string,any> user = $[];
    integer uid = tointeger (options ["uidnumber"]:options["uid"]:"-1");
    string username = options ["username"]:"";

    string type = options ["type"]:"local";

    if (type == "nis" && Users::NISAvailable () && Users::NISNotRead ())
    {
	Users::ReadNewSet ("nis");
    }
    if (type == "ldap" && Users::LDAPAvailable () && Users::LDAPNotRead ())
    {
	Ldap::SetAnonymous (true);
	Users::ReadNewSet ("ldap");
    }

    if (uid != -1)
    {
	user = Users::GetUser (uid, "");
    }
    else if (username != "")
    {
	user = Users::GetUserByName (username, "");
    }
    if (user == $[])
    {
	// error message
	CommandLine::Print (_("There is no such user."));
	return false;
    }

    string out = "";
    map keys = $[
	// label shown at command line (user attribute)
	"cn"		: _("Full Name:"),
	// label shown at command line (user attribute)
	"uid"		: _("Login Name:"),
	// label shown at command line (user attribute)
	"homedirectory"	: _("Home Directory:"),
	// label shown at command line (user attribute)
	"loginshell"	: _("Login Shell:"),
	// label shown at command line (user attribute)
	"uidnumber"	: _("UID:"),
	// label shown at command line (user attribute)
	"groupname"	: _("Default Group:"),
	// label shown at command line (user attribute)
	"grouplist"	: _("List of Groups:"),
    ];
    foreach (string key, any value, user, ``{
	key = keys[key]:"";
	if (key == "") return;
	string svalue = sformat ("%1", value);
	if (is (value, map))
	{
	    svalue = mergestring ((list<string>)
		maplist (string k, any v, (map<string,any>) value, ``(k)), ",");
	}
	CommandLine::Print (sformat ("%1\n\t%2", key, svalue));
    });

    return false; // do not call Write...
}

/**
 * Add user
 * @return boolean false
 */
define boolean UsersAddHandler (map <string, any> options ) ``{

    if (options["username"]:"" == "")
    {
	// error message
	CommandLine::Print (_("Enter a user name."));
	return false;
    }

    map <string, any> user = convert_keys (options);
    string type = user["type"]:"local";
    if (type == "ldap")
    {
	/*
	if (Users::LDAPAvailable() && Users::LDAPNotRead())
	{
	    if (Ldap::bind_pass == nil)
		// FIXME we cannot ask for password during cmdline...
		Ldap::SetBindPassword (Ldap::GetLDAPPassword (false));
	    Users::ReadNewSet ("ldap");
	}
	user["sn"] = user["uid"]:"";//FIXME
	*/
	return false;
    }

    Users::ResetCurrentUser ();
    string error = Users::AddUser (user);

    if (error != "")
    {
	CommandLine::Print (error);
	return false;
    }

    if (user["type"]:"local" == "ldap")
    {
	Users::SubstituteUserValues ();
    }

    error = Users::CheckUser ($[]);
    if (error != "")
    {
	CommandLine::Print (error);
	return false;
    }

    return Users::CommitUser ();
}

/**
 * Delete user
 * @return boolean false
 */
define boolean UsersDeleteHandler (map  <string, any>options ) ``{

    integer uid = tointeger (options ["uidnumber"]:options["uid"]:"-1");
    string username = options ["username"]:"";
    boolean delete_home = haskey (options, "delete_home");

    string type = options["type"]:"local";
    if (type == "ldap")
    {
	/*
	if (Users::LDAPAvailable() && Users::LDAPNotRead())
	{
	    if (Ldap::bind_pass == nil)
		// FIXME we cannot ask for password during cmdline...
		Ldap::SetBindPassword (Ldap::GetLDAPPassword (false));
	    Users::ReadNewSet ("ldap");
	}
	*/
	return false;
    }
    if (uid != -1)
    {
	Users::SelectUser (uid);
    }
    else if (username != "")
    {
	Users::SelectUserByName (username);
    }
    if (Users::GetCurrentUser () == $[])
    {
	// error message
	CommandLine::Print (_("There is no such user."));
	return false;
    }

    Users::DeleteUser (delete_home);
    Users::CommitUser ();
    return true;
}

define boolean UsersRead () ``{

    Users::SetGUI (false);
    return Users::Read () == "";
}

define boolean UsersWrite () ``{

    Users::SetGUI (false);
    return Users::Write () == "";
}

define boolean UsersGUI ()``{
    return (UsersSequence (start_dialog) == `next);
}


/* the command line description map */
map cmdline = $[
    "id"		: "users",
    // translators: command line help text for Users module
    "help"		: _("User configuration module."),
    "guihandler"	: UsersGUI,
    "initialize"	: UsersRead,
    "finish"		: UsersWrite,
    "actions"		: $[
	"list" :$[
	    "handler"	: UsersListHandler,
	    // translators: command line help text for list action
	    "help"	: _("List of available users"),
//FIXME print the possibility of options...
	    "options"   : ["non_strict"]
	],
	"show" :$[
	    "handler"	: UsersShowHandler,
	    // translators: command line help text for show action
	    "help"	: _("Show information of selected user")
	],
	"add" :$[
	    "handler"	: UsersAddHandler,
	    // translators: command line help text for ad action
	    "help"	: _("Add new user")
	],
	"delete" :$[
	    "handler"	: UsersDeleteHandler,
	    // translators: command line help text for delete action
	    "help"	: _("Delete an existing user. (Home directory is not removed.)")
	],
    ],
    "options"		: $[
	"local"	:$[
	    // translators: command line help text for list local option
	    "help"	: _("List of local users"),
	],
	"system"	:$[
	    // translators: command line help text for list system option
	    "help"	: _("List of system users"),
	],
	"ldap"		:$[
	    // translators: command line help text for list ldap option
	    "help"	: _("List of LDAP users"),
	],
	"nis"		:$[
	    // translators: command line help text for list nis option
	    "help"	: _("List of NIS users"),
	],
	"uid"		:$[
	    // translators: command line help text for uid option
	    "help"	: _("UID of the user"),
	    "type"	: "string"
	],
	"gid"		:$[
	    // translators: command line help text for add/gid option
	    "help"	: _("GID of user's default group"),
	    "type"	: "string"
	],
	"username"	:$[
	    // translators: command line help text for username option
	    "help"	: _("Login name of the user"),
	    "type"	: "string"
	],
	"cn"		:$[
	    // translators: command line help text for add option
	    "help"	: _("Full name of the user"),
	    "type"	: "string"
	],
	"shell"	:$[
	    // translators: command line help text for shell option
	    "help"	: _("Login shell of the user"),
	    "type"	: "string"
	],
	"home"	:$[
	    // translators: command line help text for home option
	    "help"	: _("Home directory of the user"),
	    "type"	: "string"
	],
	"no_home"	:$[
	    // translators: command line help text for add + create_home option
	    "help"	: _("Do not create home directory for new user"),
	],
	"delete_home"	:$[
	    // translators: command line help text for delete_home option
	    "help"	: _("Delete also user's home directory"),
	],
	"password"		:$[
	    // translators: command line help text for add option
	    "help"	: _("Password of the user"),
	    "type"	: "string"
	],
	"groups"	:$[
	    // translators: command line help text for home option
	    "help"	: _("List of groups of which the user is a member (separated by commas)"),
	    "type"	: "string"
	],
	"type"	:$[
	    // translators: command line help text for show option
	    "help"	: _("Type of the user (local/system/nis/ldap)"),
	    "type"	: "string"
	],
    ],
    "mappings"		: $[
	"list"	: [ "local", "system", "ldap", "nis", ],// + "custom"
	"show"  : [ "uid", "username", "type" ],
	"add"	: [ "username", "uid", "cn", "password", "home", "no_home", "shell", "gid", "groups", "type"],
	"delete": [ "username", "uid", "delete_home", "type" ],
//	"read"	: [ "nis", "ldap" ] TODO
// TODO set the default values ("useradd")
    ]
];

ret = CommandLine::Run (cmdline);

/* Finish */
y2milestone("Users module finished with %1", ret);
y2milestone("----------------------------------------");
return ret;

} //EOF
