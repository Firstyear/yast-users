<?xml version="1.0" encoding='ISO-8859-1'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
          "/usr/share/sgml/db41xml/docbookx.dtd"
[
<!ENTITY version "2.9.0">
<!ENTITY dx "DocBook-XML">

<!ENTITY distro "SUSE Linux Enterprise Server 9">
<!ENTITY comp "YaST Users component">

<!ENTITY date "November 2003">
]>

<book id="users">
  <bookinfo>
    <title>&comp;</title>
    <author>
       <firstname>Jiri</firstname>
       <surname>Suchomel</surname>
    </author>
    <copyright><year>2003</year><holder>SUSE Linux AG</holder></copyright>
    <legalnotice id="id_legal">
      <para>This is SUSE internal document.</para>
    </legalnotice>
    <abstract>
      <para>&comp; specification. Version &version; - &date;</para>
    </abstract>
  </bookinfo>
<chapter id="requirements"><title>Requirements</title>
  <section id="environment"><title>Environment</title>
    <section><title>Software</title>
      <para>
The product for this component is &distro; and products based on it.
      </para>
    </section>
    <section><title>Hardware</title>
      <para>
The computer hardware requirements is based on the requirements of &distro;.
No special hardware is required.
      </para>
    </section>
  </section>
  <section id="user"><title>User</title>
    <para>
The component could be operated by administrators of authentization servers 
who administer large amount of users and groups in NIS or LDAP database as well
as by home users who just want to set some attribute of one or two users in
their system.
    </para>
    <para>
The basic configuration does not require special knowledge of user management
techniques, but it could be useful when using some advanced component features
like setting user defaults or selecting authentization type.
    </para>
    <para>
In the special case of LDAP user management, basic knowledge of LDAP principals
is required.
    </para>
  </section>
  <section id="use_cases"><title>Use cases</title>
    <para>
For the computer with &distro; installed, &comp; is the standard tool for
configuration of users and groups.
    </para>
  </section>
  <section id="security"><title>Security</title>
    <para>
The component is expected to be run with superuser permissions as default. The
main reason are default permissions to main configuration files (/etc/passwd,
/etc/shadow etc.) which are writable by superuser only. By non-root user, the
component could be used for viewing current configuration, because configuration
files typically have the read permissions for all.
    </para>
    <para>
In case of LDAP users/groups management, the access of mentioned system files
is not neccessary so the only limitations for writing the configuation is the
knowledge of password to LDAP server and the current setting of that LDAP
server access rights.
    </para>
  </section>
  <section id="constraints"><title>Constraints</title>
    <para>
It is not possible to use &comp; multiple times; if done so, the state of
the last one regularly closed will be written.
    </para>
  </section>
</chapter>

<chapter id="design"><title>Design</title>
  <section id="components"><title>Components</title>
    <para>
    The Users configuration will consist from the following components:
      <itemizedlist>
	<listitem><para>
YaST component for Users configuration (required)
	</para></listitem>
	<listitem><para>
YaST component for Security configuration (required via RPM dependency)
	</para></listitem>
	<listitem><para>
YaST component for PAM configuration (required via RPM dependency)
	</para></listitem>
	<listitem><para>
cracklib package (required via RPM dependency)
	</para></listitem>
	<listitem><para>
YaST component for LDAP configuration (optional) - used for managing LDAP
users and groups
	</para></listitem>
      </itemizedlist>
Following (optional) components are used for Authentication Management:
      <itemizedlist>
	<listitem><para>
YaST component for NIS/NIS+ client configuration
	</para></listitem>
	<listitem><para>
YaST component for LDAP client configuration
	</para></listitem>
	<listitem><para>
YaST component for Samba client configuration
	</para></listitem>
	<listitem><para>
YaST component for Kerberos client configuration
	</para></listitem>
      </itemizedlist>
    </para>
  </section>
  <section id="functions"><title>Functionality</title>
    <section><title>User management</title>
      <note><title>Priority</title><para>Must have</para></note>
      <para>
User management means following functions:
	<itemizedlist>
	  <listitem><para>
Add new user.
	  </para></listitem>
	  <listitem><para>
Delete existing user.
	  </para></listitem>
	  <listitem><para>
Edit existing user attributes.
	  </para></listitem>
	  <listitem><para>
Enable / Disable user.
	  </para></listitem>
	</itemizedlist>

User management allows managing different types of users:
	<itemizedlist>
	  <listitem><para>
System users: users defined in /etc/passwd with UID up to SYSTEM_UID_MAX (this
variable is defined in /etc/login.defs) and the user "nobody".
	  </para></listitem>
	  <listitem><para>
Local users: all other users defined in local /etc/passwd.
	  </para></listitem>
	  <listitem><para>
NIS users: users defined on some NIS server. They are treated as "NIS users" 
only on client machines; on server they are usually regular system/local users.
	  </para></listitem>
	  <listitem><para>
LDAP users: users defined in the LDAP directory structure. It is not important
if the &comp; is run on server or client, the user management is available in
both cases.
	  </para></listitem>
	</itemizedlist>

Not all functions mentioned above could be available for each type of user
in some situations, for example deleting NIS users is not possible from machine
which is only the NIS client.
      </para>
      <section><title>Adding new user</title>
	<para>
(The description in this section is refered to local and system users;
corresponding attribute names for LDAP users are mentioned in parentheses.)
	</para>
	<para>
For creating new user it is neccessary to enter the required data, uniquely
describing new user:
	  <itemizedlist>
	    <listitem><para>
User Name ('uid' attribute)
	    </para></listitem>
	    <listitem><para>
User Password ('userPassword' attribute)
	    </para></listitem>
	  </itemizedlist>
Other attributes are optional (GECOS) or also required, but their value is
proposed by &comp;. For local and system users, following values are saved in
/etc/passwd file.
	  <itemizedlist>
	    <listitem><para>
UID	('uidNumber' attribute)
	    </para></listitem>
	    <listitem><para>
Gecos - fullname and other user attributes, shown e.g. by finger ('sn' attribute)
	    </para></listitem>
	    <listitem><para>
Default group	('gidNumber' attribute)
	    </para></listitem>
	    <listitem><para>
Home directory ('homeDirectory' attribute)
	    </para></listitem>
	    <listitem><para>
Login Shell ('loginShell' attribute)
	    </para></listitem>
	  </itemizedlist>
	</para>
	<para>
For each user there is a possibility to choose the groups this user is member
of - but internaly, such setting is an attribute of these groups, not of the
user. In local case, each group has the list of its members saved in /etc/group
file; for LDAP, groups have lists of 'UniqueMember' atrtributes, refering to
DN's of members.
	</para>
	<para>
And the last group of settings are the "shadow" attributes - saved in
/etc/shadow file for local and system users:
	  <itemizedlist>
	    <listitem><para>
Inactive value ('shadowInactive' attribute)
	    </para></listitem>
	    <listitem><para>
Expiration date ('shadowExpire')
	    </para></listitem>
	    <listitem><para>
Warning before expiration ('shadowWarning')
	    </para></listitem>
	    <listitem><para>
Minimum age of password before change ('shadowMin')
	    </para></listitem>
	    <listitem><para>
Maximum age of password ('shadowMax')
	    </para></listitem>
	    <listitem><para>
Date of last pasword change ('shadowLastChange')
	    </para></listitem>
	    <listitem><para>
Shadow flag ('shadowFlag')
	    </para></listitem>
	  </itemizedlist>
	</para>
       <section id="ldap_user"><title>Adding LDAP user</title>
	<para>
Additionally to attributes described above, LDAP users could have plenty of
special attributes, defined in Object Classes of LDAP users template. &comp;
should alllow editing of all these attributes (these are for example 'cn', 'o',
'homePhone').
	</para>
	<para>
Currently, the default values for Object Class of new LDAP user are:
	  <itemizedlist>
	    <listitem><para>
'posixAccount'
	    </para></listitem>
	    <listitem><para>
'shadowAccount'
	    </para></listitem>
	    <listitem><para>
'inetOrgPerson'
	    </para></listitem>
	  </itemizedlist>
	</para>
       </section>
       <section id="encr_types"><title>Password encryption types</title>
	<para>
The User Password can be encrypted in various way - these values of encryption 
can be used for local and system users:
	<itemizedlist>
	  <listitem><para>
DES (crypt)
	  </para></listitem>
	  <listitem><para>
MD5
	  </para></listitem>
	  <listitem><para>
Blowfish
	  </para></listitem>
	</itemizedlist>
The value of encryption type is saved in /etc/security/pam_pwcheck.conf file; 
&comp; uses YaST Security component to access the encryption setting.
	</para>
	<para>
For LDAP users, the default value of encryption type is set in YaST LDAP client
component. But there is also a possibility to set the encryption type
for each LDAP user differently. The values used for encryptions are:
	<itemizedlist>
	  <listitem><para>
CRYPT
	  </para></listitem>
	  <listitem><para>
MD5
	  </para></listitem>
	  <listitem><para>
SMD5
	  </para></listitem>
	  <listitem><para>
SHA
	  </para></listitem>
	  <listitem><para>
SSHA
	  </para></listitem>
	  <listitem><para>
PLAIN (plain text, no crypting)
	  </para></listitem>
	</itemizedlist>
	</para>
       </section>
       <section id="sles_attrs"><title>Additional attributes for server products</title>
	<para>
For advanced User Configuration (e.g. on SLOX), more user attributes has to be
set. Some of them are just more LDAP attributes extending the set of the basic
ones defined
by the default Object Classes (<xref linkend="autologin"/>). &comp; has to take
care of the filling the default values for such attributes when adding new user.
	</para>
	<para>
Here are some examples:
	<itemizedlist>
	  <listitem><para>
User is allowed to access dyce-messanger 
	  </para></listitem>
	  <listitem><para>
User is allowed to use the groupware
	  </para></listitem>
	  <listitem><para>
Special groupware attributes in the user entry
	  </para></listitem>
	  <listitem><para>
User is allowed to write in a global addressbook
	  </para></listitem>
	  <listitem><para>
The certificate (X.509 certificate) of the user
	  </para></listitem>
	  <listitem><para>
User has a mailbox and is allowed to receive mail
	  </para></listitem>
	  <listitem><para>
User is also a samba user (special samba attributes)
	  </para></listitem>
	</itemizedlist>
	</para>
       </section>
      </section>
      <section><title>Editing existing user</title>
	<para>
All attributes of user mentioned in previous section should be configurable.
	</para>
        <section><title>LDAP user: edit DN</title>
	<note><title>Priority</title><para>Optional</para></note>
	<para>
DN is the place where each LDAP items (user in our case) is located in LDAP
directory structure. It would be very helpful if &comp; could enable direct editing of 'DN' attribute of a LDAP user; in other words - moving the user in the
LDAP tree.
	</para>
       </section>
      </section>
      <section><title>Disable and Enable user</title>
	<para>
"Disabling user" means preventing user to login to the system, while "Enabling"
allows him to login again. Technically, this could mean several things according
to the type of user and the product &comp; is running at. These actions should
be taken for LDAP users on SLOX-based products:
	<itemizedlist>
	    <listitem><para>
For samba we set a "D" into "acctFlags" attribute,
	    </para></listitem>
	    <listitem><para>
set "shadowExpire" to "0",
	    </para></listitem>
	    <listitem><para>
set "mailenabled" to "550 User temporary disabled"
	    </para></listitem>
	    <listitem><para>
set a "!" before the hash-value in the "userpassword" and
	    </para></listitem>
	    <listitem><para>
set a "DEACTIVATED:" before the value in "relayclientcert".
	    </para></listitem>
	</itemizedlist>

For local/system users it is sufficient to set shadowExpire value and add "!"
to /etc/shadow file.
	</para>
      </section>
      <section><title>Deleting existing user</title>
	<para>
During deleting user, there is also possibility to delete its home directory.
Special case is LDAP user management, where home directories are probably stored
on special server and cannot be deleted from client.
	</para>
      </section>
    </section>
    <section><title>Group management</title>
      <note><title>Priority</title><para>Must have</para></note>
      <para>
Group management is quite similar like User management. It has these functions:
	<itemizedlist>
	  <listitem><para>
Add new group.
	  </para></listitem>
	  <listitem><para>
Delete existing group.
	  </para></listitem>
	  <listitem><para>
Edit existing groups attributes.
	  </para></listitem>
	</itemizedlist>
As with user, &comp; should manage groups of various types (system, local, NIS,
LDAP).
      </para>
      <para>
These are ususal group attributes:
	<itemizedlist>
	  <listitem><para>
Group name ('cn' attribute for LDAP)
	  </para></listitem>
	  <listitem><para>
GID 	('gidNumber' attribute)
	  </para></listitem>
	  <listitem><para>
Members	('uniqueMember' attribute)
	  </para></listitem>
	  <listitem><para>
Password ('userPassword' attribute)
	  </para></listitem>
	</itemizedlist>
      </para>
      <para>
Main feature of group management is configuring the user membership in groups.
This can create some relationships between various types: local groups can have
non-local (NIS, LDAP) members.
      </para>
      <section><title>LDAP groups</title>
      <para>
LDAP groups could have more special attributes to configure - currently used
default object classes for groups are:
	<itemizedlist>
	  <listitem><para>
'posixGroup'
	  </para></listitem>
	  <listitem><para>
'groupOfUniqueNames'.
	  </para></listitem>
	</itemizedlist>
If the LDAP group has no member, it cannot has object class 'groupOfUniqueNames'
 - it will use 'namedObject' object class in such case.
      </para>
      </section>
    </section>
    <section><title>Configuration of global settings</title>
      <para>
&comp; enables configuring some global settings, affecting the system behaviour
with users.
      </para>
      <section><title>New user default settings</title>
	<para>
For system and local users, some default values can be used when new user is
added. These values are saved in the /etc/defaults/useradd file.
The file contains these items:
	<itemizedlist>
	  <listitem><para>
	    default group
	  </para></listitem>
	  <listitem><para>
	    default login shell
	  </para></listitem>
	  <listitem><para>
	    default expiration date
	  </para></listitem>
	  <listitem><para>
	    default path to user's home directories
	  </para></listitem>
	  <listitem><para>
	    skeleton directory for the new home directories
	  </para></listitem>
	  <listitem><para>
	    default additional groups
	  </para></listitem>
	  <listitem><para>
	    default 'inactive' value (days of inactivity after a password has expired before the account is locked)
	  </para></listitem>
	</itemizedlist>
	</para>
      </section>
      <section><title>LDAP default settings</title>
	<para>
For LDAP users and groups, function for configuration the default values is
provided by YaST LDAP client module.
	</para>
      </section>
      <section id="autologin"><title>Autologin</title>
	<para>
'Autologin' means that it could be set for some user to log in the system 
automatically without entering the password. It is the feature of login manager
(KDM), which must be installed. &comp; enables configuring the status of this
KDM feature for the selected user.
	</para>
      </section>
    </section>
    <section id="auth_mngmt"><title>Authentication management</title>
      <note><title>Priority</title><para>Should have</para></note>
      <para>
&comp; should provide summary of available authentication types and the
possibility to change it. For configuration of each authentication type there
is one responsible YaST component, which could be called from &comp;.
To show the summary of current authentication state, &comp; uses
the function ShortSummary(), which is defined in all these components: 
	<itemizedlist>
	  <listitem><para>
LDAP client: summary contains name of LDAP server, base DN and state of LDAP authentication (on/off)
	  </para></listitem>
	  <listitem><para>
Kerberos client: summary contains server address, default domain, default realm and authentication state
	  </para></listitem>
	  <listitem><para>
NIS client: summary contains list of servers, NIS domain and client state
	  </para></listitem>
	  <listitem><para>
NIS+ client: summary contains NIS+ server address, domain and client state
	  </para></listitem>
	  <listitem><para>
Samba client: summary contains work group name and winbind authentication state
	  </para></listitem>
	</itemizedlist>
The configuration areas of above components could be very different - while
Kerberos client is used just to set the user authentication via some Kerberos
server, other clients could define both the authentication type and the set of
users used on our system. For example, enabling NIS client can mean
"using the set
of users defined on NIS server" and "authenticate the users against the
passwords saved on NIS server". The methods can be combined - one could for
example use LDAP set of users together with the local sets defined in
/etc/passwd and authenticate all of them with the use of Kerberos.
      </para>
    </section>
  </section>
  <section id="ui"><title>User interfaces</title>
   <section><title>Dialog-based interfaces</title>
    <para>
&comp; will support Qt-based and NCurses-based user interfaces.
    </para>
    <section><title>Summary dialog</title>
      <para>
This dialog provides the view of current user (group) set and offers some
actions to change the configuration. The dialog consists from:

	<itemizedlist>
	  <listitem><para>
Set of radio buttons (set user view or group view)
	  </para></listitem>
	  <listitem><para>
Table with current list of users (groups) together with Add, Edit and Delete
buttons. Columns of table contains:
	    <itemizedlist>
	      <listitem><para>
	      User/Group name
	      </para></listitem>
	      <listitem><para>
	      Full User name (user table only)
	      </para></listitem>
	      <listitem><para>
	      User/Group ID (UID/GID)
	      </para></listitem>
	      <listitem><para>
	      List of users/List of groups
	      </para></listitem>
	    </itemizedlist>
	  </para></listitem>
	  <listitem><para>
Set Filter menubutton, which enables choosing the set of users (groups) to be
displayed in the table.
	  </para></listitem>
	  <listitem><para>
Customize Filter button, which opens the Customize popup for configuring the
custom view (e.g. system + local). This setting is saved to configuration file.
	  </para></listitem>
	  <listitem><para>
Expert options menubutton, providing extended features: 
	    <itemizedlist>
	      <listitem><para>
Defaults For New Users
	      </para></listitem>
	      <listitem><para>
Pasword Encryption
	      </para></listitem>
	      <listitem><para>
Authetication and User Sources 
	      </para></listitem>
	      <listitem><para>
LDAP Search Filter setting (entry is only shown when LDAP source is available) 
	      </para></listitem>
	      <listitem><para>
Login Settings (invokes Login Settings popup)
	      </para></listitem>
	    </itemizedlist>
	  </para></listitem>
	</itemizedlist>
      </para>
      <para>
      </para>
    </section>
    <section><title>Defaults Dialog</title>
      <para>
Here the default settings for new users could be set. Dialog consists from
following parts:
	<itemizedlist>
	  <listitem><para>
Default Group combo box
	  </para></listitem>
	  <listitem><para>
Secondary Groups text entry
	  </para></listitem>
	  <listitem><para>
Default Shell text entry
	  </para></listitem>
	  <listitem><para>
Path Prefix for Home directory text entry, together with Browse button
	  </para></listitem>
	  <listitem><para>
Skeleton for Home Directory text entry, together with Browse button
	  </para></listitem>
	  <listitem><para>
Default Expiration Date texte entry
	  </para></listitem>
	  <listitem><para>
Login usability after Pasword Expiration entry
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section id="encryption_popup"><title>Encryption Popup</title>
      <para>
Use this small popup to set password encryption type for all local and
system users. The encryption types are defined in <xref linkend="encr_types"/>.
      </para>
    </section>
    <section><title>Authetication and User Sources</title>
      <para>
There is a list of various YaST components used for configuration the
authentization types and sources of user data, see <xref linkend="auth_mngmt"/>.
This dialog constists of
	<itemizedlist>
	  <listitem><para>
Richtext area with the summary of all available authentization components
	  </para></listitem>
	  <listitem><para>
Configure menubutton, allowing running appropriate component to change
configuration
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section><title>Login Settings Popup</title>
      <para>
Here is the place for enabling or disabling autologin feature, described in
<xref linkend="autologin"/>. The popup
has:
	<itemizedlist>
	  <listitem><para>
Enable Autologin checkbox, together with the combobox for selecting user for
which the autologin will be applied.
	  </para></listitem>
	  <listitem><para>
Enable login without passwords checkbox
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section><title>User Add/Edit dialog</title>
      <para>
Dialog envoked by Add or Edit button from Summary dialog. It contains from:
	<itemizedlist>
	  <listitem><para>
Full name textentry
	  </para></listitem>
	  <listitem><para>
User name textentry
	  </para></listitem>
	  <listitem><para>
Propose button: proposes username from the given value of fullname
	  </para></listitem>
	  <listitem><para>
Password entry and Verify Password entry
	  </para></listitem>
	  <listitem><para>
Details Button, which leads to User Details dialog
	  </para></listitem>
	  <listitem><para>
Password Settings Button, which leads to Password Settings dialog
	  </para></listitem>
	</itemizedlist>
For LDAP users, instead of Full name textentry, two entries will be shown:
First and Last name.
      </para>
      <para>
During installation, this dialog is shown for first instead of ususal Summary
dialog and it is a bit richer - it contains also:
	<itemizedlist>
	  <listitem><para>
Receive System Mail checkbox
	  </para></listitem>
	  <listitem><para>
Auto Login checkbox
	  </para></listitem>
	  <listitem><para>
User Management button - this leads to standard Summary dialog
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section><title>User Details dialog</title>
      <para>
Dialog for more user settings. It consists from:
	<itemizedlist>
	  <listitem><para>
UID textentry
	  </para></listitem>
	  <listitem><para>
Home directory text entry, together with Browse button
	  </para></listitem>
	  <listitem><para>
Additional User Information entry (together with fullname it creates GECOS)
	  </para></listitem>
	  <listitem><para>
Login shell combo box
	  </para></listitem>
	  <listitem><para>
Default group combo box
	  </para></listitem>
	  <listitem><para>
Additional groups list
	  </para></listitem>
	</itemizedlist>
For LDAP users, there could be much more other settings available - see 
<xref linkend="ldap_addit_u"/>.
      </para>
    </section>
    <section><title>User Password Settings dialog</title>
      <para>
Dialog for even more user settings, the password related ones. Values of these
attributes could be set here in text entries:
	<itemizedlist>
	  <listitem><para>
Days before password expiration to issue warning
	  </para></listitem>
	  <listitem><para>
Days after password expiration is login usable
	  </para></listitem>
	  <listitem><para>
Maximum days for the same password
	  </para></listitem>
	  <listitem><para>
Miniimum days for the same password
	  </para></listitem>
	  <listitem><para>
Expiration date
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section><title>Group Add/Edit dialog</title>
      <para>
Dialog envoked by Add or Edit button from Summary dialog. It contains from:
	<itemizedlist>
	  <listitem><para>
Group name textentry
	  </para></listitem>
	  <listitem><para>
Group ID textentry
	  </para></listitem>
	  <listitem><para>
Password entry and Verify Password entry
	  </para></listitem>
	  <listitem><para>
List of Members of this group
	  </para></listitem>
	  <listitem><para>
List of users, for which this group is the default group
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section><title>LDAP filter popup</title>
      <para>
This popup is envoked by entry in "Expert Options" menubutton from Summary dialog. It is used for setting filter for LDAP users/groups which are to be loaded from LDAP server (can be defined some smaller group when it is not necessary to read all of them). Consists from:
	<itemizedlist>
	  <listitem><para>
User Filter textentry
	  </para></listitem>
	  <listitem><para>
Group Filter textentry
	  </para></listitem>
	  <listitem><para>
Help button - shows help to this popup, together with example of filters
	  </para></listitem>
	  <listitem><para>
From Server button - gets the default filters which are stored in LDAP directory
(the defaults are defined in YaST LDAP client component)
	  </para></listitem>
	</itemizedlist>
      </para>
    </section>
    <section id ="ldap_addit_u"><title>Additional LDAP settings: users</title>
      <para>
Because LDAP users could have many attributes which names are not known to
&comp; and have to be loaded dynamically, this dialog shows all the attributes
which were not configured in previous dialogs. It consists from the table
with the pairs "Attribute" - "Value" and the Edit button.
      </para>
      <para>
The special case is the password encryption for LDAP users. It is not set in 
Encryption Popup (<xref linkend="encryption_popup"/>) as for local users,
but the default encryption type is set in YaST LDAP client component. In this
dialog (Additional LDAP) there should be possibility to set the encryption type
different from the default value. The values used for encryption are defined
in <xref linkend="encr_types"/>.
      </para>
    </section>
    <section><title>Additional LDAP settings: groups</title>
      <para>
Because LDAP groups could have many attributes which names are not known to
&comp; and have to be loaded dynamically, this dialog shows all the attributes
which were not configured in previous dialogs. It consists from the table
with the pairs "Attribute" - "Value" and the Edit button.
      </para>
    </section>
   </section>
   <section id="command_line"><title>Command-line interface</title>
    <para>
Most of the functions of the component must be also editable via the command
line interface of YaST. It may look as useless, because &comp; running from
command line won't have more features than standard user management commands
like useradd or usermodify and it surely cannot be faster. The main feature of
YaST commandline here is the "interactive mode", where one can call several
modification commands and write (or discard) all the changes at the end.
    </para>
    <para>
Every command has the format:
    </para>
    <para>
      <computeroutput>
yast2 users &lt;command&gt; [&lt;option&gt;=&lt;value&gt; [...]]]
      </computeroutput>
    </para>
    <para>
or:
    </para>
    <para>
      <computeroutput>
yast2 groups &lt;command&gt; [&lt;option&gt;=&lt;value&gt; [...]]
      </computeroutput>
    </para>
    <para>
depending on the object (user or group) which we want to operate with.
    </para>
    <para>
Currently all commands apply only for users defined in local /etc/passwd file
("system" and "local" ones). It will be useful to extend the commands also for
the use with LDAP users and groups.
    </para>
    <section><title>Add new user</title>
      <para>
	<computeroutput>
add name=&lt;user_name&gt; [uid=&lt;UID&gt;] [cn=&lt;full_name&gt;]
[password=&lt;password&gt;] [home=&lt;home_directory&gt;]
[group=&lt;default_group&gt;] [groups=&lt;additional_groups&gt;]
[addit=&lt;additional_info_to_gecos&gt;] [shell=&lt;login_shell&gt;]
[last_change=&lt;shadow_last_change&gt;] [expire=&lt;shadow_expire&gt;]
[inact=&lt;shadow_inactive&gt;] [max=&lt;shadow_max&gt;]
[min=&lt;shadow_min&gt;] [warn=&lt;shadow_warning&gt;] [nohome]
	</computeroutput>
      </para>
      <para>
Add new user. Use the given attributes or generate defaults when not given on
command line. Parameter "nohome" tells that home directory should not be
created (it is created in default case).
      </para>
    </section>
    <section><title>Edit user parameters</title>
      <para>
	<computeroutput>
edit name=&lt;user_name&gt;|uid=&lt;UID&gt; [uid=&lt;UID&gt;]
[name=&lt;user_name&gt;] [cn=&lt;full_name&gt;] [password=&lt;password&gt;]
[home=&lt;home_directory&gt;] [group=&lt;default_group&gt;]
[groups=&lt;additional_groups&gt;] [addit=&lt;additional_info_to_gecos&gt;]
[shell=&lt;login_shell&gt;] [last_change=&lt;shadow_last_change&gt;]
[expire=&lt;shadow_expire&gt;] [inact=&lt;shadow_inactive&gt;]
[max=&lt;shadow_max&gt;] [min=&lt;shadow_min&gt;] [warn=&lt;shadow_warning&gt;]
	</computeroutput>
      </para>
      <para>
Edit parameters of given user. User can be identified either by username or by
UID, one type of identification is required. Optional parameters set the new
values of given attributes.
      </para>
    </section>
    <section><title>Delete user</title>
      <para>
	<computeroutput>
delete name=&lt;user_name&gt;|uid=&lt;UID&gt; [deletehome]
	</computeroutput>
      </para>
      <para>
Delete user, which is identified either by username or by UID. Parameter
"deletehome" tells that home directory should be deleted also (when omitted,
no removal is done).
      </para>
    </section>
    <section><title>List users</title>
      <para>
	<computeroutput>
list [local] [system] [ldap] [nis]
	</computeroutput>
      </para>
      <para>
Print the list of users of given type. Without any parameters, list all
available users.
      </para>
    </section>
    <section><title>Show user info</title>
      <para>
	<computeroutput>
show name=&lt;user_name&gt;|uid=&lt;UID&gt; [type=&lt;user_type&gt;]
	</computeroutput>
      </para>
      <para>
Show the information of given user. Parameter "type" specifies user's type,
because UIDs and usernames don't have to be unique among all types. 
      </para>
    </section>
    <section><title>Add new group</title>
      <para>
	<computeroutput>
add name=&lt;group_name&gt; [gid=&lt;GID&gt;] [password=&lt;password&gt;]
[users=&lt;members_list&gt;]
	</computeroutput>
      </para>
      <para>
Add new group.
      </para>
    </section>
    <section><title>Edit group parameters</title>
      <para>
	<computeroutput>
edit name=&lt;group_name&gt;|gid=&lt;GID&gt; [gid=&lt;GID&gt;]
[name=&lt;group_name&gt;] [users=&lt;members_list&gt;]
	</computeroutput>
      </para>
      <para>
Edit parameters of existing group.
      </para>
    </section>
    <section><title>Delete group</title>
      <para>
	<computeroutput>
delete name=&lt;group_name&gt;|gid=&lt;GID&gt;
	</computeroutput>
      </para>
      <para>
Delete group, which is identified either by name or by GID.
      </para>
    </section>
    <section><title>List groups</title>
      <para>
	<computeroutput>
list [local] [system] [ldap] [nis]
	</computeroutput>
      </para>
      <para>
Print the list of groups of given type. Without any parameters, list all
available ones.
      </para>
    </section>
    <section><title>Show group info</title>
      <para>
	<computeroutput>
show name=&lt;group_name&gt;|gid=&lt;GID&gt; [type=&lt;group_type&gt;]
	</computeroutput>
      </para>
      <para>
Show the information of given group. Parameter "type" specifies group's type,
because GIDs and groupnames don't have to be unique among all types. 
      </para>
    </section>
    <section><title>Examples</title>
      <itemizedlist>
	<listitem><para><computeroutput>
yast2 groups list local ldap
	</computeroutput>
	</para><para>
Prints list of local and LDAP groups - names, GID's and group members.
	</para></listitem>
	<listitem><para><computeroutput>
yast2 users add name=hh home=/local/home/hh cn=HH password=hhhhh
	</computeroutput>
	</para><para>
Adds new user with non-default home directory.
	</para></listitem>
	<listitem><para><computeroutput>
yast2 groups edit name=mygroup users=hh,gg,qq
	</computeroutput>
	</para><para>
Changes the list of members of group "mygroup".
	</para></listitem>
	<listitem><para><computeroutput>
yast2 groups edit name=mygroup name=ourgroup
	</computeroutput>
	</para><para>
Renames the group "mygroup".
	</para></listitem>
      </itemizedlist>
    </section>
   </section>
  </section>
  <section id="interaction"><title>Interaction with the rest of YaST</title>
    <section id="inter_required"><title>Required functionality</title>
      <section><title>Security</title>
	<para>
The &comp; will use YaST Security component to read and possibly set some
of its settings e.g. password encryption type or UID limits; these informations
are stored in local configuration files such as /etc/login.defs or
/etc/security/pam_pwcheck.conf and are applied only for local and system users.
	</para>
      </section>
      <section><title>LDAP, LDAP client</title>
	<para>
The &comp; needs to use YaST LDAP and YaST LDAP client componets to enable work
with LDAP users and groups.
	</para>
	<para>
YaST LDAP client component is used for reading general configuration of an LDAP
client and some default values and templates for new users and groups.
	</para>
	<para>
YaST LDAP component is used for direct operation with the content of LDAP
direcory (mostly, reading and writing users and groups).
	</para>
      </section>
      <section><title>NIS client</title>
	<para>
YaST NIS client is necessary for the information of NIS status (<xref linkend="auth_mngmt"/>)
as well as for getting lists of NIS users and groups.
	</para>
      </section>
      <section><title>NIS+ client</title>
	<para>
YaST NIS+ client is necessary for managing the NIS+ configuration from &comp;
(<xref linkend="auth_mngmt"/>).
	</para>
      </section>
      <section><title>Kerberos client</title>
	<para>
YaST Kerberos client is necessary for managing the Kerberos configuration
from &comp; (<xref linkend="auth_mngmt"/>).
	</para>
      </section>
      <section><title>Samba client</title>
	<para>
YaST Samba client is necessary for managing the SMB configuration from &comp; 
(<xref linkend="auth_mngmt"/>).
	</para>
      </section>
    </section>
    <section id="inter_provided"><title>Provided functionality</title>
      <section><title>List of available users</title>
	<para>
Some of YaST componets (currently Phone-services and Mail) need to have list of users. This should be provided by accessing
<computeroutput>UsersCache::usernames</computeroutput> structure.
Before, appropriate read function (at least
<computeroutput>Users::Read ()</computeroutput>)
must be called. 
	</para>
      </section>
      <section><title>Add/Edit/Remove user/group</title>
	<para>
&comp; will provide an interface for adding new users. Currently this feature
could be used by YaST Nis client component which needs to add special lines at
the end of system config files (/etc/passwd) when the service is enabled.
	</para>
	<para>
If some YaST component wants to work with a user, it should use this
sequence of functions:
    <itemizedlist>
      <listitem><para>
Users::Read
      </para></listitem>
      <listitem><para>
Users::SelectUser (neccessary for editing or deleting)
      </para></listitem>
      <listitem><para>
Users::AddUser, Users::EditUser, Users::DeleteUser (according to the desired action)
      </para></listitem>
      <listitem><para>
Users::CheckUser
      </para></listitem>
      <listitem><para>
Users::CommitUser
      </para></listitem>
      <listitem><para>
Users::Write
      </para></listitem>
    </itemizedlist>
&comp; has to ensure the correct behaviour when these functions are called
externaly (e.g. from YaST Nis client module) while Users component is curretly
running (see <xref linkend="constraints"/>).
	</para>
      </section>
    </section>
  </section>
</chapter>

<chapter id="implementation"><title>Implementation</title>
  <para>
The &comp; will consist from following subcomponents:
    <itemizedlist>
      <listitem><para>
Users module
      </para></listitem>
      <listitem><para>
UsersCache module, for the cache (UI-related) functions
      </para></listitem>
      <listitem><para>
SCR agent for reading and writing the main user/group config files (e.g. /etc/passwd)
      </para></listitem>
      <listitem><para>
SCR agent for reading and writing /etc/default/useradd config file
      </para></listitem>
      <listitem><para>
SCR agent for testing the password strength ("agent-crack")
      </para></listitem>
      <listitem><para>
SCR agent for testing if the UIDs/usernames are unique ("agent-uid")
      </para></listitem>
      <listitem><para>
User interfaces
      </para></listitem>
    </itemizedlist>
  </para>
  <section><title>Users module</title>
    <para>
The Users module has the following tasks:
      <itemizedlist>
	<listitem><para>Read and write the settings using agents</para></listitem>
	<listitem><para>Store the settings in module variables</para></listitem>
	<listitem><para>Provide functions required by other components</para></listitem>
	<listitem><para>Provide functions tightly bound to the data it stores</para></listitem>
	<listitem><para>Provide other functions required by user interface</para></listitem>
      </itemizedlist>
    </para>
    <section><title>Functions</title>
      <section id="func_general"><title>General</title>
	<itemizedlist>
	  <listitem><para><computeroutput>
global define boolean Read ();
	  </computeroutput>
	  </para><para>
reads the settings. Returns true on success.
	    </para>
	  </listitem>
	  <listitem><para><computeroutput>
global define boolean Write ();
	  </computeroutput>
	  </para><para>
writes the settings. Returns true on success.
	  </para></listitem>
	  <listitem><para><computeroutput>
global define map Export ();
	  </computeroutput>
	  </para><para>
exports the settings. Returns export map. Used mostly for autoinstallation.
	  </para></listitem>
	  <listitem><para><computeroutput>
global define void Import (map settings);
	  </computeroutput>
	  </para><para>
imports the settings. Needs export map as argument. Used mostly for autoinstallation.
	  </para></listitem>
	  <listitem><para><computeroutput>
global define string Summary ();
	  </computeroutput>
	  </para><para>
returns summary of the module (for autoinstallation).
	  </para></listitem>
	</itemizedlist>
      </section>
      <section><title>Global</title>
	<para>
Additionally to functions described in <xref linkend="func_general"/>,
following functions will be available:
	  <itemizedlist>
	    <listitem><para><computeroutput>
boolean Users::ReadNewSet (string type)
	    </computeroutput></para>
	    <para>
Local and system users (groups) are always read as default in Users::Read()
function.
ReadNewSet () function provides reading of non-standard user (group) set
(this currently means NIS or LDAP) on demand. Function gets the connection
to server where the sets are stored (it could require user interaction) and
generates appropriate ("nis" or "ldap") structures for both users and groups.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::AddUser (map data)
	    </computeroutput></para>
	    <para>
Initialize user data structure for new group. As a parameter, gets data
for new user - the map can be empty (just to fill in defaults) or
almost complete (for example after user added the details via UI) - in this
case use the map of user_in_work format (<xref linkend="non_persistent"/>).

Function
chooses new UID (if not given), fills defaults (from useradd structure),
and copies given data to new user map.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::AddGroup (map data)
	    </computeroutput></para>
	    <para>
Initialize user data structure for new group.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::SelectUser (integer uid)
	    </computeroutput></para>
	    <para>
Finds the user identified by its UID and copies its data from global "users" map
(<xref linkend="persistent"/>) to current user map ("user_in_work":
<xref linkend="non_persistent"/>).
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::SelectUserByName (string username)
	    </computeroutput></para>
	    <para>
Finds the user identified by its name and copies its data to current user map.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::SelectGroup (integer gid)
	    </computeroutput></para>
	    <para>
Finds the group identified by its GID and copies its data from global "groups"
map to current group map ("group_in_work").
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::SelectGroupByName (string groupname)
	    </computeroutput></para>
	    <para>
Finds the group identified by its name and copies its data to current group map.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::EditUser (map data)
	    </computeroutput></para>
	    <para>
Initializes current user map (user_in_work) for editing. Copies the original
(not yet edited) data to 'org_user' submap. Additionaly, loads the data not yet
contained in current user map (like "shadow" values or additional groups
for NIS/LDAP users) from the global structures to the user_in_work map. 
Initialization is the one type of usage of Edit function, in such case its
parameter could be an empty map.
	    </para>
	    <para>
In the second type of usage, function updates current user map using the values
in the given parameter, which is a map with the same format as the user_in_work
(<xref linkend="non_persistent"/>), but containing only the entries with the
changed values.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::EditGroup (map data)
	    </computeroutput></para>
	    <para>
Initializes current group map (group_in_work) for editing and/or fills
current group map with the new values.
	    </para></listitem>
	    <listitem><para><computeroutput>
string Users::CheckUser ()
	    </computeroutput></para>
	    <para>
Function does all necessary checks to ensure that new or just edited user 
can be written (for example the checks for possible UID/username
duplicates, home directory existence etc.). Returns error message of the
first check that failed.
	    </para></listitem>
	    <listitem><para><computeroutput>
string Users::CheckGroup ()
	    </computeroutput></para>
	    <para>
Function does all necessary checks to ensure that new or just edited group 
can be written.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::CommitUser ()
	    </computeroutput></para>
	    <para>
Saves the current user map to global structures and updates all affected
structures. Adapts the (cache) lists of all usernames, uid's, home directories;
adapts the affected groups. Cache structures are adapted in
UsersCache::CommitUser() function.
	    </para>
	    <para>
Take care of special cases, e.g. when username or uid is changed, because both
are used as the indexes in some global structures.
	    </para>
	    <para>
All possible problems should be resolved in check functions before CommitUser is
called, so theoreticaly this function should never fail.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean Users::CommitGroup ()
	    </computeroutput></para>
	    <para>
Saves the current group map to global structures and updates all affected
structures. Cache structures are adapted in UsersCache::CommitGroup() function.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </section>
    </section>
    <section id="module_state"><title>State of the module</title>
      <section id="persistent"><title>Persistent</title>
       <para>
The state of Users module consists from following information (everything
must be exported for autoinstallation):
       <itemizedlist>
	<listitem><para><computeroutput>map users</computeroutput></para>
	 <para>
This structure gatheres informations of all users in the system. (To be more
precise, information of NIS and LDAP users could be read later on demand, so
just after Users::Read call, the map describes the content of /etc/passwd config
file).

The map is indexed by user type (local,system etc.), values are maps of
each type. The inner maps are indexed by UID, values are maps of users.
Such user map has the keys (user attributes, like 'username' or 'home') and its
values describing that user (see user_in_work variable).
	 </para>
	 <para>
Here is the example of 'users' structure, written in YCP:
<screen>
$[
	"local":$[
	    500: $[
		    "cn":"Ha Ha Herman",
		    "username":"hh",
		    "uidNumber":500,
		    "gidNumber":100,
		    "homeDirectory":"/home/hh",
		    "userPassword":"x",
		    "loginShell":"/bin/bash",
		    "type": "local",
		    "grouplist": $[
			    "audio" : 1,
			    "video" : 1,
		    ],
		    "modified": "added",
		    "what": "add_user",
	    ],
	],
	"ldap": $[
	    5000: $[
		    "cn":"LDAP user",
		    "givenName": "LDAP",
		    "sn": "user",
		    "dn": "uid=ldap1,ou=people,dc=suse,dc=cz",
		    "username":"ldap1",
		    "uidNumber":5000,
		    "gidNumber":100,
		    "homeDirectory":"/ldap_homes/ldap1",
		    "userPassword":"x",
		    "loginshell":"/bin/bash",
		
		    "shadowExpire":0,
		    "shadowInact":-1,
		    "shadowLastChange":11984,
		    "shadowMax":99999,
		    "shadowMin":0,
		    "shadowWarn":7,

		    "type": "ldap",
		    "grouplist":  $[
			    "audio" : 1,
			    "video" : 1,
			    "lgroup": 1
		    ],
	    ]
	]
]
</screen>
	</para></listitem>
	<listitem><para><computeroutput>map groups</computeroutput></para>
	 <para>
This structure describes all the groups (which means - as default - the content
of /etc/group config file).
The map is indexed by group type (local,system etc.), values are maps of
each type. The inner maps are indexed by GID, values are maps of groups.
	 </para>
	 <para>
Example of structure:
<screen>
$[
	"local":$[
	    500 :$[
		    "groupname": "users",
		    "gid": 500,
		    "type": "local"
		    "userlist": $[],
		    "more_users": $[ 
			    "hh": 1
		    ],
	    ]
	],
	"system": $[
	    1: $[
		    "groupname": "bin",
		    "gid": 1,
		    "type": "system"
		    "userlist": $[
			    "daemon": 1
		    ],
		    "more_users": $[
			    "bin"   : 1
		    ],
	    ],
	]
]
</screen>
	</para></listitem>
	<listitem><para><computeroutput>map shadow</computeroutput></para>
	 <para>
This is the map indexed by user type (local,system etc.), values are maps of
each type. The inner maps are indexed by username, values are maps of user
shadow settings. This map describes the content of /etc/shadow file.
	 </para>
	</listitem>
	<listitem><para><computeroutput>map useradd_defaults</computeroutput>
	 </para>
	 <para>
This map contains information about default values, used for new users. It
describes /etc/default/useradd config file.
	 </para>
	 <para>
Example of structure:
<screen>
$[
    "group": "500",
    "home": "/home",
    "inactive": "-1",
    "expire": "",
    "shell": "/bin/bash",
    "skel": "/etc/skel",
    "groups": "dialout,uucp,video,audio",
]
</screen>
	</para></listitem>
       </itemizedlist>
       </para>

      </section>
      <section id="non_persistent"><title>Non-persistent</title>
       <para>
Module provides many variables, that affect its behavior, but aren't saved
to any file or exported in export map. Here is the example of some important
ones:
       <itemizedlist>
	<listitem><para><computeroutput>boolean users_modified</computeroutput>
must be set to true whenever user configuration is changed. Otherwise it won't
be saved when exiting.
	</para></listitem>
	<listitem><para><computeroutput>boolean write_only</computeroutput>
should be set to true, if settings should be saved, but daemon shouldn't be
restarted when finishing. Used mostly during autoinstallation.
	</para></listitem>
	<listitem><para>
	<computeroutput>map user_in_work</computeroutput></para>
	 <para>
Map of current user. The maps with the same structure are saved in global
"users" map as the values for UID keys. The map contains: 
	    <itemizedlist>
	      <listitem><para>real data entries</para>
		<para>
these which were read from the config file (/etc/passwd) or other user
repository (LDAP directory) and will be written there at the end, like
"gidNumber", "uidNumber", or "username".
		</para>
	      </listitem>
	      <listitem><para>helper structures</para>
		<para>
these were generated from the "real" data and are stored in the user map just
as in some cache, like "grouplist" (generated from "group" map), "org_home"
(necessary for moving home directory to new location), "type", etc.
		</para>
	      </listitem>
	    </itemizedlist>
	 </para>
	 <para>
Example of user_in_work structure:
<screen>
$[
	    "cn":"LDAP user",
	    "givenName": "LDAP",
	    "sn": "user",
	    "dn": "uid=ldap1,ou=people,dc=suse,dc=cz",
	    "username":"ldap1",
	    "uidNumber":5000,
	    "gidNumber":100,
	    "homeDirectory":"/ldap_homes/ldap1",
	    "userPassword":"x",
	    "loginshell":"/bin/bash",
	    "shadowExpire":0,
	    "shadowInact":-1,
	    "shadowLastChange":11984,
	    "shadowMax":99999,
	    "shadowMin":0,
	    "shadowWarn":7,
	    "type": "ldap",
	    "grouplist":  $[
			    "audio" : 1,
			    "video" : 1,
			    "lgroup": 1
	    ],
]
</screen>
	 </para>
	</listitem>
	<listitem><para><computeroutput>map group_in_work</computeroutput></para>
	 <para>
Map of current group. Such maps are saved in global "groups" map as the values
for GID keys.
	 </para>
	</listitem>
       </itemizedlist>
       </para>
      </section>
    </section>
  </section>
  <section><title>UsersCache module</title>
    <para>
The UsersCache module has this task:
      <itemizedlist>
	<listitem><para>Create and manage temporary structures enabling fast
access to special parts of structures in Users module
	</para>
	<para>
For example, it is better to manage list of all user names than to
generate it from global Users::users structure every time it is necessary.
	</para></listitem>
      </itemizedlist>
    </para>
    <para>
Here is the example of variables ("cache structures") UsersCache module has to
manage:
      <itemizedlist>
	<listitem><para><computeroutput>map usernames</computeroutput></para>
	 <para>
map indexed by user type, values are maps with user names of each type
	 </para>
	 <para>
Example of usernames structure:
<screen>
$[
	"system": $[
	    "root": 1,	
	    "bin" : 1,
	    "daemon": 1,
	    ...
	]
	"local":$[
	    "users": 1,
	]
]
</screen>
	 </para>
	</listitem>
	<listitem><para><computeroutput>map uids</computeroutput></para>
	 <para>
map indexed by user type, values are maps with UID's of each type
	 </para>
	</listitem>
	<listitem><para><computeroutput>map homes</computeroutput></para>
	 <para>
map indexed by user type, values are maps with home directories for users of
each type
	 </para>
	</listitem>
	<listitem><para><computeroutput>map user_items</computeroutput></para>
	 <para>
map indexed by user type, values are maps with user items to be shown in the
table in Summary dialog
	 </para>
	</listitem>
	<listitem><para><computeroutput>map groupnamelist</computeroutput></para>
	 <para>
map indexed by group type, values are maps with group names of each type
	 </para>
	</listitem>
	<listitem><para><computeroutput>map gids</computeroutput></para>
	 <para>
map indexed by group type, values are maps with GID's of groups of each type
	 </para>
	</listitem>
      </itemizedlist>
    </para>
    <section><title>Functions</title>
      <section><title>General</title>
	<itemizedlist>
	  <listitem><para><computeroutput>
global define boolean Read ();
	  </computeroutput>
	  </para><para>
reads the settings (generate the cache structures from the global setting from
module Users). Returns true on success.
	    </para>
	  </listitem>
	</itemizedlist>
      </section>
      <section><title>Global</title>
	<para>
Additionaly, following functions will be available:
	  <itemizedlist>
	    <listitem><para><computeroutput>
boolean UsersCache::CommitUser (map data)
	    </computeroutput></para>
	    <para>
Updates cache structures after the change of one user was done. It is called
from Users::CommitUser function.
	    </para></listitem>
	    <listitem><para><computeroutput>
boolean UsersCache::CommitGroup (map data)
	    </computeroutput></para>
	    <para>
Updates cache structures after the change of one group was done. It is called
from Users::CommitGroup function.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </section>
    </section>
  </section>
  <section id="scr_passwd"><title>Agent for system files</title>
    <para>
The task of this agent is to provide reading and writing functionality
of /etc/passwd, /etc/group and /etc/shadow configuration files.
    </para>
      <section><title>Agent's functions</title>
	<para>
When agent is run for first time (= during the first agent call), it reads all
structures it needs (contents of /etc/passwd, /etc/group and /etc/shadow config
files) and generates all the structures that are necessary for Users::Read()
function.
	</para>
	<para>
Here is an example of specialized agent calls:
	  <itemizedlist>
	    <listitem><para>
	     <computeroutput>Read (.passwd.local.users) -> map
	     </computeroutput>
	     </para><para>
gets "local" entry for Users::users map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.passwd.system.users) -> map</computeroutput>
	     </para><para>
gets "system" entry for Users::users map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.passwd.local.groups) -> map</computeroutput>
	     </para><para>
gets "local" entry for Users::groups map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.passwd.local.shadow) -> map</computeroutput>
	     </para><para>
gets "local" entry for Users::shadow map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.passwd.local.users.usernames) -> map
	     </computeroutput>
	     </para><para>
gets "local" entry for UsersCache::usernames map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.passwd.local.users.items) -> map
	     </computeroutput>
	     </para><para>
gets "local" entry for UsersCache::user_items map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Write (.passwd.users, users) -> boolean
	     </computeroutput>
	     </para><para>
writes both system and local users to the /etc/passwd file. Return value is the
success of the operation.
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Write (.passwd.groups, groups) -> boolean
	     </computeroutput>
	     </para><para>
writes both system and local groups to the /etc/group file.
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Write (.passwd.shadow, shadow) -> boolean
	     </computeroutput>
	     </para><para>
writes both system and local user settings to the /etc/shadow file.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </section>
  </section>
  <section id="scr_nis"><title>Agent for reading NIS users/groups</title>
    <para>
The task of this agent is to provide reading of users and groups stored at the
NIS server.
    </para>
      <section><title>Agent's functions</title>
	<para>
When agent is run for first time (= during the first agent call), it reads all
structures it needs (both user and group lists stored at NIS server) and
generates all the structures that are necessary for read functions.
Examples of calls:
	  <itemizedlist>
	    <listitem><para>
	     <computeroutput>Read (.nis.users) -> map
	     </computeroutput>
	     </para><para>
gets "nis" entry fot Users::users map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.nis.groups) -> map
	     </computeroutput>
	     </para><para>
gets "nis" entry for Users::groups map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.nis.users.items) -> map
	     </computeroutput>
	     </para><para>
gets "nis" entry for UsersCache::user_items map
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.nis.groups.items) -> map
	     </computeroutput>
	     </para><para>
gets "nis" entry for UsersCache::group_items map
	    </para></listitem>
	  </itemizedlist>
The agent doesn't provide Write functions.
	</para>
      </section>
  </section>
  <section id="scr_defaults"><title>Agent for user defaults</title>
    <para>
This agent provides read and write access to /etc/default/useradd file.
The Users::useradd_defaults map is described in <xref linkend="module_state"/>.
    </para>
      <section><title>Agent's functions</title>
	<para>
	  <itemizedlist>
	    <listitem><para>
	    <computeroutput>Read (.etc.default.useradd) -> map
	    </computeroutput>
	     </para><para>
reads Users::useradd_defaults map.
	    </para></listitem>
	    <listitem><para>
	    <computeroutput>Write (.etc.default.useradd, useradd_defaults) -> boolean
	    </computeroutput>
	     </para><para>
writes useradd_defaults map to /etc/default/useradd.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </section>
  </section>
  <section id="scr_crack"><title>Agent for testing password strength</title>
    <para>
The task of this agent is to test the "strength" of user password
using the "cracklib" library. This feature is optional.
    </para>
      <section><title>Agent's function</title>
	<para>
	  <itemizedlist>
	    <listitem><para>
	     <computeroutput>Execute (.crack, password, dictpath) -> string
	     </computeroutput>
	     </para><para>
The "password" argument is user password to be checked, the "dictpath" argument
is the path to cracklib dictionary (can be emtpy). Return value is an empty
string (when password is strong enough) or cracklib error message.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </section>
  </section>
  <section id="scr_uid"><title>Agent for testing UID/username existence</title>
    <para>
The task of this agent is to check if user UID or username already exist in the
system. The agent uses getpwuid() and getpwnam() calls for the tests.
    </para>
      <section><title>Agent's functions</title>
	<para>
	  <itemizedlist>
	    <listitem><para>
	     <computeroutput>Read (.uid.uid, id) -> boolean
	     </computeroutput>
	     </para><para>
Returns true if no user has "id" as UID.
	    </para></listitem>
	    <listitem><para>
	     <computeroutput>Read (.uid.username, name) -> boolean
	     </computeroutput>
	     </para><para>
Returns true if no user has "name" as username.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </section>
  </section>
</chapter>
</book>
